// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak.proto

#ifndef PROTOBUF_riak_2eproto__INCLUDED
#define PROTOBUF_riak_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riak_2eproto();
void protobuf_AssignDesc_riak_2eproto();
void protobuf_ShutdownFile_riak_2eproto();

class MapField;
class MapEntry;
class DtFetchReq;
class DtValue;
class DtFetchResp;
class CounterOp;
class SetOp;
class MapUpdate;
class MapOp;
class DtOp;
class DtUpdateReq;
class DtUpdateResp;
class RpbGetClientIdResp;
class RpbSetClientIdReq;
class RpbGetReq;
class RpbGetResp;
class RpbPutReq;
class RpbPutResp;
class RpbDelReq;
class RpbListBucketsReq;
class RpbListBucketsResp;
class RpbListKeysReq;
class RpbListKeysResp;
class RpbMapRedReq;
class RpbMapRedResp;
class RpbIndexReq;
class RpbIndexResp;
class RpbIndexBodyResp;
class RpbCSBucketReq;
class RpbCSBucketResp;
class RpbIndexObject;
class RpbContent;
class RpbLink;
class RpbCounterUpdateReq;
class RpbCounterUpdateResp;
class RpbCounterGetReq;
class RpbCounterGetResp;
class RpbGetBucketKeyPreflistReq;
class RpbGetBucketKeyPreflistResp;
class RpbBucketKeyPreflistItem;
class RpbCoverageReq;
class RpbCoverageResp;
class RpbCoverageEntry;
class RpbErrorResp;
class RpbGetServerInfoResp;
class RpbPair;
class RpbGetBucketReq;
class RpbGetBucketResp;
class RpbSetBucketReq;
class RpbResetBucketReq;
class RpbGetBucketTypeReq;
class RpbSetBucketTypeReq;
class RpbModFun;
class RpbCommitHook;
class RpbBucketProps;
class RpbAuthReq;
class RpbToggleEncodingReq;
class RpbToggleEncodingResp;
class RpbSearchDoc;
class RpbSearchQueryReq;
class RpbSearchQueryResp;
class TsQueryReq;
class TsQueryResp;
class TsGetReq;
class TsGetResp;
class TsPutReq;
class TsTtbPutReq;
class TsPutResp;
class TsDelReq;
class TsDelResp;
class TsInterpolation;
class TsColumnDescription;
class TsRow;
class TsCell;
class TsListKeysReq;
class TsListKeysResp;
class TsCoverageReq;
class TsCoverageResp;
class TsCoverageEntry;
class TsRange;
class RpbYokozunaIndex;
class RpbYokozunaIndexGetReq;
class RpbYokozunaIndexGetResp;
class RpbYokozunaIndexPutReq;
class RpbYokozunaIndexDeleteReq;
class RpbYokozunaSchema;
class RpbYokozunaSchemaPutReq;
class RpbYokozunaSchemaGetReq;
class RpbYokozunaSchemaGetResp;

enum MapField_MapFieldType {
  MapField_MapFieldType_COUNTER = 1,
  MapField_MapFieldType_SET = 2,
  MapField_MapFieldType_REGISTER = 3,
  MapField_MapFieldType_FLAG = 4,
  MapField_MapFieldType_MAP = 5
};
bool MapField_MapFieldType_IsValid(int value);
const MapField_MapFieldType MapField_MapFieldType_MapFieldType_MIN = MapField_MapFieldType_COUNTER;
const MapField_MapFieldType MapField_MapFieldType_MapFieldType_MAX = MapField_MapFieldType_MAP;
const int MapField_MapFieldType_MapFieldType_ARRAYSIZE = MapField_MapFieldType_MapFieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapField_MapFieldType_descriptor();
inline const ::std::string& MapField_MapFieldType_Name(MapField_MapFieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapField_MapFieldType_descriptor(), value);
}
inline bool MapField_MapFieldType_Parse(
    const ::std::string& name, MapField_MapFieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapField_MapFieldType>(
    MapField_MapFieldType_descriptor(), name, value);
}
enum DtFetchResp_DataType {
  DtFetchResp_DataType_COUNTER = 1,
  DtFetchResp_DataType_SET = 2,
  DtFetchResp_DataType_MAP = 3
};
bool DtFetchResp_DataType_IsValid(int value);
const DtFetchResp_DataType DtFetchResp_DataType_DataType_MIN = DtFetchResp_DataType_COUNTER;
const DtFetchResp_DataType DtFetchResp_DataType_DataType_MAX = DtFetchResp_DataType_MAP;
const int DtFetchResp_DataType_DataType_ARRAYSIZE = DtFetchResp_DataType_DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DtFetchResp_DataType_descriptor();
inline const ::std::string& DtFetchResp_DataType_Name(DtFetchResp_DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DtFetchResp_DataType_descriptor(), value);
}
inline bool DtFetchResp_DataType_Parse(
    const ::std::string& name, DtFetchResp_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DtFetchResp_DataType>(
    DtFetchResp_DataType_descriptor(), name, value);
}
enum MapUpdate_FlagOp {
  MapUpdate_FlagOp_ENABLE = 1,
  MapUpdate_FlagOp_DISABLE = 2
};
bool MapUpdate_FlagOp_IsValid(int value);
const MapUpdate_FlagOp MapUpdate_FlagOp_FlagOp_MIN = MapUpdate_FlagOp_ENABLE;
const MapUpdate_FlagOp MapUpdate_FlagOp_FlagOp_MAX = MapUpdate_FlagOp_DISABLE;
const int MapUpdate_FlagOp_FlagOp_ARRAYSIZE = MapUpdate_FlagOp_FlagOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapUpdate_FlagOp_descriptor();
inline const ::std::string& MapUpdate_FlagOp_Name(MapUpdate_FlagOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapUpdate_FlagOp_descriptor(), value);
}
inline bool MapUpdate_FlagOp_Parse(
    const ::std::string& name, MapUpdate_FlagOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapUpdate_FlagOp>(
    MapUpdate_FlagOp_descriptor(), name, value);
}
enum RpbIndexReq_IndexQueryType {
  RpbIndexReq_IndexQueryType_eq = 0,
  RpbIndexReq_IndexQueryType_range = 1
};
bool RpbIndexReq_IndexQueryType_IsValid(int value);
const RpbIndexReq_IndexQueryType RpbIndexReq_IndexQueryType_IndexQueryType_MIN = RpbIndexReq_IndexQueryType_eq;
const RpbIndexReq_IndexQueryType RpbIndexReq_IndexQueryType_IndexQueryType_MAX = RpbIndexReq_IndexQueryType_range;
const int RpbIndexReq_IndexQueryType_IndexQueryType_ARRAYSIZE = RpbIndexReq_IndexQueryType_IndexQueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpbIndexReq_IndexQueryType_descriptor();
inline const ::std::string& RpbIndexReq_IndexQueryType_Name(RpbIndexReq_IndexQueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpbIndexReq_IndexQueryType_descriptor(), value);
}
inline bool RpbIndexReq_IndexQueryType_Parse(
    const ::std::string& name, RpbIndexReq_IndexQueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpbIndexReq_IndexQueryType>(
    RpbIndexReq_IndexQueryType_descriptor(), name, value);
}
enum RpbBucketProps_RpbReplMode {
  RpbBucketProps_RpbReplMode_FALSE = 0,
  RpbBucketProps_RpbReplMode_REALTIME = 1,
  RpbBucketProps_RpbReplMode_FULLSYNC = 2,
  RpbBucketProps_RpbReplMode_TRUE = 3
};
bool RpbBucketProps_RpbReplMode_IsValid(int value);
const RpbBucketProps_RpbReplMode RpbBucketProps_RpbReplMode_RpbReplMode_MIN = RpbBucketProps_RpbReplMode_FALSE;
const RpbBucketProps_RpbReplMode RpbBucketProps_RpbReplMode_RpbReplMode_MAX = RpbBucketProps_RpbReplMode_TRUE;
const int RpbBucketProps_RpbReplMode_RpbReplMode_ARRAYSIZE = RpbBucketProps_RpbReplMode_RpbReplMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpbBucketProps_RpbReplMode_descriptor();
inline const ::std::string& RpbBucketProps_RpbReplMode_Name(RpbBucketProps_RpbReplMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpbBucketProps_RpbReplMode_descriptor(), value);
}
inline bool RpbBucketProps_RpbReplMode_Parse(
    const ::std::string& name, RpbBucketProps_RpbReplMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpbBucketProps_RpbReplMode>(
    RpbBucketProps_RpbReplMode_descriptor(), name, value);
}
enum TsColumnType {
  VARCHAR = 0,
  SINT64 = 1,
  DOUBLE = 2,
  TIMESTAMP = 3,
  BOOLEAN = 4
};
bool TsColumnType_IsValid(int value);
const TsColumnType TsColumnType_MIN = VARCHAR;
const TsColumnType TsColumnType_MAX = BOOLEAN;
const int TsColumnType_ARRAYSIZE = TsColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TsColumnType_descriptor();
inline const ::std::string& TsColumnType_Name(TsColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TsColumnType_descriptor(), value);
}
inline bool TsColumnType_Parse(
    const ::std::string& name, TsColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TsColumnType>(
    TsColumnType_descriptor(), name, value);
}
// ===================================================================

class MapField : public ::google::protobuf::Message {
 public:
  MapField();
  virtual ~MapField();

  MapField(const MapField& from);

  inline MapField& operator=(const MapField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapField& default_instance();

  void Swap(MapField* other);

  // implements Message ----------------------------------------------

  MapField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapField& from);
  void MergeFrom(const MapField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MapField_MapFieldType MapFieldType;
  static const MapFieldType COUNTER = MapField_MapFieldType_COUNTER;
  static const MapFieldType SET = MapField_MapFieldType_SET;
  static const MapFieldType REGISTER = MapField_MapFieldType_REGISTER;
  static const MapFieldType FLAG = MapField_MapFieldType_FLAG;
  static const MapFieldType MAP = MapField_MapFieldType_MAP;
  static inline bool MapFieldType_IsValid(int value) {
    return MapField_MapFieldType_IsValid(value);
  }
  static const MapFieldType MapFieldType_MIN =
    MapField_MapFieldType_MapFieldType_MIN;
  static const MapFieldType MapFieldType_MAX =
    MapField_MapFieldType_MapFieldType_MAX;
  static const int MapFieldType_ARRAYSIZE =
    MapField_MapFieldType_MapFieldType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MapFieldType_descriptor() {
    return MapField_MapFieldType_descriptor();
  }
  static inline const ::std::string& MapFieldType_Name(MapFieldType value) {
    return MapField_MapFieldType_Name(value);
  }
  static inline bool MapFieldType_Parse(const ::std::string& name,
      MapFieldType* value) {
    return MapField_MapFieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .MapField.MapFieldType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::MapField_MapFieldType type() const;
  inline void set_type(::MapField_MapFieldType value);

  // @@protoc_insertion_point(class_scope:MapField)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static MapField* default_instance_;
};
// -------------------------------------------------------------------

class MapEntry : public ::google::protobuf::Message {
 public:
  MapEntry();
  virtual ~MapEntry();

  MapEntry(const MapEntry& from);

  inline MapEntry& operator=(const MapEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntry& default_instance();

  void Swap(MapEntry* other);

  // implements Message ----------------------------------------------

  MapEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapEntry& from);
  void MergeFrom(const MapEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MapField field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::MapField& field() const;
  inline ::MapField* mutable_field();
  inline ::MapField* release_field();
  inline void set_allocated_field(::MapField* field);

  // optional sint64 counter_value = 2;
  inline bool has_counter_value() const;
  inline void clear_counter_value();
  static const int kCounterValueFieldNumber = 2;
  inline ::google::protobuf::int64 counter_value() const;
  inline void set_counter_value(::google::protobuf::int64 value);

  // repeated bytes set_value = 3;
  inline int set_value_size() const;
  inline void clear_set_value();
  static const int kSetValueFieldNumber = 3;
  inline const ::std::string& set_value(int index) const;
  inline ::std::string* mutable_set_value(int index);
  inline void set_set_value(int index, const ::std::string& value);
  inline void set_set_value(int index, const char* value);
  inline void set_set_value(int index, const void* value, size_t size);
  inline ::std::string* add_set_value();
  inline void add_set_value(const ::std::string& value);
  inline void add_set_value(const char* value);
  inline void add_set_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& set_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_set_value();

  // optional bytes register_value = 4;
  inline bool has_register_value() const;
  inline void clear_register_value();
  static const int kRegisterValueFieldNumber = 4;
  inline const ::std::string& register_value() const;
  inline void set_register_value(const ::std::string& value);
  inline void set_register_value(const char* value);
  inline void set_register_value(const void* value, size_t size);
  inline ::std::string* mutable_register_value();
  inline ::std::string* release_register_value();
  inline void set_allocated_register_value(::std::string* register_value);

  // optional bool flag_value = 5;
  inline bool has_flag_value() const;
  inline void clear_flag_value();
  static const int kFlagValueFieldNumber = 5;
  inline bool flag_value() const;
  inline void set_flag_value(bool value);

  // repeated .MapEntry map_value = 6;
  inline int map_value_size() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 6;
  inline const ::MapEntry& map_value(int index) const;
  inline ::MapEntry* mutable_map_value(int index);
  inline ::MapEntry* add_map_value();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
      map_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
      mutable_map_value();

  // @@protoc_insertion_point(class_scope:MapEntry)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_counter_value();
  inline void clear_has_counter_value();
  inline void set_has_register_value();
  inline void clear_has_register_value();
  inline void set_has_flag_value();
  inline void clear_has_flag_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MapField* field_;
  ::google::protobuf::int64 counter_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> set_value_;
  ::std::string* register_value_;
  ::google::protobuf::RepeatedPtrField< ::MapEntry > map_value_;
  bool flag_value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static MapEntry* default_instance_;
};
// -------------------------------------------------------------------

class DtFetchReq : public ::google::protobuf::Message {
 public:
  DtFetchReq();
  virtual ~DtFetchReq();

  DtFetchReq(const DtFetchReq& from);

  inline DtFetchReq& operator=(const DtFetchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtFetchReq& default_instance();

  void Swap(DtFetchReq* other);

  // implements Message ----------------------------------------------

  DtFetchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtFetchReq& from);
  void MergeFrom(const DtFetchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional uint32 r = 4;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 4;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 pr = 5;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 5;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 6;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 6;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 7;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 7;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // optional uint32 timeout = 8;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 9;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 9;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 10;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 10;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bool include_context = 11 [default = true];
  inline bool has_include_context() const;
  inline void clear_include_context();
  static const int kIncludeContextFieldNumber = 11;
  inline bool include_context() const;
  inline void set_include_context(bool value);

  // @@protoc_insertion_point(class_scope:DtFetchReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_include_context();
  inline void clear_has_include_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* type_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 timeout_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool sloppy_quorum_;
  bool include_context_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static DtFetchReq* default_instance_;
};
// -------------------------------------------------------------------

class DtValue : public ::google::protobuf::Message {
 public:
  DtValue();
  virtual ~DtValue();

  DtValue(const DtValue& from);

  inline DtValue& operator=(const DtValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtValue& default_instance();

  void Swap(DtValue* other);

  // implements Message ----------------------------------------------

  DtValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtValue& from);
  void MergeFrom(const DtValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 counter_value = 1;
  inline bool has_counter_value() const;
  inline void clear_counter_value();
  static const int kCounterValueFieldNumber = 1;
  inline ::google::protobuf::int64 counter_value() const;
  inline void set_counter_value(::google::protobuf::int64 value);

  // repeated bytes set_value = 2;
  inline int set_value_size() const;
  inline void clear_set_value();
  static const int kSetValueFieldNumber = 2;
  inline const ::std::string& set_value(int index) const;
  inline ::std::string* mutable_set_value(int index);
  inline void set_set_value(int index, const ::std::string& value);
  inline void set_set_value(int index, const char* value);
  inline void set_set_value(int index, const void* value, size_t size);
  inline ::std::string* add_set_value();
  inline void add_set_value(const ::std::string& value);
  inline void add_set_value(const char* value);
  inline void add_set_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& set_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_set_value();

  // repeated .MapEntry map_value = 3;
  inline int map_value_size() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 3;
  inline const ::MapEntry& map_value(int index) const;
  inline ::MapEntry* mutable_map_value(int index);
  inline ::MapEntry* add_map_value();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
      map_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
      mutable_map_value();

  // @@protoc_insertion_point(class_scope:DtValue)
 private:
  inline void set_has_counter_value();
  inline void clear_has_counter_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 counter_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> set_value_;
  ::google::protobuf::RepeatedPtrField< ::MapEntry > map_value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static DtValue* default_instance_;
};
// -------------------------------------------------------------------

class DtFetchResp : public ::google::protobuf::Message {
 public:
  DtFetchResp();
  virtual ~DtFetchResp();

  DtFetchResp(const DtFetchResp& from);

  inline DtFetchResp& operator=(const DtFetchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtFetchResp& default_instance();

  void Swap(DtFetchResp* other);

  // implements Message ----------------------------------------------

  DtFetchResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtFetchResp& from);
  void MergeFrom(const DtFetchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DtFetchResp_DataType DataType;
  static const DataType COUNTER = DtFetchResp_DataType_COUNTER;
  static const DataType SET = DtFetchResp_DataType_SET;
  static const DataType MAP = DtFetchResp_DataType_MAP;
  static inline bool DataType_IsValid(int value) {
    return DtFetchResp_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    DtFetchResp_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    DtFetchResp_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    DtFetchResp_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataType_descriptor() {
    return DtFetchResp_DataType_descriptor();
  }
  static inline const ::std::string& DataType_Name(DataType value) {
    return DtFetchResp_DataType_Name(value);
  }
  static inline bool DataType_Parse(const ::std::string& name,
      DataType* value) {
    return DtFetchResp_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes context = 1;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // required .DtFetchResp.DataType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::DtFetchResp_DataType type() const;
  inline void set_type(::DtFetchResp_DataType value);

  // optional .DtValue value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::DtValue& value() const;
  inline ::DtValue* mutable_value();
  inline ::DtValue* release_value();
  inline void set_allocated_value(::DtValue* value);

  // @@protoc_insertion_point(class_scope:DtFetchResp)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* context_;
  ::DtValue* value_;
  int type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static DtFetchResp* default_instance_;
};
// -------------------------------------------------------------------

class CounterOp : public ::google::protobuf::Message {
 public:
  CounterOp();
  virtual ~CounterOp();

  CounterOp(const CounterOp& from);

  inline CounterOp& operator=(const CounterOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CounterOp& default_instance();

  void Swap(CounterOp* other);

  // implements Message ----------------------------------------------

  CounterOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CounterOp& from);
  void MergeFrom(const CounterOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 increment = 1;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 1;
  inline ::google::protobuf::int64 increment() const;
  inline void set_increment(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CounterOp)
 private:
  inline void set_has_increment();
  inline void clear_has_increment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 increment_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static CounterOp* default_instance_;
};
// -------------------------------------------------------------------

class SetOp : public ::google::protobuf::Message {
 public:
  SetOp();
  virtual ~SetOp();

  SetOp(const SetOp& from);

  inline SetOp& operator=(const SetOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetOp& default_instance();

  void Swap(SetOp* other);

  // implements Message ----------------------------------------------

  SetOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetOp& from);
  void MergeFrom(const SetOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes adds = 1;
  inline int adds_size() const;
  inline void clear_adds();
  static const int kAddsFieldNumber = 1;
  inline const ::std::string& adds(int index) const;
  inline ::std::string* mutable_adds(int index);
  inline void set_adds(int index, const ::std::string& value);
  inline void set_adds(int index, const char* value);
  inline void set_adds(int index, const void* value, size_t size);
  inline ::std::string* add_adds();
  inline void add_adds(const ::std::string& value);
  inline void add_adds(const char* value);
  inline void add_adds(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& adds() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_adds();

  // repeated bytes removes = 2;
  inline int removes_size() const;
  inline void clear_removes();
  static const int kRemovesFieldNumber = 2;
  inline const ::std::string& removes(int index) const;
  inline ::std::string* mutable_removes(int index);
  inline void set_removes(int index, const ::std::string& value);
  inline void set_removes(int index, const char* value);
  inline void set_removes(int index, const void* value, size_t size);
  inline ::std::string* add_removes();
  inline void add_removes(const ::std::string& value);
  inline void add_removes(const char* value);
  inline void add_removes(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& removes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_removes();

  // @@protoc_insertion_point(class_scope:SetOp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> adds_;
  ::google::protobuf::RepeatedPtrField< ::std::string> removes_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static SetOp* default_instance_;
};
// -------------------------------------------------------------------

class MapUpdate : public ::google::protobuf::Message {
 public:
  MapUpdate();
  virtual ~MapUpdate();

  MapUpdate(const MapUpdate& from);

  inline MapUpdate& operator=(const MapUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapUpdate& default_instance();

  void Swap(MapUpdate* other);

  // implements Message ----------------------------------------------

  MapUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapUpdate& from);
  void MergeFrom(const MapUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MapUpdate_FlagOp FlagOp;
  static const FlagOp ENABLE = MapUpdate_FlagOp_ENABLE;
  static const FlagOp DISABLE = MapUpdate_FlagOp_DISABLE;
  static inline bool FlagOp_IsValid(int value) {
    return MapUpdate_FlagOp_IsValid(value);
  }
  static const FlagOp FlagOp_MIN =
    MapUpdate_FlagOp_FlagOp_MIN;
  static const FlagOp FlagOp_MAX =
    MapUpdate_FlagOp_FlagOp_MAX;
  static const int FlagOp_ARRAYSIZE =
    MapUpdate_FlagOp_FlagOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlagOp_descriptor() {
    return MapUpdate_FlagOp_descriptor();
  }
  static inline const ::std::string& FlagOp_Name(FlagOp value) {
    return MapUpdate_FlagOp_Name(value);
  }
  static inline bool FlagOp_Parse(const ::std::string& name,
      FlagOp* value) {
    return MapUpdate_FlagOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MapField field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::MapField& field() const;
  inline ::MapField* mutable_field();
  inline ::MapField* release_field();
  inline void set_allocated_field(::MapField* field);

  // optional .CounterOp counter_op = 2;
  inline bool has_counter_op() const;
  inline void clear_counter_op();
  static const int kCounterOpFieldNumber = 2;
  inline const ::CounterOp& counter_op() const;
  inline ::CounterOp* mutable_counter_op();
  inline ::CounterOp* release_counter_op();
  inline void set_allocated_counter_op(::CounterOp* counter_op);

  // optional .SetOp set_op = 3;
  inline bool has_set_op() const;
  inline void clear_set_op();
  static const int kSetOpFieldNumber = 3;
  inline const ::SetOp& set_op() const;
  inline ::SetOp* mutable_set_op();
  inline ::SetOp* release_set_op();
  inline void set_allocated_set_op(::SetOp* set_op);

  // optional bytes register_op = 4;
  inline bool has_register_op() const;
  inline void clear_register_op();
  static const int kRegisterOpFieldNumber = 4;
  inline const ::std::string& register_op() const;
  inline void set_register_op(const ::std::string& value);
  inline void set_register_op(const char* value);
  inline void set_register_op(const void* value, size_t size);
  inline ::std::string* mutable_register_op();
  inline ::std::string* release_register_op();
  inline void set_allocated_register_op(::std::string* register_op);

  // optional .MapUpdate.FlagOp flag_op = 5;
  inline bool has_flag_op() const;
  inline void clear_flag_op();
  static const int kFlagOpFieldNumber = 5;
  inline ::MapUpdate_FlagOp flag_op() const;
  inline void set_flag_op(::MapUpdate_FlagOp value);

  // optional .MapOp map_op = 6;
  inline bool has_map_op() const;
  inline void clear_map_op();
  static const int kMapOpFieldNumber = 6;
  inline const ::MapOp& map_op() const;
  inline ::MapOp* mutable_map_op();
  inline ::MapOp* release_map_op();
  inline void set_allocated_map_op(::MapOp* map_op);

  // @@protoc_insertion_point(class_scope:MapUpdate)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_counter_op();
  inline void clear_has_counter_op();
  inline void set_has_set_op();
  inline void clear_has_set_op();
  inline void set_has_register_op();
  inline void clear_has_register_op();
  inline void set_has_flag_op();
  inline void clear_has_flag_op();
  inline void set_has_map_op();
  inline void clear_has_map_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MapField* field_;
  ::CounterOp* counter_op_;
  ::SetOp* set_op_;
  ::std::string* register_op_;
  ::MapOp* map_op_;
  int flag_op_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static MapUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MapOp : public ::google::protobuf::Message {
 public:
  MapOp();
  virtual ~MapOp();

  MapOp(const MapOp& from);

  inline MapOp& operator=(const MapOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapOp& default_instance();

  void Swap(MapOp* other);

  // implements Message ----------------------------------------------

  MapOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapOp& from);
  void MergeFrom(const MapOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapField removes = 1;
  inline int removes_size() const;
  inline void clear_removes();
  static const int kRemovesFieldNumber = 1;
  inline const ::MapField& removes(int index) const;
  inline ::MapField* mutable_removes(int index);
  inline ::MapField* add_removes();
  inline const ::google::protobuf::RepeatedPtrField< ::MapField >&
      removes() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapField >*
      mutable_removes();

  // repeated .MapUpdate updates = 2;
  inline int updates_size() const;
  inline void clear_updates();
  static const int kUpdatesFieldNumber = 2;
  inline const ::MapUpdate& updates(int index) const;
  inline ::MapUpdate* mutable_updates(int index);
  inline ::MapUpdate* add_updates();
  inline const ::google::protobuf::RepeatedPtrField< ::MapUpdate >&
      updates() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapUpdate >*
      mutable_updates();

  // @@protoc_insertion_point(class_scope:MapOp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MapField > removes_;
  ::google::protobuf::RepeatedPtrField< ::MapUpdate > updates_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static MapOp* default_instance_;
};
// -------------------------------------------------------------------

class DtOp : public ::google::protobuf::Message {
 public:
  DtOp();
  virtual ~DtOp();

  DtOp(const DtOp& from);

  inline DtOp& operator=(const DtOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtOp& default_instance();

  void Swap(DtOp* other);

  // implements Message ----------------------------------------------

  DtOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtOp& from);
  void MergeFrom(const DtOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CounterOp counter_op = 1;
  inline bool has_counter_op() const;
  inline void clear_counter_op();
  static const int kCounterOpFieldNumber = 1;
  inline const ::CounterOp& counter_op() const;
  inline ::CounterOp* mutable_counter_op();
  inline ::CounterOp* release_counter_op();
  inline void set_allocated_counter_op(::CounterOp* counter_op);

  // optional .SetOp set_op = 2;
  inline bool has_set_op() const;
  inline void clear_set_op();
  static const int kSetOpFieldNumber = 2;
  inline const ::SetOp& set_op() const;
  inline ::SetOp* mutable_set_op();
  inline ::SetOp* release_set_op();
  inline void set_allocated_set_op(::SetOp* set_op);

  // optional .MapOp map_op = 3;
  inline bool has_map_op() const;
  inline void clear_map_op();
  static const int kMapOpFieldNumber = 3;
  inline const ::MapOp& map_op() const;
  inline ::MapOp* mutable_map_op();
  inline ::MapOp* release_map_op();
  inline void set_allocated_map_op(::MapOp* map_op);

  // @@protoc_insertion_point(class_scope:DtOp)
 private:
  inline void set_has_counter_op();
  inline void clear_has_counter_op();
  inline void set_has_set_op();
  inline void clear_has_set_op();
  inline void set_has_map_op();
  inline void clear_has_map_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CounterOp* counter_op_;
  ::SetOp* set_op_;
  ::MapOp* map_op_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static DtOp* default_instance_;
};
// -------------------------------------------------------------------

class DtUpdateReq : public ::google::protobuf::Message {
 public:
  DtUpdateReq();
  virtual ~DtUpdateReq();

  DtUpdateReq(const DtUpdateReq& from);

  inline DtUpdateReq& operator=(const DtUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtUpdateReq& default_instance();

  void Swap(DtUpdateReq* other);

  // implements Message ----------------------------------------------

  DtUpdateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtUpdateReq& from);
  void MergeFrom(const DtUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes context = 4;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 4;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // required .DtOp op = 5;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 5;
  inline const ::DtOp& op() const;
  inline ::DtOp* mutable_op();
  inline ::DtOp* release_op();
  inline void set_allocated_op(::DtOp* op);

  // optional uint32 w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 7;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 7;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional bool return_body = 9 [default = false];
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 9;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // optional uint32 timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 11;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 11;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 12;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 12;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bool include_context = 13 [default = true];
  inline bool has_include_context() const;
  inline void clear_include_context();
  static const int kIncludeContextFieldNumber = 13;
  inline bool include_context() const;
  inline void set_include_context(bool value);

  // @@protoc_insertion_point(class_scope:DtUpdateReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_return_body();
  inline void clear_has_return_body();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_include_context();
  inline void clear_has_include_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* type_;
  ::std::string* context_;
  ::DtOp* op_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 timeout_;
  bool return_body_;
  bool sloppy_quorum_;
  bool include_context_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static DtUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class DtUpdateResp : public ::google::protobuf::Message {
 public:
  DtUpdateResp();
  virtual ~DtUpdateResp();

  DtUpdateResp(const DtUpdateResp& from);

  inline DtUpdateResp& operator=(const DtUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtUpdateResp& default_instance();

  void Swap(DtUpdateResp* other);

  // implements Message ----------------------------------------------

  DtUpdateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtUpdateResp& from);
  void MergeFrom(const DtUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // optional sint64 counter_value = 3;
  inline bool has_counter_value() const;
  inline void clear_counter_value();
  static const int kCounterValueFieldNumber = 3;
  inline ::google::protobuf::int64 counter_value() const;
  inline void set_counter_value(::google::protobuf::int64 value);

  // repeated bytes set_value = 4;
  inline int set_value_size() const;
  inline void clear_set_value();
  static const int kSetValueFieldNumber = 4;
  inline const ::std::string& set_value(int index) const;
  inline ::std::string* mutable_set_value(int index);
  inline void set_set_value(int index, const ::std::string& value);
  inline void set_set_value(int index, const char* value);
  inline void set_set_value(int index, const void* value, size_t size);
  inline ::std::string* add_set_value();
  inline void add_set_value(const ::std::string& value);
  inline void add_set_value(const char* value);
  inline void add_set_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& set_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_set_value();

  // repeated .MapEntry map_value = 5;
  inline int map_value_size() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 5;
  inline const ::MapEntry& map_value(int index) const;
  inline ::MapEntry* mutable_map_value(int index);
  inline ::MapEntry* add_map_value();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
      map_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
      mutable_map_value();

  // @@protoc_insertion_point(class_scope:DtUpdateResp)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_counter_value();
  inline void clear_has_counter_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* context_;
  ::google::protobuf::int64 counter_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> set_value_;
  ::google::protobuf::RepeatedPtrField< ::MapEntry > map_value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static DtUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetClientIdResp : public ::google::protobuf::Message {
 public:
  RpbGetClientIdResp();
  virtual ~RpbGetClientIdResp();

  RpbGetClientIdResp(const RpbGetClientIdResp& from);

  inline RpbGetClientIdResp& operator=(const RpbGetClientIdResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetClientIdResp& default_instance();

  void Swap(RpbGetClientIdResp* other);

  // implements Message ----------------------------------------------

  RpbGetClientIdResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetClientIdResp& from);
  void MergeFrom(const RpbGetClientIdResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:RpbGetClientIdResp)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetClientIdResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetClientIdReq : public ::google::protobuf::Message {
 public:
  RpbSetClientIdReq();
  virtual ~RpbSetClientIdReq();

  RpbSetClientIdReq(const RpbSetClientIdReq& from);

  inline RpbSetClientIdReq& operator=(const RpbSetClientIdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetClientIdReq& default_instance();

  void Swap(RpbSetClientIdReq* other);

  // implements Message ----------------------------------------------

  RpbSetClientIdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetClientIdReq& from);
  void MergeFrom(const RpbSetClientIdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:RpbSetClientIdReq)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbSetClientIdReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetReq : public ::google::protobuf::Message {
 public:
  RpbGetReq();
  virtual ~RpbGetReq();

  RpbGetReq(const RpbGetReq& from);

  inline RpbGetReq& operator=(const RpbGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetReq& default_instance();

  void Swap(RpbGetReq* other);

  // implements Message ----------------------------------------------

  RpbGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetReq& from);
  void MergeFrom(const RpbGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 pr = 4;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 4;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 5;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 5;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 6;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 6;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // optional bytes if_modified = 7;
  inline bool has_if_modified() const;
  inline void clear_if_modified();
  static const int kIfModifiedFieldNumber = 7;
  inline const ::std::string& if_modified() const;
  inline void set_if_modified(const ::std::string& value);
  inline void set_if_modified(const char* value);
  inline void set_if_modified(const void* value, size_t size);
  inline ::std::string* mutable_if_modified();
  inline ::std::string* release_if_modified();
  inline void set_allocated_if_modified(::std::string* if_modified);

  // optional bool head = 8;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 8;
  inline bool head() const;
  inline void set_head(bool value);

  // optional bool deletedvclock = 9;
  inline bool has_deletedvclock() const;
  inline void clear_deletedvclock();
  static const int kDeletedvclockFieldNumber = 9;
  inline bool deletedvclock() const;
  inline void set_deletedvclock(bool value);

  // optional uint32 timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 11;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 11;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 12;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 12;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bytes type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_if_modified();
  inline void clear_has_if_modified();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_deletedvclock();
  inline void clear_has_deletedvclock();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  ::std::string* if_modified_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool head_;
  bool deletedvclock_;
  ::google::protobuf::uint32 timeout_;
  bool sloppy_quorum_;
  ::google::protobuf::uint32 n_val_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetResp : public ::google::protobuf::Message {
 public:
  RpbGetResp();
  virtual ~RpbGetResp();

  RpbGetResp(const RpbGetResp& from);

  inline RpbGetResp& operator=(const RpbGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetResp& default_instance();

  void Swap(RpbGetResp* other);

  // implements Message ----------------------------------------------

  RpbGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetResp& from);
  void MergeFrom(const RpbGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();

  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional bool unchanged = 3;
  inline bool has_unchanged() const;
  inline void clear_unchanged();
  static const int kUnchangedFieldNumber = 3;
  inline bool unchanged() const;
  inline void set_unchanged(bool value);

  // @@protoc_insertion_point(class_scope:RpbGetResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_unchanged();
  inline void clear_has_unchanged();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  bool unchanged_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutReq : public ::google::protobuf::Message {
 public:
  RpbPutReq();
  virtual ~RpbPutReq();

  RpbPutReq(const RpbPutReq& from);

  inline RpbPutReq& operator=(const RpbPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutReq& default_instance();

  void Swap(RpbPutReq* other);

  // implements Message ----------------------------------------------

  RpbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutReq& from);
  void MergeFrom(const RpbPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // required .RpbContent content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::RpbContent& content() const;
  inline ::RpbContent* mutable_content();
  inline ::RpbContent* release_content();
  inline void set_allocated_content(::RpbContent* content);

  // optional uint32 w = 5;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 5;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 6;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 6;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional bool return_body = 7;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 7;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional bool if_not_modified = 9;
  inline bool has_if_not_modified() const;
  inline void clear_if_not_modified();
  static const int kIfNotModifiedFieldNumber = 9;
  inline bool if_not_modified() const;
  inline void set_if_not_modified(bool value);

  // optional bool if_none_match = 10;
  inline bool has_if_none_match() const;
  inline void clear_if_none_match();
  static const int kIfNoneMatchFieldNumber = 10;
  inline bool if_none_match() const;
  inline void set_if_none_match(bool value);

  // optional bool return_head = 11;
  inline bool has_return_head() const;
  inline void clear_return_head();
  static const int kReturnHeadFieldNumber = 11;
  inline bool return_head() const;
  inline void set_return_head(bool value);

  // optional uint32 timeout = 12;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 12;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool asis = 13;
  inline bool has_asis() const;
  inline void clear_asis();
  static const int kAsisFieldNumber = 13;
  inline bool asis() const;
  inline void set_asis(bool value);

  // optional bool sloppy_quorum = 14;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 14;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 15;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 15;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bytes type = 16;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 16;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbPutReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_return_body();
  inline void clear_has_return_body();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_if_not_modified();
  inline void clear_has_if_not_modified();
  inline void set_has_if_none_match();
  inline void clear_has_if_none_match();
  inline void set_has_return_head();
  inline void clear_has_return_head();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_asis();
  inline void clear_has_asis();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::RpbContent* content_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  bool return_body_;
  bool if_not_modified_;
  bool if_none_match_;
  bool return_head_;
  ::google::protobuf::uint32 timeout_;
  bool asis_;
  bool sloppy_quorum_;
  ::std::string* type_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutResp : public ::google::protobuf::Message {
 public:
  RpbPutResp();
  virtual ~RpbPutResp();

  RpbPutResp(const RpbPutResp& from);

  inline RpbPutResp& operator=(const RpbPutResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutResp& default_instance();

  void Swap(RpbPutResp* other);

  // implements Message ----------------------------------------------

  RpbPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutResp& from);
  void MergeFrom(const RpbPutResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();

  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:RpbPutResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  ::std::string* key_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbPutResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbDelReq : public ::google::protobuf::Message {
 public:
  RpbDelReq();
  virtual ~RpbDelReq();

  RpbDelReq(const RpbDelReq& from);

  inline RpbDelReq& operator=(const RpbDelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbDelReq& default_instance();

  void Swap(RpbDelReq* other);

  // implements Message ----------------------------------------------

  RpbDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbDelReq& from);
  void MergeFrom(const RpbDelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 rw = 3;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 3;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);

  // optional bytes vclock = 4;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 4;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional uint32 r = 5;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 5;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 pr = 7;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 7;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional uint32 dw = 9;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 9;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 11;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 11;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 12;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 12;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bytes type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbDelReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_rw();
  inline void clear_has_rw();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::google::protobuf::uint32 rw_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 timeout_;
  bool sloppy_quorum_;
  ::std::string* type_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbDelReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsReq : public ::google::protobuf::Message {
 public:
  RpbListBucketsReq();
  virtual ~RpbListBucketsReq();

  RpbListBucketsReq(const RpbListBucketsReq& from);

  inline RpbListBucketsReq& operator=(const RpbListBucketsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsReq& default_instance();

  void Swap(RpbListBucketsReq* other);

  // implements Message ----------------------------------------------

  RpbListBucketsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsReq& from);
  void MergeFrom(const RpbListBucketsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 1;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool stream = 2;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbListBucketsReq)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_;
  bool stream_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbListBucketsReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsResp : public ::google::protobuf::Message {
 public:
  RpbListBucketsResp();
  virtual ~RpbListBucketsResp();

  RpbListBucketsResp(const RpbListBucketsResp& from);

  inline RpbListBucketsResp& operator=(const RpbListBucketsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsResp& default_instance();

  void Swap(RpbListBucketsResp* other);

  // implements Message ----------------------------------------------

  RpbListBucketsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsResp& from);
  void MergeFrom(const RpbListBucketsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes buckets = 1;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const void* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbListBucketsResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbListBucketsResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysReq : public ::google::protobuf::Message {
 public:
  RpbListKeysReq();
  virtual ~RpbListKeysReq();

  RpbListKeysReq(const RpbListKeysReq& from);

  inline RpbListKeysReq& operator=(const RpbListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysReq& default_instance();

  void Swap(RpbListKeysReq* other);

  // implements Message ----------------------------------------------

  RpbListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysReq& from);
  void MergeFrom(const RpbListKeysReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbListKeysReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* type_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysResp : public ::google::protobuf::Message {
 public:
  RpbListKeysResp();
  virtual ~RpbListKeysResp();

  RpbListKeysResp(const RpbListKeysResp& from);

  inline RpbListKeysResp& operator=(const RpbListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysResp& default_instance();

  void Swap(RpbListKeysResp* other);

  // implements Message ----------------------------------------------

  RpbListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysResp& from);
  void MergeFrom(const RpbListKeysResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedReq : public ::google::protobuf::Message {
 public:
  RpbMapRedReq();
  virtual ~RpbMapRedReq();

  RpbMapRedReq(const RpbMapRedReq& from);

  inline RpbMapRedReq& operator=(const RpbMapRedReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedReq& default_instance();

  void Swap(RpbMapRedReq* other);

  // implements Message ----------------------------------------------

  RpbMapRedReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedReq& from);
  void MergeFrom(const RpbMapRedReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  inline void set_allocated_request(::std::string* request);

  // required bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  inline void set_allocated_content_type(::std::string* content_type);

  // @@protoc_insertion_point(class_scope:RpbMapRedReq)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_content_type();
  inline void clear_has_content_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* request_;
  ::std::string* content_type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbMapRedReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedResp : public ::google::protobuf::Message {
 public:
  RpbMapRedResp();
  virtual ~RpbMapRedResp();

  RpbMapRedResp(const RpbMapRedResp& from);

  inline RpbMapRedResp& operator=(const RpbMapRedResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedResp& default_instance();

  void Swap(RpbMapRedResp* other);

  // implements Message ----------------------------------------------

  RpbMapRedResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedResp& from);
  void MergeFrom(const RpbMapRedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline ::google::protobuf::uint32 phase() const;
  inline void set_phase(::google::protobuf::uint32 value);

  // optional bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  inline void set_allocated_response(::std::string* response);

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbMapRedResp)
 private:
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* response_;
  ::google::protobuf::uint32 phase_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbMapRedResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexReq : public ::google::protobuf::Message {
 public:
  RpbIndexReq();
  virtual ~RpbIndexReq();

  RpbIndexReq(const RpbIndexReq& from);

  inline RpbIndexReq& operator=(const RpbIndexReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexReq& default_instance();

  void Swap(RpbIndexReq* other);

  // implements Message ----------------------------------------------

  RpbIndexReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexReq& from);
  void MergeFrom(const RpbIndexReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RpbIndexReq_IndexQueryType IndexQueryType;
  static const IndexQueryType eq = RpbIndexReq_IndexQueryType_eq;
  static const IndexQueryType range = RpbIndexReq_IndexQueryType_range;
  static inline bool IndexQueryType_IsValid(int value) {
    return RpbIndexReq_IndexQueryType_IsValid(value);
  }
  static const IndexQueryType IndexQueryType_MIN =
    RpbIndexReq_IndexQueryType_IndexQueryType_MIN;
  static const IndexQueryType IndexQueryType_MAX =
    RpbIndexReq_IndexQueryType_IndexQueryType_MAX;
  static const int IndexQueryType_ARRAYSIZE =
    RpbIndexReq_IndexQueryType_IndexQueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IndexQueryType_descriptor() {
    return RpbIndexReq_IndexQueryType_descriptor();
  }
  static inline const ::std::string& IndexQueryType_Name(IndexQueryType value) {
    return RpbIndexReq_IndexQueryType_Name(value);
  }
  static inline bool IndexQueryType_Parse(const ::std::string& name,
      IndexQueryType* value) {
    return RpbIndexReq_IndexQueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const void* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  inline void set_allocated_index(::std::string* index);

  // required .RpbIndexReq.IndexQueryType qtype = 3;
  inline bool has_qtype() const;
  inline void clear_qtype();
  static const int kQtypeFieldNumber = 3;
  inline ::RpbIndexReq_IndexQueryType qtype() const;
  inline void set_qtype(::RpbIndexReq_IndexQueryType value);

  // optional bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes range_min = 5;
  inline bool has_range_min() const;
  inline void clear_range_min();
  static const int kRangeMinFieldNumber = 5;
  inline const ::std::string& range_min() const;
  inline void set_range_min(const ::std::string& value);
  inline void set_range_min(const char* value);
  inline void set_range_min(const void* value, size_t size);
  inline ::std::string* mutable_range_min();
  inline ::std::string* release_range_min();
  inline void set_allocated_range_min(::std::string* range_min);

  // optional bytes range_max = 6;
  inline bool has_range_max() const;
  inline void clear_range_max();
  static const int kRangeMaxFieldNumber = 6;
  inline const ::std::string& range_max() const;
  inline void set_range_max(const ::std::string& value);
  inline void set_range_max(const char* value);
  inline void set_range_max(const void* value, size_t size);
  inline ::std::string* mutable_range_max();
  inline ::std::string* release_range_max();
  inline void set_allocated_range_max(::std::string* range_max);

  // optional bool return_terms = 7;
  inline bool has_return_terms() const;
  inline void clear_return_terms();
  static const int kReturnTermsFieldNumber = 7;
  inline bool return_terms() const;
  inline void set_return_terms(bool value);

  // optional bool stream = 8;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 8;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional uint32 max_results = 9;
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 9;
  inline ::google::protobuf::uint32 max_results() const;
  inline void set_max_results(::google::protobuf::uint32 value);

  // optional bytes continuation = 10;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 10;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional uint32 timeout = 11;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 11;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bytes type = 12;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 12;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes term_regex = 13;
  inline bool has_term_regex() const;
  inline void clear_term_regex();
  static const int kTermRegexFieldNumber = 13;
  inline const ::std::string& term_regex() const;
  inline void set_term_regex(const ::std::string& value);
  inline void set_term_regex(const char* value);
  inline void set_term_regex(const void* value, size_t size);
  inline ::std::string* mutable_term_regex();
  inline ::std::string* release_term_regex();
  inline void set_allocated_term_regex(::std::string* term_regex);

  // optional bool pagination_sort = 14;
  inline bool has_pagination_sort() const;
  inline void clear_pagination_sort();
  static const int kPaginationSortFieldNumber = 14;
  inline bool pagination_sort() const;
  inline void set_pagination_sort(bool value);

  // optional bytes cover_context = 15;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 15;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // optional bool return_body = 16;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 16;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // @@protoc_insertion_point(class_scope:RpbIndexReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_qtype();
  inline void clear_has_qtype();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_range_min();
  inline void clear_has_range_min();
  inline void set_has_range_max();
  inline void clear_has_range_max();
  inline void set_has_return_terms();
  inline void clear_has_return_terms();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_max_results();
  inline void clear_has_max_results();
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_term_regex();
  inline void clear_has_term_regex();
  inline void set_has_pagination_sort();
  inline void clear_has_pagination_sort();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();
  inline void set_has_return_body();
  inline void clear_has_return_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* index_;
  ::std::string* key_;
  ::std::string* range_min_;
  ::std::string* range_max_;
  int qtype_;
  ::google::protobuf::uint32 max_results_;
  ::std::string* continuation_;
  ::google::protobuf::uint32 timeout_;
  bool return_terms_;
  bool stream_;
  bool pagination_sort_;
  bool return_body_;
  ::std::string* type_;
  ::std::string* term_regex_;
  ::std::string* cover_context_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexResp : public ::google::protobuf::Message {
 public:
  RpbIndexResp();
  virtual ~RpbIndexResp();

  RpbIndexResp(const RpbIndexResp& from);

  inline RpbIndexResp& operator=(const RpbIndexResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexResp& default_instance();

  void Swap(RpbIndexResp* other);

  // implements Message ----------------------------------------------

  RpbIndexResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexResp& from);
  void MergeFrom(const RpbIndexResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated .RpbPair results = 2;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 2;
  inline const ::RpbPair& results(int index) const;
  inline ::RpbPair* mutable_results(int index);
  inline ::RpbPair* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_results();

  // optional bytes continuation = 3;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 3;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional bool done = 4;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 4;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbIndexResp)
 private:
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > results_;
  ::std::string* continuation_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexBodyResp : public ::google::protobuf::Message {
 public:
  RpbIndexBodyResp();
  virtual ~RpbIndexBodyResp();

  RpbIndexBodyResp(const RpbIndexBodyResp& from);

  inline RpbIndexBodyResp& operator=(const RpbIndexBodyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexBodyResp& default_instance();

  void Swap(RpbIndexBodyResp* other);

  // implements Message ----------------------------------------------

  RpbIndexBodyResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexBodyResp& from);
  void MergeFrom(const RpbIndexBodyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbIndexObject objects = 1;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 1;
  inline const ::RpbIndexObject& objects(int index) const;
  inline ::RpbIndexObject* mutable_objects(int index);
  inline ::RpbIndexObject* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
      mutable_objects();

  // optional bytes continuation = 2;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 2;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbIndexBodyResp)
 private:
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbIndexObject > objects_;
  ::std::string* continuation_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexBodyResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbCSBucketReq : public ::google::protobuf::Message {
 public:
  RpbCSBucketReq();
  virtual ~RpbCSBucketReq();

  RpbCSBucketReq(const RpbCSBucketReq& from);

  inline RpbCSBucketReq& operator=(const RpbCSBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCSBucketReq& default_instance();

  void Swap(RpbCSBucketReq* other);

  // implements Message ----------------------------------------------

  RpbCSBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCSBucketReq& from);
  void MergeFrom(const RpbCSBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes start_key = 2;
  inline bool has_start_key() const;
  inline void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  inline const ::std::string& start_key() const;
  inline void set_start_key(const ::std::string& value);
  inline void set_start_key(const char* value);
  inline void set_start_key(const void* value, size_t size);
  inline ::std::string* mutable_start_key();
  inline ::std::string* release_start_key();
  inline void set_allocated_start_key(::std::string* start_key);

  // optional bytes end_key = 3;
  inline bool has_end_key() const;
  inline void clear_end_key();
  static const int kEndKeyFieldNumber = 3;
  inline const ::std::string& end_key() const;
  inline void set_end_key(const ::std::string& value);
  inline void set_end_key(const char* value);
  inline void set_end_key(const void* value, size_t size);
  inline ::std::string* mutable_end_key();
  inline ::std::string* release_end_key();
  inline void set_allocated_end_key(::std::string* end_key);

  // optional bool start_incl = 4 [default = true];
  inline bool has_start_incl() const;
  inline void clear_start_incl();
  static const int kStartInclFieldNumber = 4;
  inline bool start_incl() const;
  inline void set_start_incl(bool value);

  // optional bool end_incl = 5 [default = false];
  inline bool has_end_incl() const;
  inline void clear_end_incl();
  static const int kEndInclFieldNumber = 5;
  inline bool end_incl() const;
  inline void set_end_incl(bool value);

  // optional bytes continuation = 6;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 6;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional uint32 max_results = 7;
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 7;
  inline ::google::protobuf::uint32 max_results() const;
  inline void set_max_results(::google::protobuf::uint32 value);

  // optional uint32 timeout = 8;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bytes type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes cover_context = 10;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 10;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // @@protoc_insertion_point(class_scope:RpbCSBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_start_key();
  inline void clear_has_start_key();
  inline void set_has_end_key();
  inline void clear_has_end_key();
  inline void set_has_start_incl();
  inline void clear_has_start_incl();
  inline void set_has_end_incl();
  inline void clear_has_end_incl();
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_max_results();
  inline void clear_has_max_results();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* start_key_;
  ::std::string* end_key_;
  bool start_incl_;
  bool end_incl_;
  ::google::protobuf::uint32 max_results_;
  ::std::string* continuation_;
  ::std::string* type_;
  ::std::string* cover_context_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCSBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCSBucketResp : public ::google::protobuf::Message {
 public:
  RpbCSBucketResp();
  virtual ~RpbCSBucketResp();

  RpbCSBucketResp(const RpbCSBucketResp& from);

  inline RpbCSBucketResp& operator=(const RpbCSBucketResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCSBucketResp& default_instance();

  void Swap(RpbCSBucketResp* other);

  // implements Message ----------------------------------------------

  RpbCSBucketResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCSBucketResp& from);
  void MergeFrom(const RpbCSBucketResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbIndexObject objects = 1;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 1;
  inline const ::RpbIndexObject& objects(int index) const;
  inline ::RpbIndexObject* mutable_objects(int index);
  inline ::RpbIndexObject* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
      mutable_objects();

  // optional bytes continuation = 2;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 2;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbCSBucketResp)
 private:
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbIndexObject > objects_;
  ::std::string* continuation_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCSBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexObject : public ::google::protobuf::Message {
 public:
  RpbIndexObject();
  virtual ~RpbIndexObject();

  RpbIndexObject(const RpbIndexObject& from);

  inline RpbIndexObject& operator=(const RpbIndexObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexObject& default_instance();

  void Swap(RpbIndexObject* other);

  // implements Message ----------------------------------------------

  RpbIndexObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexObject& from);
  void MergeFrom(const RpbIndexObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .RpbGetResp object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::RpbGetResp& object() const;
  inline ::RpbGetResp* mutable_object();
  inline ::RpbGetResp* release_object();
  inline void set_allocated_object(::RpbGetResp* object);

  // @@protoc_insertion_point(class_scope:RpbIndexObject)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::RpbGetResp* object_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexObject* default_instance_;
};
// -------------------------------------------------------------------

class RpbContent : public ::google::protobuf::Message {
 public:
  RpbContent();
  virtual ~RpbContent();

  RpbContent(const RpbContent& from);

  inline RpbContent& operator=(const RpbContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbContent& default_instance();

  void Swap(RpbContent* other);

  // implements Message ----------------------------------------------

  RpbContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbContent& from);
  void MergeFrom(const RpbContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  inline void set_allocated_content_type(::std::string* content_type);

  // optional bytes charset = 3;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 3;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  inline void set_allocated_charset(::std::string* charset);

  // optional bytes content_encoding = 4;
  inline bool has_content_encoding() const;
  inline void clear_content_encoding();
  static const int kContentEncodingFieldNumber = 4;
  inline const ::std::string& content_encoding() const;
  inline void set_content_encoding(const ::std::string& value);
  inline void set_content_encoding(const char* value);
  inline void set_content_encoding(const void* value, size_t size);
  inline ::std::string* mutable_content_encoding();
  inline ::std::string* release_content_encoding();
  inline void set_allocated_content_encoding(::std::string* content_encoding);

  // optional bytes vtag = 5;
  inline bool has_vtag() const;
  inline void clear_vtag();
  static const int kVtagFieldNumber = 5;
  inline const ::std::string& vtag() const;
  inline void set_vtag(const ::std::string& value);
  inline void set_vtag(const char* value);
  inline void set_vtag(const void* value, size_t size);
  inline ::std::string* mutable_vtag();
  inline ::std::string* release_vtag();
  inline void set_allocated_vtag(::std::string* vtag);

  // repeated .RpbLink links = 6;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 6;
  inline const ::RpbLink& links(int index) const;
  inline ::RpbLink* mutable_links(int index);
  inline ::RpbLink* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
      mutable_links();

  // optional uint32 last_mod = 7;
  inline bool has_last_mod() const;
  inline void clear_last_mod();
  static const int kLastModFieldNumber = 7;
  inline ::google::protobuf::uint32 last_mod() const;
  inline void set_last_mod(::google::protobuf::uint32 value);

  // optional uint32 last_mod_usecs = 8;
  inline bool has_last_mod_usecs() const;
  inline void clear_last_mod_usecs();
  static const int kLastModUsecsFieldNumber = 8;
  inline ::google::protobuf::uint32 last_mod_usecs() const;
  inline void set_last_mod_usecs(::google::protobuf::uint32 value);

  // repeated .RpbPair usermeta = 9;
  inline int usermeta_size() const;
  inline void clear_usermeta();
  static const int kUsermetaFieldNumber = 9;
  inline const ::RpbPair& usermeta(int index) const;
  inline ::RpbPair* mutable_usermeta(int index);
  inline ::RpbPair* add_usermeta();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      usermeta() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_usermeta();

  // repeated .RpbPair indexes = 10;
  inline int indexes_size() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 10;
  inline const ::RpbPair& indexes(int index) const;
  inline ::RpbPair* mutable_indexes(int index);
  inline ::RpbPair* add_indexes();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      indexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_indexes();

  // optional bool deleted = 11;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 11;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // @@protoc_insertion_point(class_scope:RpbContent)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_content_encoding();
  inline void clear_has_content_encoding();
  inline void set_has_vtag();
  inline void clear_has_vtag();
  inline void set_has_last_mod();
  inline void clear_has_last_mod();
  inline void set_has_last_mod_usecs();
  inline void clear_has_last_mod_usecs();
  inline void set_has_deleted();
  inline void clear_has_deleted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::std::string* content_type_;
  ::std::string* charset_;
  ::std::string* content_encoding_;
  ::std::string* vtag_;
  ::google::protobuf::RepeatedPtrField< ::RpbLink > links_;
  ::google::protobuf::uint32 last_mod_;
  ::google::protobuf::uint32 last_mod_usecs_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > usermeta_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > indexes_;
  bool deleted_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbContent* default_instance_;
};
// -------------------------------------------------------------------

class RpbLink : public ::google::protobuf::Message {
 public:
  RpbLink();
  virtual ~RpbLink();

  RpbLink(const RpbLink& from);

  inline RpbLink& operator=(const RpbLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbLink& default_instance();

  void Swap(RpbLink* other);

  // implements Message ----------------------------------------------

  RpbLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbLink& from);
  void MergeFrom(const RpbLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:RpbLink)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* tag_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbLink* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterUpdateReq : public ::google::protobuf::Message {
 public:
  RpbCounterUpdateReq();
  virtual ~RpbCounterUpdateReq();

  RpbCounterUpdateReq(const RpbCounterUpdateReq& from);

  inline RpbCounterUpdateReq& operator=(const RpbCounterUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterUpdateReq& default_instance();

  void Swap(RpbCounterUpdateReq* other);

  // implements Message ----------------------------------------------

  RpbCounterUpdateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterUpdateReq& from);
  void MergeFrom(const RpbCounterUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required sint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::int64 amount() const;
  inline void set_amount(::google::protobuf::int64 value);

  // optional uint32 w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 5;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 5;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 pw = 6;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 6;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional bool returnvalue = 7;
  inline bool has_returnvalue() const;
  inline void clear_returnvalue();
  static const int kReturnvalueFieldNumber = 7;
  inline bool returnvalue() const;
  inline void set_returnvalue(bool value);

  // @@protoc_insertion_point(class_scope:RpbCounterUpdateReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_returnvalue();
  inline void clear_has_returnvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::int64 amount_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  bool returnvalue_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterUpdateResp : public ::google::protobuf::Message {
 public:
  RpbCounterUpdateResp();
  virtual ~RpbCounterUpdateResp();

  RpbCounterUpdateResp(const RpbCounterUpdateResp& from);

  inline RpbCounterUpdateResp& operator=(const RpbCounterUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterUpdateResp& default_instance();

  void Swap(RpbCounterUpdateResp* other);

  // implements Message ----------------------------------------------

  RpbCounterUpdateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterUpdateResp& from);
  void MergeFrom(const RpbCounterUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RpbCounterUpdateResp)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterGetReq : public ::google::protobuf::Message {
 public:
  RpbCounterGetReq();
  virtual ~RpbCounterGetReq();

  RpbCounterGetReq(const RpbCounterGetReq& from);

  inline RpbCounterGetReq& operator=(const RpbCounterGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterGetReq& default_instance();

  void Swap(RpbCounterGetReq* other);

  // implements Message ----------------------------------------------

  RpbCounterGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterGetReq& from);
  void MergeFrom(const RpbCounterGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 pr = 4;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 4;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 5;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 5;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 6;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 6;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // @@protoc_insertion_point(class_scope:RpbCounterGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  bool basic_quorum_;
  bool notfound_ok_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterGetResp : public ::google::protobuf::Message {
 public:
  RpbCounterGetResp();
  virtual ~RpbCounterGetResp();

  RpbCounterGetResp(const RpbCounterGetResp& from);

  inline RpbCounterGetResp& operator=(const RpbCounterGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterGetResp& default_instance();

  void Swap(RpbCounterGetResp* other);

  // implements Message ----------------------------------------------

  RpbCounterGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterGetResp& from);
  void MergeFrom(const RpbCounterGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RpbCounterGetResp)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketKeyPreflistReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketKeyPreflistReq();
  virtual ~RpbGetBucketKeyPreflistReq();

  RpbGetBucketKeyPreflistReq(const RpbGetBucketKeyPreflistReq& from);

  inline RpbGetBucketKeyPreflistReq& operator=(const RpbGetBucketKeyPreflistReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketKeyPreflistReq& default_instance();

  void Swap(RpbGetBucketKeyPreflistReq* other);

  // implements Message ----------------------------------------------

  RpbGetBucketKeyPreflistReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketKeyPreflistReq& from);
  void MergeFrom(const RpbGetBucketKeyPreflistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbGetBucketKeyPreflistReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketKeyPreflistReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketKeyPreflistResp : public ::google::protobuf::Message {
 public:
  RpbGetBucketKeyPreflistResp();
  virtual ~RpbGetBucketKeyPreflistResp();

  RpbGetBucketKeyPreflistResp(const RpbGetBucketKeyPreflistResp& from);

  inline RpbGetBucketKeyPreflistResp& operator=(const RpbGetBucketKeyPreflistResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketKeyPreflistResp& default_instance();

  void Swap(RpbGetBucketKeyPreflistResp* other);

  // implements Message ----------------------------------------------

  RpbGetBucketKeyPreflistResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketKeyPreflistResp& from);
  void MergeFrom(const RpbGetBucketKeyPreflistResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbBucketKeyPreflistItem preflist = 1;
  inline int preflist_size() const;
  inline void clear_preflist();
  static const int kPreflistFieldNumber = 1;
  inline const ::RpbBucketKeyPreflistItem& preflist(int index) const;
  inline ::RpbBucketKeyPreflistItem* mutable_preflist(int index);
  inline ::RpbBucketKeyPreflistItem* add_preflist();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >&
      preflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >*
      mutable_preflist();

  // @@protoc_insertion_point(class_scope:RpbGetBucketKeyPreflistResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem > preflist_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketKeyPreflistResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketKeyPreflistItem : public ::google::protobuf::Message {
 public:
  RpbBucketKeyPreflistItem();
  virtual ~RpbBucketKeyPreflistItem();

  RpbBucketKeyPreflistItem(const RpbBucketKeyPreflistItem& from);

  inline RpbBucketKeyPreflistItem& operator=(const RpbBucketKeyPreflistItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbBucketKeyPreflistItem& default_instance();

  void Swap(RpbBucketKeyPreflistItem* other);

  // implements Message ----------------------------------------------

  RpbBucketKeyPreflistItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbBucketKeyPreflistItem& from);
  void MergeFrom(const RpbBucketKeyPreflistItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 partition = 1;
  inline bool has_partition() const;
  inline void clear_partition();
  static const int kPartitionFieldNumber = 1;
  inline ::google::protobuf::int64 partition() const;
  inline void set_partition(::google::protobuf::int64 value);

  // required bytes node = 2;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // required bool primary = 3;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 3;
  inline bool primary() const;
  inline void set_primary(bool value);

  // @@protoc_insertion_point(class_scope:RpbBucketKeyPreflistItem)
 private:
  inline void set_has_partition();
  inline void clear_has_partition();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_primary();
  inline void clear_has_primary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 partition_;
  ::std::string* node_;
  bool primary_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbBucketKeyPreflistItem* default_instance_;
};
// -------------------------------------------------------------------

class RpbCoverageReq : public ::google::protobuf::Message {
 public:
  RpbCoverageReq();
  virtual ~RpbCoverageReq();

  RpbCoverageReq(const RpbCoverageReq& from);

  inline RpbCoverageReq& operator=(const RpbCoverageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCoverageReq& default_instance();

  void Swap(RpbCoverageReq* other);

  // implements Message ----------------------------------------------

  RpbCoverageReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCoverageReq& from);
  void MergeFrom(const RpbCoverageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required bytes bucket = 2;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 2;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional uint32 min_partitions = 3;
  inline bool has_min_partitions() const;
  inline void clear_min_partitions();
  static const int kMinPartitionsFieldNumber = 3;
  inline ::google::protobuf::uint32 min_partitions() const;
  inline void set_min_partitions(::google::protobuf::uint32 value);

  // optional bytes replace_cover = 4;
  inline bool has_replace_cover() const;
  inline void clear_replace_cover();
  static const int kReplaceCoverFieldNumber = 4;
  inline const ::std::string& replace_cover() const;
  inline void set_replace_cover(const ::std::string& value);
  inline void set_replace_cover(const char* value);
  inline void set_replace_cover(const void* value, size_t size);
  inline ::std::string* mutable_replace_cover();
  inline ::std::string* release_replace_cover();
  inline void set_allocated_replace_cover(::std::string* replace_cover);

  // repeated bytes unavailable_cover = 5;
  inline int unavailable_cover_size() const;
  inline void clear_unavailable_cover();
  static const int kUnavailableCoverFieldNumber = 5;
  inline const ::std::string& unavailable_cover(int index) const;
  inline ::std::string* mutable_unavailable_cover(int index);
  inline void set_unavailable_cover(int index, const ::std::string& value);
  inline void set_unavailable_cover(int index, const char* value);
  inline void set_unavailable_cover(int index, const void* value, size_t size);
  inline ::std::string* add_unavailable_cover();
  inline void add_unavailable_cover(const ::std::string& value);
  inline void add_unavailable_cover(const char* value);
  inline void add_unavailable_cover(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unavailable_cover() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unavailable_cover();

  // @@protoc_insertion_point(class_scope:RpbCoverageReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_min_partitions();
  inline void clear_has_min_partitions();
  inline void set_has_replace_cover();
  inline void clear_has_replace_cover();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* bucket_;
  ::std::string* replace_cover_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unavailable_cover_;
  ::google::protobuf::uint32 min_partitions_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCoverageReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCoverageResp : public ::google::protobuf::Message {
 public:
  RpbCoverageResp();
  virtual ~RpbCoverageResp();

  RpbCoverageResp(const RpbCoverageResp& from);

  inline RpbCoverageResp& operator=(const RpbCoverageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCoverageResp& default_instance();

  void Swap(RpbCoverageResp* other);

  // implements Message ----------------------------------------------

  RpbCoverageResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCoverageResp& from);
  void MergeFrom(const RpbCoverageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbCoverageEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::RpbCoverageEntry& entries(int index) const;
  inline ::RpbCoverageEntry* mutable_entries(int index);
  inline ::RpbCoverageEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:RpbCoverageResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry > entries_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCoverageResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbCoverageEntry : public ::google::protobuf::Message {
 public:
  RpbCoverageEntry();
  virtual ~RpbCoverageEntry();

  RpbCoverageEntry(const RpbCoverageEntry& from);

  inline RpbCoverageEntry& operator=(const RpbCoverageEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCoverageEntry& default_instance();

  void Swap(RpbCoverageEntry* other);

  // implements Message ----------------------------------------------

  RpbCoverageEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCoverageEntry& from);
  void MergeFrom(const RpbCoverageEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bytes keyspace_desc = 3;
  inline bool has_keyspace_desc() const;
  inline void clear_keyspace_desc();
  static const int kKeyspaceDescFieldNumber = 3;
  inline const ::std::string& keyspace_desc() const;
  inline void set_keyspace_desc(const ::std::string& value);
  inline void set_keyspace_desc(const char* value);
  inline void set_keyspace_desc(const void* value, size_t size);
  inline ::std::string* mutable_keyspace_desc();
  inline ::std::string* release_keyspace_desc();
  inline void set_allocated_keyspace_desc(::std::string* keyspace_desc);

  // required bytes cover_context = 4;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 4;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // @@protoc_insertion_point(class_scope:RpbCoverageEntry)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_keyspace_desc();
  inline void clear_has_keyspace_desc();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* keyspace_desc_;
  ::std::string* cover_context_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCoverageEntry* default_instance_;
};
// -------------------------------------------------------------------

class RpbErrorResp : public ::google::protobuf::Message {
 public:
  RpbErrorResp();
  virtual ~RpbErrorResp();

  RpbErrorResp(const RpbErrorResp& from);

  inline RpbErrorResp& operator=(const RpbErrorResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbErrorResp& default_instance();

  void Swap(RpbErrorResp* other);

  // implements Message ----------------------------------------------

  RpbErrorResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbErrorResp& from);
  void MergeFrom(const RpbErrorResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes errmsg = 1;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 1;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const void* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // required uint32 errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbErrorResp)
 private:
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* errmsg_;
  ::google::protobuf::uint32 errcode_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbErrorResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetServerInfoResp : public ::google::protobuf::Message {
 public:
  RpbGetServerInfoResp();
  virtual ~RpbGetServerInfoResp();

  RpbGetServerInfoResp(const RpbGetServerInfoResp& from);

  inline RpbGetServerInfoResp& operator=(const RpbGetServerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetServerInfoResp& default_instance();

  void Swap(RpbGetServerInfoResp* other);

  // implements Message ----------------------------------------------

  RpbGetServerInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetServerInfoResp& from);
  void MergeFrom(const RpbGetServerInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // optional bytes server_version = 2;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 2;
  inline const ::std::string& server_version() const;
  inline void set_server_version(const ::std::string& value);
  inline void set_server_version(const char* value);
  inline void set_server_version(const void* value, size_t size);
  inline ::std::string* mutable_server_version();
  inline ::std::string* release_server_version();
  inline void set_allocated_server_version(::std::string* server_version);

  // @@protoc_insertion_point(class_scope:RpbGetServerInfoResp)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_server_version();
  inline void clear_has_server_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_;
  ::std::string* server_version_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetServerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPair : public ::google::protobuf::Message {
 public:
  RpbPair();
  virtual ~RpbPair();

  RpbPair(const RpbPair& from);

  inline RpbPair& operator=(const RpbPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPair& default_instance();

  void Swap(RpbPair* other);

  // implements Message ----------------------------------------------

  RpbPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPair& from);
  void MergeFrom(const RpbPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:RpbPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbPair* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketReq();
  virtual ~RpbGetBucketReq();

  RpbGetBucketReq(const RpbGetBucketReq& from);

  inline RpbGetBucketReq& operator=(const RpbGetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketReq& default_instance();

  void Swap(RpbGetBucketReq* other);

  // implements Message ----------------------------------------------

  RpbGetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketReq& from);
  void MergeFrom(const RpbGetBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbGetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketResp : public ::google::protobuf::Message {
 public:
  RpbGetBucketResp();
  virtual ~RpbGetBucketResp();

  RpbGetBucketResp(const RpbGetBucketResp& from);

  inline RpbGetBucketResp& operator=(const RpbGetBucketResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketResp& default_instance();

  void Swap(RpbGetBucketResp* other);

  // implements Message ----------------------------------------------

  RpbGetBucketResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketResp& from);
  void MergeFrom(const RpbGetBucketResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RpbBucketProps props = 1;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 1;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();
  inline void set_allocated_props(::RpbBucketProps* props);

  // @@protoc_insertion_point(class_scope:RpbGetBucketResp)
 private:
  inline void set_has_props();
  inline void clear_has_props();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RpbBucketProps* props_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetBucketReq : public ::google::protobuf::Message {
 public:
  RpbSetBucketReq();
  virtual ~RpbSetBucketReq();

  RpbSetBucketReq(const RpbSetBucketReq& from);

  inline RpbSetBucketReq& operator=(const RpbSetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetBucketReq& default_instance();

  void Swap(RpbSetBucketReq* other);

  // implements Message ----------------------------------------------

  RpbSetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetBucketReq& from);
  void MergeFrom(const RpbSetBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required .RpbBucketProps props = 2;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();
  inline void set_allocated_props(::RpbBucketProps* props);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbSetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_props();
  inline void clear_has_props();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::RpbBucketProps* props_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbSetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbResetBucketReq : public ::google::protobuf::Message {
 public:
  RpbResetBucketReq();
  virtual ~RpbResetBucketReq();

  RpbResetBucketReq(const RpbResetBucketReq& from);

  inline RpbResetBucketReq& operator=(const RpbResetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbResetBucketReq& default_instance();

  void Swap(RpbResetBucketReq* other);

  // implements Message ----------------------------------------------

  RpbResetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbResetBucketReq& from);
  void MergeFrom(const RpbResetBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbResetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbResetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketTypeReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketTypeReq();
  virtual ~RpbGetBucketTypeReq();

  RpbGetBucketTypeReq(const RpbGetBucketTypeReq& from);

  inline RpbGetBucketTypeReq& operator=(const RpbGetBucketTypeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketTypeReq& default_instance();

  void Swap(RpbGetBucketTypeReq* other);

  // implements Message ----------------------------------------------

  RpbGetBucketTypeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketTypeReq& from);
  void MergeFrom(const RpbGetBucketTypeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbGetBucketTypeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketTypeReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetBucketTypeReq : public ::google::protobuf::Message {
 public:
  RpbSetBucketTypeReq();
  virtual ~RpbSetBucketTypeReq();

  RpbSetBucketTypeReq(const RpbSetBucketTypeReq& from);

  inline RpbSetBucketTypeReq& operator=(const RpbSetBucketTypeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetBucketTypeReq& default_instance();

  void Swap(RpbSetBucketTypeReq* other);

  // implements Message ----------------------------------------------

  RpbSetBucketTypeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetBucketTypeReq& from);
  void MergeFrom(const RpbSetBucketTypeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required .RpbBucketProps props = 2;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  inline ::RpbBucketProps* release_props();
  inline void set_allocated_props(::RpbBucketProps* props);

  // @@protoc_insertion_point(class_scope:RpbSetBucketTypeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_props();
  inline void clear_has_props();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::RpbBucketProps* props_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbSetBucketTypeReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbModFun : public ::google::protobuf::Message {
 public:
  RpbModFun();
  virtual ~RpbModFun();

  RpbModFun(const RpbModFun& from);

  inline RpbModFun& operator=(const RpbModFun& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbModFun& default_instance();

  void Swap(RpbModFun* other);

  // implements Message ----------------------------------------------

  RpbModFun* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbModFun& from);
  void MergeFrom(const RpbModFun& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline void set_module(const void* value, size_t size);
  inline ::std::string* mutable_module();
  inline ::std::string* release_module();
  inline void set_allocated_module(::std::string* module);

  // required bytes function = 2;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 2;
  inline const ::std::string& function() const;
  inline void set_function(const ::std::string& value);
  inline void set_function(const char* value);
  inline void set_function(const void* value, size_t size);
  inline ::std::string* mutable_function();
  inline ::std::string* release_function();
  inline void set_allocated_function(::std::string* function);

  // @@protoc_insertion_point(class_scope:RpbModFun)
 private:
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_function();
  inline void clear_has_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* module_;
  ::std::string* function_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbModFun* default_instance_;
};
// -------------------------------------------------------------------

class RpbCommitHook : public ::google::protobuf::Message {
 public:
  RpbCommitHook();
  virtual ~RpbCommitHook();

  RpbCommitHook(const RpbCommitHook& from);

  inline RpbCommitHook& operator=(const RpbCommitHook& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCommitHook& default_instance();

  void Swap(RpbCommitHook* other);

  // implements Message ----------------------------------------------

  RpbCommitHook* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCommitHook& from);
  void MergeFrom(const RpbCommitHook& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RpbModFun modfun = 1;
  inline bool has_modfun() const;
  inline void clear_modfun();
  static const int kModfunFieldNumber = 1;
  inline const ::RpbModFun& modfun() const;
  inline ::RpbModFun* mutable_modfun();
  inline ::RpbModFun* release_modfun();
  inline void set_allocated_modfun(::RpbModFun* modfun);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:RpbCommitHook)
 private:
  inline void set_has_modfun();
  inline void clear_has_modfun();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RpbModFun* modfun_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbCommitHook* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketProps : public ::google::protobuf::Message {
 public:
  RpbBucketProps();
  virtual ~RpbBucketProps();

  RpbBucketProps(const RpbBucketProps& from);

  inline RpbBucketProps& operator=(const RpbBucketProps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbBucketProps& default_instance();

  void Swap(RpbBucketProps* other);

  // implements Message ----------------------------------------------

  RpbBucketProps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbBucketProps& from);
  void MergeFrom(const RpbBucketProps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RpbBucketProps_RpbReplMode RpbReplMode;
  static const RpbReplMode FALSE = RpbBucketProps_RpbReplMode_FALSE;
  static const RpbReplMode REALTIME = RpbBucketProps_RpbReplMode_REALTIME;
  static const RpbReplMode FULLSYNC = RpbBucketProps_RpbReplMode_FULLSYNC;
  static const RpbReplMode TRUE = RpbBucketProps_RpbReplMode_TRUE;
  static inline bool RpbReplMode_IsValid(int value) {
    return RpbBucketProps_RpbReplMode_IsValid(value);
  }
  static const RpbReplMode RpbReplMode_MIN =
    RpbBucketProps_RpbReplMode_RpbReplMode_MIN;
  static const RpbReplMode RpbReplMode_MAX =
    RpbBucketProps_RpbReplMode_RpbReplMode_MAX;
  static const int RpbReplMode_ARRAYSIZE =
    RpbBucketProps_RpbReplMode_RpbReplMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RpbReplMode_descriptor() {
    return RpbBucketProps_RpbReplMode_descriptor();
  }
  static inline const ::std::string& RpbReplMode_Name(RpbReplMode value) {
    return RpbBucketProps_RpbReplMode_Name(value);
  }
  static inline bool RpbReplMode_Parse(const ::std::string& name,
      RpbReplMode* value) {
    return RpbBucketProps_RpbReplMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 n_val = 1;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 1;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bool allow_mult = 2;
  inline bool has_allow_mult() const;
  inline void clear_allow_mult();
  static const int kAllowMultFieldNumber = 2;
  inline bool allow_mult() const;
  inline void set_allow_mult(bool value);

  // optional bool last_write_wins = 3;
  inline bool has_last_write_wins() const;
  inline void clear_last_write_wins();
  static const int kLastWriteWinsFieldNumber = 3;
  inline bool last_write_wins() const;
  inline void set_last_write_wins(bool value);

  // repeated .RpbCommitHook precommit = 4;
  inline int precommit_size() const;
  inline void clear_precommit();
  static const int kPrecommitFieldNumber = 4;
  inline const ::RpbCommitHook& precommit(int index) const;
  inline ::RpbCommitHook* mutable_precommit(int index);
  inline ::RpbCommitHook* add_precommit();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >&
      precommit() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >*
      mutable_precommit();

  // optional bool has_precommit = 5 [default = false];
  inline bool has_has_precommit() const;
  inline void clear_has_precommit();
  static const int kHasPrecommitFieldNumber = 5;
  inline bool has_precommit() const;
  inline void set_has_precommit(bool value);

  // repeated .RpbCommitHook postcommit = 6;
  inline int postcommit_size() const;
  inline void clear_postcommit();
  static const int kPostcommitFieldNumber = 6;
  inline const ::RpbCommitHook& postcommit(int index) const;
  inline ::RpbCommitHook* mutable_postcommit(int index);
  inline ::RpbCommitHook* add_postcommit();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >&
      postcommit() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >*
      mutable_postcommit();

  // optional bool has_postcommit = 7 [default = false];
  inline bool has_has_postcommit() const;
  inline void clear_has_postcommit();
  static const int kHasPostcommitFieldNumber = 7;
  inline bool has_postcommit() const;
  inline void set_has_postcommit(bool value);

  // optional .RpbModFun chash_keyfun = 8;
  inline bool has_chash_keyfun() const;
  inline void clear_chash_keyfun();
  static const int kChashKeyfunFieldNumber = 8;
  inline const ::RpbModFun& chash_keyfun() const;
  inline ::RpbModFun* mutable_chash_keyfun();
  inline ::RpbModFun* release_chash_keyfun();
  inline void set_allocated_chash_keyfun(::RpbModFun* chash_keyfun);

  // optional .RpbModFun linkfun = 9;
  inline bool has_linkfun() const;
  inline void clear_linkfun();
  static const int kLinkfunFieldNumber = 9;
  inline const ::RpbModFun& linkfun() const;
  inline ::RpbModFun* mutable_linkfun();
  inline ::RpbModFun* release_linkfun();
  inline void set_allocated_linkfun(::RpbModFun* linkfun);

  // optional uint32 old_vclock = 10;
  inline bool has_old_vclock() const;
  inline void clear_old_vclock();
  static const int kOldVclockFieldNumber = 10;
  inline ::google::protobuf::uint32 old_vclock() const;
  inline void set_old_vclock(::google::protobuf::uint32 value);

  // optional uint32 young_vclock = 11;
  inline bool has_young_vclock() const;
  inline void clear_young_vclock();
  static const int kYoungVclockFieldNumber = 11;
  inline ::google::protobuf::uint32 young_vclock() const;
  inline void set_young_vclock(::google::protobuf::uint32 value);

  // optional uint32 big_vclock = 12;
  inline bool has_big_vclock() const;
  inline void clear_big_vclock();
  static const int kBigVclockFieldNumber = 12;
  inline ::google::protobuf::uint32 big_vclock() const;
  inline void set_big_vclock(::google::protobuf::uint32 value);

  // optional uint32 small_vclock = 13;
  inline bool has_small_vclock() const;
  inline void clear_small_vclock();
  static const int kSmallVclockFieldNumber = 13;
  inline ::google::protobuf::uint32 small_vclock() const;
  inline void set_small_vclock(::google::protobuf::uint32 value);

  // optional uint32 pr = 14;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 14;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional uint32 r = 15;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 15;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 w = 16;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 16;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 pw = 17;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 17;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional uint32 dw = 18;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 18;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 rw = 19;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 19;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 20;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 20;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 21;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 21;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // optional bytes backend = 22;
  inline bool has_backend() const;
  inline void clear_backend();
  static const int kBackendFieldNumber = 22;
  inline const ::std::string& backend() const;
  inline void set_backend(const ::std::string& value);
  inline void set_backend(const char* value);
  inline void set_backend(const void* value, size_t size);
  inline ::std::string* mutable_backend();
  inline ::std::string* release_backend();
  inline void set_allocated_backend(::std::string* backend);

  // optional bool search = 23;
  inline bool has_search() const;
  inline void clear_search();
  static const int kSearchFieldNumber = 23;
  inline bool search() const;
  inline void set_search(bool value);

  // optional .RpbBucketProps.RpbReplMode repl = 24;
  inline bool has_repl() const;
  inline void clear_repl();
  static const int kReplFieldNumber = 24;
  inline ::RpbBucketProps_RpbReplMode repl() const;
  inline void set_repl(::RpbBucketProps_RpbReplMode value);

  // optional bytes search_index = 25;
  inline bool has_search_index() const;
  inline void clear_search_index();
  static const int kSearchIndexFieldNumber = 25;
  inline const ::std::string& search_index() const;
  inline void set_search_index(const ::std::string& value);
  inline void set_search_index(const char* value);
  inline void set_search_index(const void* value, size_t size);
  inline ::std::string* mutable_search_index();
  inline ::std::string* release_search_index();
  inline void set_allocated_search_index(::std::string* search_index);

  // optional bytes datatype = 26;
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDatatypeFieldNumber = 26;
  inline const ::std::string& datatype() const;
  inline void set_datatype(const ::std::string& value);
  inline void set_datatype(const char* value);
  inline void set_datatype(const void* value, size_t size);
  inline ::std::string* mutable_datatype();
  inline ::std::string* release_datatype();
  inline void set_allocated_datatype(::std::string* datatype);

  // optional bool consistent = 27;
  inline bool has_consistent() const;
  inline void clear_consistent();
  static const int kConsistentFieldNumber = 27;
  inline bool consistent() const;
  inline void set_consistent(bool value);

  // optional bool write_once = 28;
  inline bool has_write_once() const;
  inline void clear_write_once();
  static const int kWriteOnceFieldNumber = 28;
  inline bool write_once() const;
  inline void set_write_once(bool value);

  // @@protoc_insertion_point(class_scope:RpbBucketProps)
 private:
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_allow_mult();
  inline void clear_has_allow_mult();
  inline void set_has_last_write_wins();
  inline void clear_has_last_write_wins();
  inline void set_has_has_precommit();
  inline void clear_has_has_precommit();
  inline void set_has_has_postcommit();
  inline void clear_has_has_postcommit();
  inline void set_has_chash_keyfun();
  inline void clear_has_chash_keyfun();
  inline void set_has_linkfun();
  inline void clear_has_linkfun();
  inline void set_has_old_vclock();
  inline void clear_has_old_vclock();
  inline void set_has_young_vclock();
  inline void clear_has_young_vclock();
  inline void set_has_big_vclock();
  inline void clear_has_big_vclock();
  inline void set_has_small_vclock();
  inline void clear_has_small_vclock();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_rw();
  inline void clear_has_rw();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_backend();
  inline void clear_has_backend();
  inline void set_has_search();
  inline void clear_has_search();
  inline void set_has_repl();
  inline void clear_has_repl();
  inline void set_has_search_index();
  inline void clear_has_search_index();
  inline void set_has_datatype();
  inline void clear_has_datatype();
  inline void set_has_consistent();
  inline void clear_has_consistent();
  inline void set_has_write_once();
  inline void clear_has_write_once();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 n_val_;
  bool allow_mult_;
  bool last_write_wins_;
  bool has_precommit_;
  bool has_postcommit_;
  ::google::protobuf::RepeatedPtrField< ::RpbCommitHook > precommit_;
  ::google::protobuf::RepeatedPtrField< ::RpbCommitHook > postcommit_;
  ::RpbModFun* chash_keyfun_;
  ::RpbModFun* linkfun_;
  ::google::protobuf::uint32 old_vclock_;
  ::google::protobuf::uint32 young_vclock_;
  ::google::protobuf::uint32 big_vclock_;
  ::google::protobuf::uint32 small_vclock_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 rw_;
  ::std::string* backend_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool search_;
  bool consistent_;
  int repl_;
  ::std::string* search_index_;
  ::std::string* datatype_;
  bool write_once_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbBucketProps* default_instance_;
};
// -------------------------------------------------------------------

class RpbAuthReq : public ::google::protobuf::Message {
 public:
  RpbAuthReq();
  virtual ~RpbAuthReq();

  RpbAuthReq(const RpbAuthReq& from);

  inline RpbAuthReq& operator=(const RpbAuthReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbAuthReq& default_instance();

  void Swap(RpbAuthReq* other);

  // implements Message ----------------------------------------------

  RpbAuthReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbAuthReq& from);
  void MergeFrom(const RpbAuthReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:RpbAuthReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbAuthReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbToggleEncodingReq : public ::google::protobuf::Message {
 public:
  RpbToggleEncodingReq();
  virtual ~RpbToggleEncodingReq();

  RpbToggleEncodingReq(const RpbToggleEncodingReq& from);

  inline RpbToggleEncodingReq& operator=(const RpbToggleEncodingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbToggleEncodingReq& default_instance();

  void Swap(RpbToggleEncodingReq* other);

  // implements Message ----------------------------------------------

  RpbToggleEncodingReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbToggleEncodingReq& from);
  void MergeFrom(const RpbToggleEncodingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool use_native = 1;
  inline bool has_use_native() const;
  inline void clear_use_native();
  static const int kUseNativeFieldNumber = 1;
  inline bool use_native() const;
  inline void set_use_native(bool value);

  // @@protoc_insertion_point(class_scope:RpbToggleEncodingReq)
 private:
  inline void set_has_use_native();
  inline void clear_has_use_native();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool use_native_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbToggleEncodingReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbToggleEncodingResp : public ::google::protobuf::Message {
 public:
  RpbToggleEncodingResp();
  virtual ~RpbToggleEncodingResp();

  RpbToggleEncodingResp(const RpbToggleEncodingResp& from);

  inline RpbToggleEncodingResp& operator=(const RpbToggleEncodingResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbToggleEncodingResp& default_instance();

  void Swap(RpbToggleEncodingResp* other);

  // implements Message ----------------------------------------------

  RpbToggleEncodingResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbToggleEncodingResp& from);
  void MergeFrom(const RpbToggleEncodingResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool use_native = 1;
  inline bool has_use_native() const;
  inline void clear_use_native();
  static const int kUseNativeFieldNumber = 1;
  inline bool use_native() const;
  inline void set_use_native(bool value);

  // @@protoc_insertion_point(class_scope:RpbToggleEncodingResp)
 private:
  inline void set_has_use_native();
  inline void clear_has_use_native();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool use_native_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbToggleEncodingResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSearchDoc : public ::google::protobuf::Message {
 public:
  RpbSearchDoc();
  virtual ~RpbSearchDoc();

  RpbSearchDoc(const RpbSearchDoc& from);

  inline RpbSearchDoc& operator=(const RpbSearchDoc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSearchDoc& default_instance();

  void Swap(RpbSearchDoc* other);

  // implements Message ----------------------------------------------

  RpbSearchDoc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSearchDoc& from);
  void MergeFrom(const RpbSearchDoc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbPair fields = 1;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 1;
  inline const ::RpbPair& fields(int index) const;
  inline ::RpbPair* mutable_fields(int index);
  inline ::RpbPair* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_fields();

  // @@protoc_insertion_point(class_scope:RpbSearchDoc)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > fields_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbSearchDoc* default_instance_;
};
// -------------------------------------------------------------------

class RpbSearchQueryReq : public ::google::protobuf::Message {
 public:
  RpbSearchQueryReq();
  virtual ~RpbSearchQueryReq();

  RpbSearchQueryReq(const RpbSearchQueryReq& from);

  inline RpbSearchQueryReq& operator=(const RpbSearchQueryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSearchQueryReq& default_instance();

  void Swap(RpbSearchQueryReq* other);

  // implements Message ----------------------------------------------

  RpbSearchQueryReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSearchQueryReq& from);
  void MergeFrom(const RpbSearchQueryReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes q = 1;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 1;
  inline const ::std::string& q() const;
  inline void set_q(const ::std::string& value);
  inline void set_q(const char* value);
  inline void set_q(const void* value, size_t size);
  inline ::std::string* mutable_q();
  inline ::std::string* release_q();
  inline void set_allocated_q(::std::string* q);

  // required bytes index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const void* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  inline void set_allocated_index(::std::string* index);

  // optional uint32 rows = 3;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);

  // optional uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional bytes sort = 5;
  inline bool has_sort() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 5;
  inline const ::std::string& sort() const;
  inline void set_sort(const ::std::string& value);
  inline void set_sort(const char* value);
  inline void set_sort(const void* value, size_t size);
  inline ::std::string* mutable_sort();
  inline ::std::string* release_sort();
  inline void set_allocated_sort(::std::string* sort);

  // optional bytes filter = 6;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 6;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const void* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  inline void set_allocated_filter(::std::string* filter);

  // optional bytes df = 7;
  inline bool has_df() const;
  inline void clear_df();
  static const int kDfFieldNumber = 7;
  inline const ::std::string& df() const;
  inline void set_df(const ::std::string& value);
  inline void set_df(const char* value);
  inline void set_df(const void* value, size_t size);
  inline ::std::string* mutable_df();
  inline ::std::string* release_df();
  inline void set_allocated_df(::std::string* df);

  // optional bytes op = 8;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 8;
  inline const ::std::string& op() const;
  inline void set_op(const ::std::string& value);
  inline void set_op(const char* value);
  inline void set_op(const void* value, size_t size);
  inline ::std::string* mutable_op();
  inline ::std::string* release_op();
  inline void set_allocated_op(::std::string* op);

  // repeated bytes fl = 9;
  inline int fl_size() const;
  inline void clear_fl();
  static const int kFlFieldNumber = 9;
  inline const ::std::string& fl(int index) const;
  inline ::std::string* mutable_fl(int index);
  inline void set_fl(int index, const ::std::string& value);
  inline void set_fl(int index, const char* value);
  inline void set_fl(int index, const void* value, size_t size);
  inline ::std::string* add_fl();
  inline void add_fl(const ::std::string& value);
  inline void add_fl(const char* value);
  inline void add_fl(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& fl() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fl();

  // optional bytes presort = 10;
  inline bool has_presort() const;
  inline void clear_presort();
  static const int kPresortFieldNumber = 10;
  inline const ::std::string& presort() const;
  inline void set_presort(const ::std::string& value);
  inline void set_presort(const char* value);
  inline void set_presort(const void* value, size_t size);
  inline ::std::string* mutable_presort();
  inline ::std::string* release_presort();
  inline void set_allocated_presort(::std::string* presort);

  // @@protoc_insertion_point(class_scope:RpbSearchQueryReq)
 private:
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_sort();
  inline void clear_has_sort();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_df();
  inline void clear_has_df();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_presort();
  inline void clear_has_presort();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* q_;
  ::std::string* index_;
  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 start_;
  ::std::string* sort_;
  ::std::string* filter_;
  ::std::string* df_;
  ::std::string* op_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fl_;
  ::std::string* presort_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbSearchQueryReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbSearchQueryResp : public ::google::protobuf::Message {
 public:
  RpbSearchQueryResp();
  virtual ~RpbSearchQueryResp();

  RpbSearchQueryResp(const RpbSearchQueryResp& from);

  inline RpbSearchQueryResp& operator=(const RpbSearchQueryResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSearchQueryResp& default_instance();

  void Swap(RpbSearchQueryResp* other);

  // implements Message ----------------------------------------------

  RpbSearchQueryResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSearchQueryResp& from);
  void MergeFrom(const RpbSearchQueryResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbSearchDoc docs = 1;
  inline int docs_size() const;
  inline void clear_docs();
  static const int kDocsFieldNumber = 1;
  inline const ::RpbSearchDoc& docs(int index) const;
  inline ::RpbSearchDoc* mutable_docs(int index);
  inline ::RpbSearchDoc* add_docs();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbSearchDoc >&
      docs() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbSearchDoc >*
      mutable_docs();

  // optional float max_score = 2;
  inline bool has_max_score() const;
  inline void clear_max_score();
  static const int kMaxScoreFieldNumber = 2;
  inline float max_score() const;
  inline void set_max_score(float value);

  // optional uint32 num_found = 3;
  inline bool has_num_found() const;
  inline void clear_num_found();
  static const int kNumFoundFieldNumber = 3;
  inline ::google::protobuf::uint32 num_found() const;
  inline void set_num_found(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbSearchQueryResp)
 private:
  inline void set_has_max_score();
  inline void clear_has_max_score();
  inline void set_has_num_found();
  inline void clear_has_num_found();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbSearchDoc > docs_;
  float max_score_;
  ::google::protobuf::uint32 num_found_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbSearchQueryResp* default_instance_;
};
// -------------------------------------------------------------------

class TsQueryReq : public ::google::protobuf::Message {
 public:
  TsQueryReq();
  virtual ~TsQueryReq();

  TsQueryReq(const TsQueryReq& from);

  inline TsQueryReq& operator=(const TsQueryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsQueryReq& default_instance();

  void Swap(TsQueryReq* other);

  // implements Message ----------------------------------------------

  TsQueryReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsQueryReq& from);
  void MergeFrom(const TsQueryReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TsInterpolation query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::TsInterpolation& query() const;
  inline ::TsInterpolation* mutable_query();
  inline ::TsInterpolation* release_query();
  inline void set_allocated_query(::TsInterpolation* query);

  // optional bool stream = 2 [default = false];
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional bytes cover_context = 3;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 3;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // @@protoc_insertion_point(class_scope:TsQueryReq)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TsInterpolation* query_;
  ::std::string* cover_context_;
  bool stream_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsQueryReq* default_instance_;
};
// -------------------------------------------------------------------

class TsQueryResp : public ::google::protobuf::Message {
 public:
  TsQueryResp();
  virtual ~TsQueryResp();

  TsQueryResp(const TsQueryResp& from);

  inline TsQueryResp& operator=(const TsQueryResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsQueryResp& default_instance();

  void Swap(TsQueryResp* other);

  // implements Message ----------------------------------------------

  TsQueryResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsQueryResp& from);
  void MergeFrom(const TsQueryResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsColumnDescription columns = 1;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 1;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 2;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // optional bool done = 3 [default = true];
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:TsQueryResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsQueryResp* default_instance_;
};
// -------------------------------------------------------------------

class TsGetReq : public ::google::protobuf::Message {
 public:
  TsGetReq();
  virtual ~TsGetReq();

  TsGetReq(const TsGetReq& from);

  inline TsGetReq& operator=(const TsGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsGetReq& default_instance();

  void Swap(TsGetReq* other);

  // implements Message ----------------------------------------------

  TsGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsGetReq& from);
  void MergeFrom(const TsGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsCell key = 2;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::TsCell& key(int index) const;
  inline ::TsCell* mutable_key(int index);
  inline ::TsCell* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
      mutable_key();

  // optional uint32 timeout = 3;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TsGetReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsCell > key_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsGetReq* default_instance_;
};
// -------------------------------------------------------------------

class TsGetResp : public ::google::protobuf::Message {
 public:
  TsGetResp();
  virtual ~TsGetResp();

  TsGetResp(const TsGetResp& from);

  inline TsGetResp& operator=(const TsGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsGetResp& default_instance();

  void Swap(TsGetResp* other);

  // implements Message ----------------------------------------------

  TsGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsGetResp& from);
  void MergeFrom(const TsGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsColumnDescription columns = 1;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 1;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 2;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:TsGetResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsGetResp* default_instance_;
};
// -------------------------------------------------------------------

class TsPutReq : public ::google::protobuf::Message {
 public:
  TsPutReq();
  virtual ~TsPutReq();

  TsPutReq(const TsPutReq& from);

  inline TsPutReq& operator=(const TsPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsPutReq& default_instance();

  void Swap(TsPutReq* other);

  // implements Message ----------------------------------------------

  TsPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsPutReq& from);
  void MergeFrom(const TsPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsColumnDescription columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 3;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:TsPutReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsPutReq* default_instance_;
};
// -------------------------------------------------------------------

class TsTtbPutReq : public ::google::protobuf::Message {
 public:
  TsTtbPutReq();
  virtual ~TsTtbPutReq();

  TsTtbPutReq(const TsTtbPutReq& from);

  inline TsTtbPutReq& operator=(const TsTtbPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsTtbPutReq& default_instance();

  void Swap(TsTtbPutReq* other);

  // implements Message ----------------------------------------------

  TsTtbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsTtbPutReq& from);
  void MergeFrom(const TsTtbPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsColumnDescription columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 3;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:TsTtbPutReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsTtbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class TsPutResp : public ::google::protobuf::Message {
 public:
  TsPutResp();
  virtual ~TsPutResp();

  TsPutResp(const TsPutResp& from);

  inline TsPutResp& operator=(const TsPutResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsPutResp& default_instance();

  void Swap(TsPutResp* other);

  // implements Message ----------------------------------------------

  TsPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsPutResp& from);
  void MergeFrom(const TsPutResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TsPutResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsPutResp* default_instance_;
};
// -------------------------------------------------------------------

class TsDelReq : public ::google::protobuf::Message {
 public:
  TsDelReq();
  virtual ~TsDelReq();

  TsDelReq(const TsDelReq& from);

  inline TsDelReq& operator=(const TsDelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsDelReq& default_instance();

  void Swap(TsDelReq* other);

  // implements Message ----------------------------------------------

  TsDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsDelReq& from);
  void MergeFrom(const TsDelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsCell key = 2;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::TsCell& key(int index) const;
  inline ::TsCell* mutable_key(int index);
  inline ::TsCell* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
      mutable_key();

  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional uint32 timeout = 4;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TsDelReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsCell > key_;
  ::std::string* vclock_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsDelReq* default_instance_;
};
// -------------------------------------------------------------------

class TsDelResp : public ::google::protobuf::Message {
 public:
  TsDelResp();
  virtual ~TsDelResp();

  TsDelResp(const TsDelResp& from);

  inline TsDelResp& operator=(const TsDelResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsDelResp& default_instance();

  void Swap(TsDelResp* other);

  // implements Message ----------------------------------------------

  TsDelResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsDelResp& from);
  void MergeFrom(const TsDelResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TsDelResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsDelResp* default_instance_;
};
// -------------------------------------------------------------------

class TsInterpolation : public ::google::protobuf::Message {
 public:
  TsInterpolation();
  virtual ~TsInterpolation();

  TsInterpolation(const TsInterpolation& from);

  inline TsInterpolation& operator=(const TsInterpolation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsInterpolation& default_instance();

  void Swap(TsInterpolation* other);

  // implements Message ----------------------------------------------

  TsInterpolation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsInterpolation& from);
  void MergeFrom(const TsInterpolation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::std::string& base() const;
  inline void set_base(const ::std::string& value);
  inline void set_base(const char* value);
  inline void set_base(const void* value, size_t size);
  inline ::std::string* mutable_base();
  inline ::std::string* release_base();
  inline void set_allocated_base(::std::string* base);

  // repeated .RpbPair interpolations = 2;
  inline int interpolations_size() const;
  inline void clear_interpolations();
  static const int kInterpolationsFieldNumber = 2;
  inline const ::RpbPair& interpolations(int index) const;
  inline ::RpbPair* mutable_interpolations(int index);
  inline ::RpbPair* add_interpolations();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      interpolations() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_interpolations();

  // @@protoc_insertion_point(class_scope:TsInterpolation)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* base_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > interpolations_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsInterpolation* default_instance_;
};
// -------------------------------------------------------------------

class TsColumnDescription : public ::google::protobuf::Message {
 public:
  TsColumnDescription();
  virtual ~TsColumnDescription();

  TsColumnDescription(const TsColumnDescription& from);

  inline TsColumnDescription& operator=(const TsColumnDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsColumnDescription& default_instance();

  void Swap(TsColumnDescription* other);

  // implements Message ----------------------------------------------

  TsColumnDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsColumnDescription& from);
  void MergeFrom(const TsColumnDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .TsColumnType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::TsColumnType type() const;
  inline void set_type(::TsColumnType value);

  // @@protoc_insertion_point(class_scope:TsColumnDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsColumnDescription* default_instance_;
};
// -------------------------------------------------------------------

class TsRow : public ::google::protobuf::Message {
 public:
  TsRow();
  virtual ~TsRow();

  TsRow(const TsRow& from);

  inline TsRow& operator=(const TsRow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsRow& default_instance();

  void Swap(TsRow* other);

  // implements Message ----------------------------------------------

  TsRow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsRow& from);
  void MergeFrom(const TsRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsCell cells = 1;
  inline int cells_size() const;
  inline void clear_cells();
  static const int kCellsFieldNumber = 1;
  inline const ::TsCell& cells(int index) const;
  inline ::TsCell* mutable_cells(int index);
  inline ::TsCell* add_cells();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
      cells() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
      mutable_cells();

  // @@protoc_insertion_point(class_scope:TsRow)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsCell > cells_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsRow* default_instance_;
};
// -------------------------------------------------------------------

class TsCell : public ::google::protobuf::Message {
 public:
  TsCell();
  virtual ~TsCell();

  TsCell(const TsCell& from);

  inline TsCell& operator=(const TsCell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCell& default_instance();

  void Swap(TsCell* other);

  // implements Message ----------------------------------------------

  TsCell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCell& from);
  void MergeFrom(const TsCell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes varchar_value = 1;
  inline bool has_varchar_value() const;
  inline void clear_varchar_value();
  static const int kVarcharValueFieldNumber = 1;
  inline const ::std::string& varchar_value() const;
  inline void set_varchar_value(const ::std::string& value);
  inline void set_varchar_value(const char* value);
  inline void set_varchar_value(const void* value, size_t size);
  inline ::std::string* mutable_varchar_value();
  inline ::std::string* release_varchar_value();
  inline void set_allocated_varchar_value(::std::string* varchar_value);

  // optional sint64 sint64_value = 2;
  inline bool has_sint64_value() const;
  inline void clear_sint64_value();
  static const int kSint64ValueFieldNumber = 2;
  inline ::google::protobuf::int64 sint64_value() const;
  inline void set_sint64_value(::google::protobuf::int64 value);

  // optional sint64 timestamp_value = 3;
  inline bool has_timestamp_value() const;
  inline void clear_timestamp_value();
  static const int kTimestampValueFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp_value() const;
  inline void set_timestamp_value(::google::protobuf::int64 value);

  // optional bool boolean_value = 4;
  inline bool has_boolean_value() const;
  inline void clear_boolean_value();
  static const int kBooleanValueFieldNumber = 4;
  inline bool boolean_value() const;
  inline void set_boolean_value(bool value);

  // optional double double_value = 5;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 5;
  inline double double_value() const;
  inline void set_double_value(double value);

  // @@protoc_insertion_point(class_scope:TsCell)
 private:
  inline void set_has_varchar_value();
  inline void clear_has_varchar_value();
  inline void set_has_sint64_value();
  inline void clear_has_sint64_value();
  inline void set_has_timestamp_value();
  inline void clear_has_timestamp_value();
  inline void set_has_boolean_value();
  inline void clear_has_boolean_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* varchar_value_;
  ::google::protobuf::int64 sint64_value_;
  ::google::protobuf::int64 timestamp_value_;
  double double_value_;
  bool boolean_value_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsCell* default_instance_;
};
// -------------------------------------------------------------------

class TsListKeysReq : public ::google::protobuf::Message {
 public:
  TsListKeysReq();
  virtual ~TsListKeysReq();

  TsListKeysReq(const TsListKeysReq& from);

  inline TsListKeysReq& operator=(const TsListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsListKeysReq& default_instance();

  void Swap(TsListKeysReq* other);

  // implements Message ----------------------------------------------

  TsListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsListKeysReq& from);
  void MergeFrom(const TsListKeysReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TsListKeysReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class TsListKeysResp : public ::google::protobuf::Message {
 public:
  TsListKeysResp();
  virtual ~TsListKeysResp();

  TsListKeysResp(const TsListKeysResp& from);

  inline TsListKeysResp& operator=(const TsListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsListKeysResp& default_instance();

  void Swap(TsListKeysResp* other);

  // implements Message ----------------------------------------------

  TsListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsListKeysResp& from);
  void MergeFrom(const TsListKeysResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsRow keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::TsRow& keys(int index) const;
  inline ::TsRow* mutable_keys(int index);
  inline ::TsRow* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_keys();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:TsListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > keys_;
  bool done_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class TsCoverageReq : public ::google::protobuf::Message {
 public:
  TsCoverageReq();
  virtual ~TsCoverageReq();

  TsCoverageReq(const TsCoverageReq& from);

  inline TsCoverageReq& operator=(const TsCoverageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCoverageReq& default_instance();

  void Swap(TsCoverageReq* other);

  // implements Message ----------------------------------------------

  TsCoverageReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCoverageReq& from);
  void MergeFrom(const TsCoverageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TsInterpolation query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::TsInterpolation& query() const;
  inline ::TsInterpolation* mutable_query();
  inline ::TsInterpolation* release_query();
  inline void set_allocated_query(::TsInterpolation* query);

  // required bytes table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // optional bytes replace_cover = 3;
  inline bool has_replace_cover() const;
  inline void clear_replace_cover();
  static const int kReplaceCoverFieldNumber = 3;
  inline const ::std::string& replace_cover() const;
  inline void set_replace_cover(const ::std::string& value);
  inline void set_replace_cover(const char* value);
  inline void set_replace_cover(const void* value, size_t size);
  inline ::std::string* mutable_replace_cover();
  inline ::std::string* release_replace_cover();
  inline void set_allocated_replace_cover(::std::string* replace_cover);

  // repeated bytes unavailable_cover = 4;
  inline int unavailable_cover_size() const;
  inline void clear_unavailable_cover();
  static const int kUnavailableCoverFieldNumber = 4;
  inline const ::std::string& unavailable_cover(int index) const;
  inline ::std::string* mutable_unavailable_cover(int index);
  inline void set_unavailable_cover(int index, const ::std::string& value);
  inline void set_unavailable_cover(int index, const char* value);
  inline void set_unavailable_cover(int index, const void* value, size_t size);
  inline ::std::string* add_unavailable_cover();
  inline void add_unavailable_cover(const ::std::string& value);
  inline void add_unavailable_cover(const char* value);
  inline void add_unavailable_cover(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unavailable_cover() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unavailable_cover();

  // @@protoc_insertion_point(class_scope:TsCoverageReq)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_replace_cover();
  inline void clear_has_replace_cover();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TsInterpolation* query_;
  ::std::string* table_;
  ::std::string* replace_cover_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unavailable_cover_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsCoverageReq* default_instance_;
};
// -------------------------------------------------------------------

class TsCoverageResp : public ::google::protobuf::Message {
 public:
  TsCoverageResp();
  virtual ~TsCoverageResp();

  TsCoverageResp(const TsCoverageResp& from);

  inline TsCoverageResp& operator=(const TsCoverageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCoverageResp& default_instance();

  void Swap(TsCoverageResp* other);

  // implements Message ----------------------------------------------

  TsCoverageResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCoverageResp& from);
  void MergeFrom(const TsCoverageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsCoverageEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TsCoverageEntry& entries(int index) const;
  inline ::TsCoverageEntry* mutable_entries(int index);
  inline ::TsCoverageEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TsCoverageResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry > entries_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsCoverageResp* default_instance_;
};
// -------------------------------------------------------------------

class TsCoverageEntry : public ::google::protobuf::Message {
 public:
  TsCoverageEntry();
  virtual ~TsCoverageEntry();

  TsCoverageEntry(const TsCoverageEntry& from);

  inline TsCoverageEntry& operator=(const TsCoverageEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCoverageEntry& default_instance();

  void Swap(TsCoverageEntry* other);

  // implements Message ----------------------------------------------

  TsCoverageEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCoverageEntry& from);
  void MergeFrom(const TsCoverageEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required bytes cover_context = 3;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 3;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // optional .TsRange range = 4;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 4;
  inline const ::TsRange& range() const;
  inline ::TsRange* mutable_range();
  inline ::TsRange* release_range();
  inline void set_allocated_range(::TsRange* range);

  // @@protoc_insertion_point(class_scope:TsCoverageEntry)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* cover_context_;
  ::TsRange* range_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsCoverageEntry* default_instance_;
};
// -------------------------------------------------------------------

class TsRange : public ::google::protobuf::Message {
 public:
  TsRange();
  virtual ~TsRange();

  TsRange(const TsRange& from);

  inline TsRange& operator=(const TsRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsRange& default_instance();

  void Swap(TsRange* other);

  // implements Message ----------------------------------------------

  TsRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsRange& from);
  void MergeFrom(const TsRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes field_name = 1;
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const void* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // required sint64 lower_bound = 2;
  inline bool has_lower_bound() const;
  inline void clear_lower_bound();
  static const int kLowerBoundFieldNumber = 2;
  inline ::google::protobuf::int64 lower_bound() const;
  inline void set_lower_bound(::google::protobuf::int64 value);

  // required bool lower_bound_inclusive = 3;
  inline bool has_lower_bound_inclusive() const;
  inline void clear_lower_bound_inclusive();
  static const int kLowerBoundInclusiveFieldNumber = 3;
  inline bool lower_bound_inclusive() const;
  inline void set_lower_bound_inclusive(bool value);

  // required sint64 upper_bound = 4;
  inline bool has_upper_bound() const;
  inline void clear_upper_bound();
  static const int kUpperBoundFieldNumber = 4;
  inline ::google::protobuf::int64 upper_bound() const;
  inline void set_upper_bound(::google::protobuf::int64 value);

  // required bool upper_bound_inclusive = 5;
  inline bool has_upper_bound_inclusive() const;
  inline void clear_upper_bound_inclusive();
  static const int kUpperBoundInclusiveFieldNumber = 5;
  inline bool upper_bound_inclusive() const;
  inline void set_upper_bound_inclusive(bool value);

  // required bytes desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:TsRange)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_lower_bound();
  inline void clear_has_lower_bound();
  inline void set_has_lower_bound_inclusive();
  inline void clear_has_lower_bound_inclusive();
  inline void set_has_upper_bound();
  inline void clear_has_upper_bound();
  inline void set_has_upper_bound_inclusive();
  inline void clear_has_upper_bound_inclusive();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* field_name_;
  ::google::protobuf::int64 lower_bound_;
  ::google::protobuf::int64 upper_bound_;
  ::std::string* desc_;
  bool lower_bound_inclusive_;
  bool upper_bound_inclusive_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static TsRange* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaIndex : public ::google::protobuf::Message {
 public:
  RpbYokozunaIndex();
  virtual ~RpbYokozunaIndex();

  RpbYokozunaIndex(const RpbYokozunaIndex& from);

  inline RpbYokozunaIndex& operator=(const RpbYokozunaIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaIndex& default_instance();

  void Swap(RpbYokozunaIndex* other);

  // implements Message ----------------------------------------------

  RpbYokozunaIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaIndex& from);
  void MergeFrom(const RpbYokozunaIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes schema = 2;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 2;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const void* value, size_t size);
  inline ::std::string* mutable_schema();
  inline ::std::string* release_schema();
  inline void set_allocated_schema(::std::string* schema);

  // optional uint32 n_val = 3;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 3;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbYokozunaIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_n_val();
  inline void clear_has_n_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* schema_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaIndex* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaIndexGetReq : public ::google::protobuf::Message {
 public:
  RpbYokozunaIndexGetReq();
  virtual ~RpbYokozunaIndexGetReq();

  RpbYokozunaIndexGetReq(const RpbYokozunaIndexGetReq& from);

  inline RpbYokozunaIndexGetReq& operator=(const RpbYokozunaIndexGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaIndexGetReq& default_instance();

  void Swap(RpbYokozunaIndexGetReq* other);

  // implements Message ----------------------------------------------

  RpbYokozunaIndexGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaIndexGetReq& from);
  void MergeFrom(const RpbYokozunaIndexGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:RpbYokozunaIndexGetReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaIndexGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaIndexGetResp : public ::google::protobuf::Message {
 public:
  RpbYokozunaIndexGetResp();
  virtual ~RpbYokozunaIndexGetResp();

  RpbYokozunaIndexGetResp(const RpbYokozunaIndexGetResp& from);

  inline RpbYokozunaIndexGetResp& operator=(const RpbYokozunaIndexGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaIndexGetResp& default_instance();

  void Swap(RpbYokozunaIndexGetResp* other);

  // implements Message ----------------------------------------------

  RpbYokozunaIndexGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaIndexGetResp& from);
  void MergeFrom(const RpbYokozunaIndexGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbYokozunaIndex index = 1;
  inline int index_size() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline const ::RpbYokozunaIndex& index(int index) const;
  inline ::RpbYokozunaIndex* mutable_index(int index);
  inline ::RpbYokozunaIndex* add_index();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbYokozunaIndex >&
      index() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbYokozunaIndex >*
      mutable_index();

  // @@protoc_insertion_point(class_scope:RpbYokozunaIndexGetResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbYokozunaIndex > index_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaIndexGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaIndexPutReq : public ::google::protobuf::Message {
 public:
  RpbYokozunaIndexPutReq();
  virtual ~RpbYokozunaIndexPutReq();

  RpbYokozunaIndexPutReq(const RpbYokozunaIndexPutReq& from);

  inline RpbYokozunaIndexPutReq& operator=(const RpbYokozunaIndexPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaIndexPutReq& default_instance();

  void Swap(RpbYokozunaIndexPutReq* other);

  // implements Message ----------------------------------------------

  RpbYokozunaIndexPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaIndexPutReq& from);
  void MergeFrom(const RpbYokozunaIndexPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RpbYokozunaIndex index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline const ::RpbYokozunaIndex& index() const;
  inline ::RpbYokozunaIndex* mutable_index();
  inline ::RpbYokozunaIndex* release_index();
  inline void set_allocated_index(::RpbYokozunaIndex* index);

  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RpbYokozunaIndexPutReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RpbYokozunaIndex* index_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaIndexPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaIndexDeleteReq : public ::google::protobuf::Message {
 public:
  RpbYokozunaIndexDeleteReq();
  virtual ~RpbYokozunaIndexDeleteReq();

  RpbYokozunaIndexDeleteReq(const RpbYokozunaIndexDeleteReq& from);

  inline RpbYokozunaIndexDeleteReq& operator=(const RpbYokozunaIndexDeleteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaIndexDeleteReq& default_instance();

  void Swap(RpbYokozunaIndexDeleteReq* other);

  // implements Message ----------------------------------------------

  RpbYokozunaIndexDeleteReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaIndexDeleteReq& from);
  void MergeFrom(const RpbYokozunaIndexDeleteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:RpbYokozunaIndexDeleteReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaIndexDeleteReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaSchema : public ::google::protobuf::Message {
 public:
  RpbYokozunaSchema();
  virtual ~RpbYokozunaSchema();

  RpbYokozunaSchema(const RpbYokozunaSchema& from);

  inline RpbYokozunaSchema& operator=(const RpbYokozunaSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaSchema& default_instance();

  void Swap(RpbYokozunaSchema* other);

  // implements Message ----------------------------------------------

  RpbYokozunaSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaSchema& from);
  void MergeFrom(const RpbYokozunaSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:RpbYokozunaSchema)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaSchema* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaSchemaPutReq : public ::google::protobuf::Message {
 public:
  RpbYokozunaSchemaPutReq();
  virtual ~RpbYokozunaSchemaPutReq();

  RpbYokozunaSchemaPutReq(const RpbYokozunaSchemaPutReq& from);

  inline RpbYokozunaSchemaPutReq& operator=(const RpbYokozunaSchemaPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaSchemaPutReq& default_instance();

  void Swap(RpbYokozunaSchemaPutReq* other);

  // implements Message ----------------------------------------------

  RpbYokozunaSchemaPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaSchemaPutReq& from);
  void MergeFrom(const RpbYokozunaSchemaPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RpbYokozunaSchema schema = 1;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::RpbYokozunaSchema& schema() const;
  inline ::RpbYokozunaSchema* mutable_schema();
  inline ::RpbYokozunaSchema* release_schema();
  inline void set_allocated_schema(::RpbYokozunaSchema* schema);

  // @@protoc_insertion_point(class_scope:RpbYokozunaSchemaPutReq)
 private:
  inline void set_has_schema();
  inline void clear_has_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RpbYokozunaSchema* schema_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaSchemaPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaSchemaGetReq : public ::google::protobuf::Message {
 public:
  RpbYokozunaSchemaGetReq();
  virtual ~RpbYokozunaSchemaGetReq();

  RpbYokozunaSchemaGetReq(const RpbYokozunaSchemaGetReq& from);

  inline RpbYokozunaSchemaGetReq& operator=(const RpbYokozunaSchemaGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaSchemaGetReq& default_instance();

  void Swap(RpbYokozunaSchemaGetReq* other);

  // implements Message ----------------------------------------------

  RpbYokozunaSchemaGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaSchemaGetReq& from);
  void MergeFrom(const RpbYokozunaSchemaGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:RpbYokozunaSchemaGetReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaSchemaGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbYokozunaSchemaGetResp : public ::google::protobuf::Message {
 public:
  RpbYokozunaSchemaGetResp();
  virtual ~RpbYokozunaSchemaGetResp();

  RpbYokozunaSchemaGetResp(const RpbYokozunaSchemaGetResp& from);

  inline RpbYokozunaSchemaGetResp& operator=(const RpbYokozunaSchemaGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbYokozunaSchemaGetResp& default_instance();

  void Swap(RpbYokozunaSchemaGetResp* other);

  // implements Message ----------------------------------------------

  RpbYokozunaSchemaGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbYokozunaSchemaGetResp& from);
  void MergeFrom(const RpbYokozunaSchemaGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RpbYokozunaSchema schema = 1;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::RpbYokozunaSchema& schema() const;
  inline ::RpbYokozunaSchema* mutable_schema();
  inline ::RpbYokozunaSchema* release_schema();
  inline void set_allocated_schema(::RpbYokozunaSchema* schema);

  // @@protoc_insertion_point(class_scope:RpbYokozunaSchemaGetResp)
 private:
  inline void set_has_schema();
  inline void clear_has_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RpbYokozunaSchema* schema_;
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();

  void InitAsDefaultInstance();
  static RpbYokozunaSchemaGetResp* default_instance_;
};
// ===================================================================


// ===================================================================

// MapField

// required bytes name = 1;
inline bool MapField::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapField::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapField::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapField::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapField::name() const {
  // @@protoc_insertion_point(field_get:MapField.name)
  return *name_;
}
inline void MapField::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:MapField.name)
}
inline void MapField::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapField.name)
}
inline void MapField::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapField.name)
}
inline ::std::string* MapField::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapField.name)
  return name_;
}
inline ::std::string* MapField::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapField::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapField.name)
}

// required .MapField.MapFieldType type = 2;
inline bool MapField::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapField::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapField::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapField::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::MapField_MapFieldType MapField::type() const {
  // @@protoc_insertion_point(field_get:MapField.type)
  return static_cast< ::MapField_MapFieldType >(type_);
}
inline void MapField::set_type(::MapField_MapFieldType value) {
  assert(::MapField_MapFieldType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MapField.type)
}

// -------------------------------------------------------------------

// MapEntry

// required .MapField field = 1;
inline bool MapEntry::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapEntry::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapEntry::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapEntry::clear_field() {
  if (field_ != NULL) field_->::MapField::Clear();
  clear_has_field();
}
inline const ::MapField& MapEntry::field() const {
  // @@protoc_insertion_point(field_get:MapEntry.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::MapField* MapEntry::mutable_field() {
  set_has_field();
  if (field_ == NULL) field_ = new ::MapField;
  // @@protoc_insertion_point(field_mutable:MapEntry.field)
  return field_;
}
inline ::MapField* MapEntry::release_field() {
  clear_has_field();
  ::MapField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void MapEntry::set_allocated_field(::MapField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:MapEntry.field)
}

// optional sint64 counter_value = 2;
inline bool MapEntry::has_counter_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapEntry::set_has_counter_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapEntry::clear_has_counter_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapEntry::clear_counter_value() {
  counter_value_ = GOOGLE_LONGLONG(0);
  clear_has_counter_value();
}
inline ::google::protobuf::int64 MapEntry::counter_value() const {
  // @@protoc_insertion_point(field_get:MapEntry.counter_value)
  return counter_value_;
}
inline void MapEntry::set_counter_value(::google::protobuf::int64 value) {
  set_has_counter_value();
  counter_value_ = value;
  // @@protoc_insertion_point(field_set:MapEntry.counter_value)
}

// repeated bytes set_value = 3;
inline int MapEntry::set_value_size() const {
  return set_value_.size();
}
inline void MapEntry::clear_set_value() {
  set_value_.Clear();
}
inline const ::std::string& MapEntry::set_value(int index) const {
  // @@protoc_insertion_point(field_get:MapEntry.set_value)
  return set_value_.Get(index);
}
inline ::std::string* MapEntry::mutable_set_value(int index) {
  // @@protoc_insertion_point(field_mutable:MapEntry.set_value)
  return set_value_.Mutable(index);
}
inline void MapEntry::set_set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MapEntry.set_value)
  set_value_.Mutable(index)->assign(value);
}
inline void MapEntry::set_set_value(int index, const char* value) {
  set_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MapEntry.set_value)
}
inline void MapEntry::set_set_value(int index, const void* value, size_t size) {
  set_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapEntry.set_value)
}
inline ::std::string* MapEntry::add_set_value() {
  return set_value_.Add();
}
inline void MapEntry::add_set_value(const ::std::string& value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MapEntry.set_value)
}
inline void MapEntry::add_set_value(const char* value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MapEntry.set_value)
}
inline void MapEntry::add_set_value(const void* value, size_t size) {
  set_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MapEntry.set_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapEntry::set_value() const {
  // @@protoc_insertion_point(field_list:MapEntry.set_value)
  return set_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapEntry::mutable_set_value() {
  // @@protoc_insertion_point(field_mutable_list:MapEntry.set_value)
  return &set_value_;
}

// optional bytes register_value = 4;
inline bool MapEntry::has_register_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapEntry::set_has_register_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapEntry::clear_has_register_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapEntry::clear_register_value() {
  if (register_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_->clear();
  }
  clear_has_register_value();
}
inline const ::std::string& MapEntry::register_value() const {
  // @@protoc_insertion_point(field_get:MapEntry.register_value)
  return *register_value_;
}
inline void MapEntry::set_register_value(const ::std::string& value) {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  register_value_->assign(value);
  // @@protoc_insertion_point(field_set:MapEntry.register_value)
}
inline void MapEntry::set_register_value(const char* value) {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  register_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapEntry.register_value)
}
inline void MapEntry::set_register_value(const void* value, size_t size) {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  register_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapEntry.register_value)
}
inline ::std::string* MapEntry::mutable_register_value() {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapEntry.register_value)
  return register_value_;
}
inline ::std::string* MapEntry::release_register_value() {
  clear_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_value_;
    register_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapEntry::set_allocated_register_value(::std::string* register_value) {
  if (register_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_value_;
  }
  if (register_value) {
    set_has_register_value();
    register_value_ = register_value;
  } else {
    clear_has_register_value();
    register_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapEntry.register_value)
}

// optional bool flag_value = 5;
inline bool MapEntry::has_flag_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapEntry::set_has_flag_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapEntry::clear_has_flag_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapEntry::clear_flag_value() {
  flag_value_ = false;
  clear_has_flag_value();
}
inline bool MapEntry::flag_value() const {
  // @@protoc_insertion_point(field_get:MapEntry.flag_value)
  return flag_value_;
}
inline void MapEntry::set_flag_value(bool value) {
  set_has_flag_value();
  flag_value_ = value;
  // @@protoc_insertion_point(field_set:MapEntry.flag_value)
}

// repeated .MapEntry map_value = 6;
inline int MapEntry::map_value_size() const {
  return map_value_.size();
}
inline void MapEntry::clear_map_value() {
  map_value_.Clear();
}
inline const ::MapEntry& MapEntry::map_value(int index) const {
  // @@protoc_insertion_point(field_get:MapEntry.map_value)
  return map_value_.Get(index);
}
inline ::MapEntry* MapEntry::mutable_map_value(int index) {
  // @@protoc_insertion_point(field_mutable:MapEntry.map_value)
  return map_value_.Mutable(index);
}
inline ::MapEntry* MapEntry::add_map_value() {
  // @@protoc_insertion_point(field_add:MapEntry.map_value)
  return map_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
MapEntry::map_value() const {
  // @@protoc_insertion_point(field_list:MapEntry.map_value)
  return map_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
MapEntry::mutable_map_value() {
  // @@protoc_insertion_point(field_mutable_list:MapEntry.map_value)
  return &map_value_;
}

// -------------------------------------------------------------------

// DtFetchReq

// required bytes bucket = 1;
inline bool DtFetchReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtFetchReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtFetchReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtFetchReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& DtFetchReq::bucket() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.bucket)
  return *bucket_;
}
inline void DtFetchReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchReq.bucket)
}
inline void DtFetchReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchReq.bucket)
}
inline void DtFetchReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchReq.bucket)
}
inline ::std::string* DtFetchReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchReq.bucket)
  return bucket_;
}
inline ::std::string* DtFetchReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchReq.bucket)
}

// required bytes key = 2;
inline bool DtFetchReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtFetchReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtFetchReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtFetchReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DtFetchReq::key() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.key)
  return *key_;
}
inline void DtFetchReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchReq.key)
}
inline void DtFetchReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchReq.key)
}
inline void DtFetchReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchReq.key)
}
inline ::std::string* DtFetchReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchReq.key)
  return key_;
}
inline ::std::string* DtFetchReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchReq.key)
}

// required bytes type = 3;
inline bool DtFetchReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtFetchReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtFetchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtFetchReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& DtFetchReq::type() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.type)
  return *type_;
}
inline void DtFetchReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchReq.type)
}
inline void DtFetchReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchReq.type)
}
inline void DtFetchReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchReq.type)
}
inline ::std::string* DtFetchReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchReq.type)
  return type_;
}
inline ::std::string* DtFetchReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchReq.type)
}

// optional uint32 r = 4;
inline bool DtFetchReq::has_r() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DtFetchReq::set_has_r() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DtFetchReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DtFetchReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 DtFetchReq::r() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.r)
  return r_;
}
inline void DtFetchReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.r)
}

// optional uint32 pr = 5;
inline bool DtFetchReq::has_pr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DtFetchReq::set_has_pr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DtFetchReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DtFetchReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 DtFetchReq::pr() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.pr)
  return pr_;
}
inline void DtFetchReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.pr)
}

// optional bool basic_quorum = 6;
inline bool DtFetchReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DtFetchReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DtFetchReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DtFetchReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool DtFetchReq::basic_quorum() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.basic_quorum)
  return basic_quorum_;
}
inline void DtFetchReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.basic_quorum)
}

// optional bool notfound_ok = 7;
inline bool DtFetchReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DtFetchReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DtFetchReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DtFetchReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool DtFetchReq::notfound_ok() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.notfound_ok)
  return notfound_ok_;
}
inline void DtFetchReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.notfound_ok)
}

// optional uint32 timeout = 8;
inline bool DtFetchReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DtFetchReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DtFetchReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DtFetchReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 DtFetchReq::timeout() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.timeout)
  return timeout_;
}
inline void DtFetchReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.timeout)
}

// optional bool sloppy_quorum = 9;
inline bool DtFetchReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DtFetchReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DtFetchReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DtFetchReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool DtFetchReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void DtFetchReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.sloppy_quorum)
}

// optional uint32 n_val = 10;
inline bool DtFetchReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DtFetchReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DtFetchReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DtFetchReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 DtFetchReq::n_val() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.n_val)
  return n_val_;
}
inline void DtFetchReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.n_val)
}

// optional bool include_context = 11 [default = true];
inline bool DtFetchReq::has_include_context() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DtFetchReq::set_has_include_context() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DtFetchReq::clear_has_include_context() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DtFetchReq::clear_include_context() {
  include_context_ = true;
  clear_has_include_context();
}
inline bool DtFetchReq::include_context() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.include_context)
  return include_context_;
}
inline void DtFetchReq::set_include_context(bool value) {
  set_has_include_context();
  include_context_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.include_context)
}

// -------------------------------------------------------------------

// DtValue

// optional sint64 counter_value = 1;
inline bool DtValue::has_counter_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtValue::set_has_counter_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtValue::clear_has_counter_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtValue::clear_counter_value() {
  counter_value_ = GOOGLE_LONGLONG(0);
  clear_has_counter_value();
}
inline ::google::protobuf::int64 DtValue::counter_value() const {
  // @@protoc_insertion_point(field_get:DtValue.counter_value)
  return counter_value_;
}
inline void DtValue::set_counter_value(::google::protobuf::int64 value) {
  set_has_counter_value();
  counter_value_ = value;
  // @@protoc_insertion_point(field_set:DtValue.counter_value)
}

// repeated bytes set_value = 2;
inline int DtValue::set_value_size() const {
  return set_value_.size();
}
inline void DtValue::clear_set_value() {
  set_value_.Clear();
}
inline const ::std::string& DtValue::set_value(int index) const {
  // @@protoc_insertion_point(field_get:DtValue.set_value)
  return set_value_.Get(index);
}
inline ::std::string* DtValue::mutable_set_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtValue.set_value)
  return set_value_.Mutable(index);
}
inline void DtValue::set_set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DtValue.set_value)
  set_value_.Mutable(index)->assign(value);
}
inline void DtValue::set_set_value(int index, const char* value) {
  set_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DtValue.set_value)
}
inline void DtValue::set_set_value(int index, const void* value, size_t size) {
  set_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtValue.set_value)
}
inline ::std::string* DtValue::add_set_value() {
  return set_value_.Add();
}
inline void DtValue::add_set_value(const ::std::string& value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DtValue.set_value)
}
inline void DtValue::add_set_value(const char* value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DtValue.set_value)
}
inline void DtValue::add_set_value(const void* value, size_t size) {
  set_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DtValue.set_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DtValue::set_value() const {
  // @@protoc_insertion_point(field_list:DtValue.set_value)
  return set_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DtValue::mutable_set_value() {
  // @@protoc_insertion_point(field_mutable_list:DtValue.set_value)
  return &set_value_;
}

// repeated .MapEntry map_value = 3;
inline int DtValue::map_value_size() const {
  return map_value_.size();
}
inline void DtValue::clear_map_value() {
  map_value_.Clear();
}
inline const ::MapEntry& DtValue::map_value(int index) const {
  // @@protoc_insertion_point(field_get:DtValue.map_value)
  return map_value_.Get(index);
}
inline ::MapEntry* DtValue::mutable_map_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtValue.map_value)
  return map_value_.Mutable(index);
}
inline ::MapEntry* DtValue::add_map_value() {
  // @@protoc_insertion_point(field_add:DtValue.map_value)
  return map_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
DtValue::map_value() const {
  // @@protoc_insertion_point(field_list:DtValue.map_value)
  return map_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
DtValue::mutable_map_value() {
  // @@protoc_insertion_point(field_mutable_list:DtValue.map_value)
  return &map_value_;
}

// -------------------------------------------------------------------

// DtFetchResp

// optional bytes context = 1;
inline bool DtFetchResp::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtFetchResp::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtFetchResp::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtFetchResp::clear_context() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DtFetchResp::context() const {
  // @@protoc_insertion_point(field_get:DtFetchResp.context)
  return *context_;
}
inline void DtFetchResp::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchResp.context)
}
inline void DtFetchResp::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchResp.context)
}
inline void DtFetchResp::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchResp.context)
}
inline ::std::string* DtFetchResp::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchResp.context)
  return context_;
}
inline ::std::string* DtFetchResp::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchResp::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchResp.context)
}

// required .DtFetchResp.DataType type = 2;
inline bool DtFetchResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtFetchResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtFetchResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtFetchResp::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::DtFetchResp_DataType DtFetchResp::type() const {
  // @@protoc_insertion_point(field_get:DtFetchResp.type)
  return static_cast< ::DtFetchResp_DataType >(type_);
}
inline void DtFetchResp::set_type(::DtFetchResp_DataType value) {
  assert(::DtFetchResp_DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DtFetchResp.type)
}

// optional .DtValue value = 3;
inline bool DtFetchResp::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtFetchResp::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtFetchResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtFetchResp::clear_value() {
  if (value_ != NULL) value_->::DtValue::Clear();
  clear_has_value();
}
inline const ::DtValue& DtFetchResp::value() const {
  // @@protoc_insertion_point(field_get:DtFetchResp.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::DtValue* DtFetchResp::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::DtValue;
  // @@protoc_insertion_point(field_mutable:DtFetchResp.value)
  return value_;
}
inline ::DtValue* DtFetchResp::release_value() {
  clear_has_value();
  ::DtValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void DtFetchResp::set_allocated_value(::DtValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchResp.value)
}

// -------------------------------------------------------------------

// CounterOp

// optional sint64 increment = 1;
inline bool CounterOp::has_increment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CounterOp::set_has_increment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CounterOp::clear_has_increment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CounterOp::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
inline ::google::protobuf::int64 CounterOp::increment() const {
  // @@protoc_insertion_point(field_get:CounterOp.increment)
  return increment_;
}
inline void CounterOp::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:CounterOp.increment)
}

// -------------------------------------------------------------------

// SetOp

// repeated bytes adds = 1;
inline int SetOp::adds_size() const {
  return adds_.size();
}
inline void SetOp::clear_adds() {
  adds_.Clear();
}
inline const ::std::string& SetOp::adds(int index) const {
  // @@protoc_insertion_point(field_get:SetOp.adds)
  return adds_.Get(index);
}
inline ::std::string* SetOp::mutable_adds(int index) {
  // @@protoc_insertion_point(field_mutable:SetOp.adds)
  return adds_.Mutable(index);
}
inline void SetOp::set_adds(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SetOp.adds)
  adds_.Mutable(index)->assign(value);
}
inline void SetOp::set_adds(int index, const char* value) {
  adds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOp.adds)
}
inline void SetOp::set_adds(int index, const void* value, size_t size) {
  adds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOp.adds)
}
inline ::std::string* SetOp::add_adds() {
  return adds_.Add();
}
inline void SetOp::add_adds(const ::std::string& value) {
  adds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SetOp.adds)
}
inline void SetOp::add_adds(const char* value) {
  adds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SetOp.adds)
}
inline void SetOp::add_adds(const void* value, size_t size) {
  adds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SetOp.adds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetOp::adds() const {
  // @@protoc_insertion_point(field_list:SetOp.adds)
  return adds_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SetOp::mutable_adds() {
  // @@protoc_insertion_point(field_mutable_list:SetOp.adds)
  return &adds_;
}

// repeated bytes removes = 2;
inline int SetOp::removes_size() const {
  return removes_.size();
}
inline void SetOp::clear_removes() {
  removes_.Clear();
}
inline const ::std::string& SetOp::removes(int index) const {
  // @@protoc_insertion_point(field_get:SetOp.removes)
  return removes_.Get(index);
}
inline ::std::string* SetOp::mutable_removes(int index) {
  // @@protoc_insertion_point(field_mutable:SetOp.removes)
  return removes_.Mutable(index);
}
inline void SetOp::set_removes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SetOp.removes)
  removes_.Mutable(index)->assign(value);
}
inline void SetOp::set_removes(int index, const char* value) {
  removes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOp.removes)
}
inline void SetOp::set_removes(int index, const void* value, size_t size) {
  removes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOp.removes)
}
inline ::std::string* SetOp::add_removes() {
  return removes_.Add();
}
inline void SetOp::add_removes(const ::std::string& value) {
  removes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SetOp.removes)
}
inline void SetOp::add_removes(const char* value) {
  removes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SetOp.removes)
}
inline void SetOp::add_removes(const void* value, size_t size) {
  removes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SetOp.removes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetOp::removes() const {
  // @@protoc_insertion_point(field_list:SetOp.removes)
  return removes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SetOp::mutable_removes() {
  // @@protoc_insertion_point(field_mutable_list:SetOp.removes)
  return &removes_;
}

// -------------------------------------------------------------------

// MapUpdate

// required .MapField field = 1;
inline bool MapUpdate::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapUpdate::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapUpdate::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapUpdate::clear_field() {
  if (field_ != NULL) field_->::MapField::Clear();
  clear_has_field();
}
inline const ::MapField& MapUpdate::field() const {
  // @@protoc_insertion_point(field_get:MapUpdate.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::MapField* MapUpdate::mutable_field() {
  set_has_field();
  if (field_ == NULL) field_ = new ::MapField;
  // @@protoc_insertion_point(field_mutable:MapUpdate.field)
  return field_;
}
inline ::MapField* MapUpdate::release_field() {
  clear_has_field();
  ::MapField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_field(::MapField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.field)
}

// optional .CounterOp counter_op = 2;
inline bool MapUpdate::has_counter_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapUpdate::set_has_counter_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapUpdate::clear_has_counter_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapUpdate::clear_counter_op() {
  if (counter_op_ != NULL) counter_op_->::CounterOp::Clear();
  clear_has_counter_op();
}
inline const ::CounterOp& MapUpdate::counter_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.counter_op)
  return counter_op_ != NULL ? *counter_op_ : *default_instance_->counter_op_;
}
inline ::CounterOp* MapUpdate::mutable_counter_op() {
  set_has_counter_op();
  if (counter_op_ == NULL) counter_op_ = new ::CounterOp;
  // @@protoc_insertion_point(field_mutable:MapUpdate.counter_op)
  return counter_op_;
}
inline ::CounterOp* MapUpdate::release_counter_op() {
  clear_has_counter_op();
  ::CounterOp* temp = counter_op_;
  counter_op_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_counter_op(::CounterOp* counter_op) {
  delete counter_op_;
  counter_op_ = counter_op;
  if (counter_op) {
    set_has_counter_op();
  } else {
    clear_has_counter_op();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.counter_op)
}

// optional .SetOp set_op = 3;
inline bool MapUpdate::has_set_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapUpdate::set_has_set_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapUpdate::clear_has_set_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapUpdate::clear_set_op() {
  if (set_op_ != NULL) set_op_->::SetOp::Clear();
  clear_has_set_op();
}
inline const ::SetOp& MapUpdate::set_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.set_op)
  return set_op_ != NULL ? *set_op_ : *default_instance_->set_op_;
}
inline ::SetOp* MapUpdate::mutable_set_op() {
  set_has_set_op();
  if (set_op_ == NULL) set_op_ = new ::SetOp;
  // @@protoc_insertion_point(field_mutable:MapUpdate.set_op)
  return set_op_;
}
inline ::SetOp* MapUpdate::release_set_op() {
  clear_has_set_op();
  ::SetOp* temp = set_op_;
  set_op_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_set_op(::SetOp* set_op) {
  delete set_op_;
  set_op_ = set_op;
  if (set_op) {
    set_has_set_op();
  } else {
    clear_has_set_op();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.set_op)
}

// optional bytes register_op = 4;
inline bool MapUpdate::has_register_op() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapUpdate::set_has_register_op() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapUpdate::clear_has_register_op() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapUpdate::clear_register_op() {
  if (register_op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_->clear();
  }
  clear_has_register_op();
}
inline const ::std::string& MapUpdate::register_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.register_op)
  return *register_op_;
}
inline void MapUpdate::set_register_op(const ::std::string& value) {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  register_op_->assign(value);
  // @@protoc_insertion_point(field_set:MapUpdate.register_op)
}
inline void MapUpdate::set_register_op(const char* value) {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  register_op_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapUpdate.register_op)
}
inline void MapUpdate::set_register_op(const void* value, size_t size) {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  register_op_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapUpdate.register_op)
}
inline ::std::string* MapUpdate::mutable_register_op() {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapUpdate.register_op)
  return register_op_;
}
inline ::std::string* MapUpdate::release_register_op() {
  clear_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_op_;
    register_op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapUpdate::set_allocated_register_op(::std::string* register_op) {
  if (register_op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_op_;
  }
  if (register_op) {
    set_has_register_op();
    register_op_ = register_op;
  } else {
    clear_has_register_op();
    register_op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.register_op)
}

// optional .MapUpdate.FlagOp flag_op = 5;
inline bool MapUpdate::has_flag_op() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapUpdate::set_has_flag_op() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapUpdate::clear_has_flag_op() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapUpdate::clear_flag_op() {
  flag_op_ = 1;
  clear_has_flag_op();
}
inline ::MapUpdate_FlagOp MapUpdate::flag_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.flag_op)
  return static_cast< ::MapUpdate_FlagOp >(flag_op_);
}
inline void MapUpdate::set_flag_op(::MapUpdate_FlagOp value) {
  assert(::MapUpdate_FlagOp_IsValid(value));
  set_has_flag_op();
  flag_op_ = value;
  // @@protoc_insertion_point(field_set:MapUpdate.flag_op)
}

// optional .MapOp map_op = 6;
inline bool MapUpdate::has_map_op() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapUpdate::set_has_map_op() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapUpdate::clear_has_map_op() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapUpdate::clear_map_op() {
  if (map_op_ != NULL) map_op_->::MapOp::Clear();
  clear_has_map_op();
}
inline const ::MapOp& MapUpdate::map_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.map_op)
  return map_op_ != NULL ? *map_op_ : *default_instance_->map_op_;
}
inline ::MapOp* MapUpdate::mutable_map_op() {
  set_has_map_op();
  if (map_op_ == NULL) map_op_ = new ::MapOp;
  // @@protoc_insertion_point(field_mutable:MapUpdate.map_op)
  return map_op_;
}
inline ::MapOp* MapUpdate::release_map_op() {
  clear_has_map_op();
  ::MapOp* temp = map_op_;
  map_op_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_map_op(::MapOp* map_op) {
  delete map_op_;
  map_op_ = map_op;
  if (map_op) {
    set_has_map_op();
  } else {
    clear_has_map_op();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.map_op)
}

// -------------------------------------------------------------------

// MapOp

// repeated .MapField removes = 1;
inline int MapOp::removes_size() const {
  return removes_.size();
}
inline void MapOp::clear_removes() {
  removes_.Clear();
}
inline const ::MapField& MapOp::removes(int index) const {
  // @@protoc_insertion_point(field_get:MapOp.removes)
  return removes_.Get(index);
}
inline ::MapField* MapOp::mutable_removes(int index) {
  // @@protoc_insertion_point(field_mutable:MapOp.removes)
  return removes_.Mutable(index);
}
inline ::MapField* MapOp::add_removes() {
  // @@protoc_insertion_point(field_add:MapOp.removes)
  return removes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapField >&
MapOp::removes() const {
  // @@protoc_insertion_point(field_list:MapOp.removes)
  return removes_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapField >*
MapOp::mutable_removes() {
  // @@protoc_insertion_point(field_mutable_list:MapOp.removes)
  return &removes_;
}

// repeated .MapUpdate updates = 2;
inline int MapOp::updates_size() const {
  return updates_.size();
}
inline void MapOp::clear_updates() {
  updates_.Clear();
}
inline const ::MapUpdate& MapOp::updates(int index) const {
  // @@protoc_insertion_point(field_get:MapOp.updates)
  return updates_.Get(index);
}
inline ::MapUpdate* MapOp::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:MapOp.updates)
  return updates_.Mutable(index);
}
inline ::MapUpdate* MapOp::add_updates() {
  // @@protoc_insertion_point(field_add:MapOp.updates)
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapUpdate >&
MapOp::updates() const {
  // @@protoc_insertion_point(field_list:MapOp.updates)
  return updates_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapUpdate >*
MapOp::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:MapOp.updates)
  return &updates_;
}

// -------------------------------------------------------------------

// DtOp

// optional .CounterOp counter_op = 1;
inline bool DtOp::has_counter_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtOp::set_has_counter_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtOp::clear_has_counter_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtOp::clear_counter_op() {
  if (counter_op_ != NULL) counter_op_->::CounterOp::Clear();
  clear_has_counter_op();
}
inline const ::CounterOp& DtOp::counter_op() const {
  // @@protoc_insertion_point(field_get:DtOp.counter_op)
  return counter_op_ != NULL ? *counter_op_ : *default_instance_->counter_op_;
}
inline ::CounterOp* DtOp::mutable_counter_op() {
  set_has_counter_op();
  if (counter_op_ == NULL) counter_op_ = new ::CounterOp;
  // @@protoc_insertion_point(field_mutable:DtOp.counter_op)
  return counter_op_;
}
inline ::CounterOp* DtOp::release_counter_op() {
  clear_has_counter_op();
  ::CounterOp* temp = counter_op_;
  counter_op_ = NULL;
  return temp;
}
inline void DtOp::set_allocated_counter_op(::CounterOp* counter_op) {
  delete counter_op_;
  counter_op_ = counter_op;
  if (counter_op) {
    set_has_counter_op();
  } else {
    clear_has_counter_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtOp.counter_op)
}

// optional .SetOp set_op = 2;
inline bool DtOp::has_set_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtOp::set_has_set_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtOp::clear_has_set_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtOp::clear_set_op() {
  if (set_op_ != NULL) set_op_->::SetOp::Clear();
  clear_has_set_op();
}
inline const ::SetOp& DtOp::set_op() const {
  // @@protoc_insertion_point(field_get:DtOp.set_op)
  return set_op_ != NULL ? *set_op_ : *default_instance_->set_op_;
}
inline ::SetOp* DtOp::mutable_set_op() {
  set_has_set_op();
  if (set_op_ == NULL) set_op_ = new ::SetOp;
  // @@protoc_insertion_point(field_mutable:DtOp.set_op)
  return set_op_;
}
inline ::SetOp* DtOp::release_set_op() {
  clear_has_set_op();
  ::SetOp* temp = set_op_;
  set_op_ = NULL;
  return temp;
}
inline void DtOp::set_allocated_set_op(::SetOp* set_op) {
  delete set_op_;
  set_op_ = set_op;
  if (set_op) {
    set_has_set_op();
  } else {
    clear_has_set_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtOp.set_op)
}

// optional .MapOp map_op = 3;
inline bool DtOp::has_map_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtOp::set_has_map_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtOp::clear_has_map_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtOp::clear_map_op() {
  if (map_op_ != NULL) map_op_->::MapOp::Clear();
  clear_has_map_op();
}
inline const ::MapOp& DtOp::map_op() const {
  // @@protoc_insertion_point(field_get:DtOp.map_op)
  return map_op_ != NULL ? *map_op_ : *default_instance_->map_op_;
}
inline ::MapOp* DtOp::mutable_map_op() {
  set_has_map_op();
  if (map_op_ == NULL) map_op_ = new ::MapOp;
  // @@protoc_insertion_point(field_mutable:DtOp.map_op)
  return map_op_;
}
inline ::MapOp* DtOp::release_map_op() {
  clear_has_map_op();
  ::MapOp* temp = map_op_;
  map_op_ = NULL;
  return temp;
}
inline void DtOp::set_allocated_map_op(::MapOp* map_op) {
  delete map_op_;
  map_op_ = map_op;
  if (map_op) {
    set_has_map_op();
  } else {
    clear_has_map_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtOp.map_op)
}

// -------------------------------------------------------------------

// DtUpdateReq

// required bytes bucket = 1;
inline bool DtUpdateReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtUpdateReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtUpdateReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtUpdateReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& DtUpdateReq::bucket() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.bucket)
  return *bucket_;
}
inline void DtUpdateReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.bucket)
}
inline void DtUpdateReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.bucket)
}
inline void DtUpdateReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.bucket)
}
inline ::std::string* DtUpdateReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.bucket)
  return bucket_;
}
inline ::std::string* DtUpdateReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.bucket)
}

// optional bytes key = 2;
inline bool DtUpdateReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtUpdateReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtUpdateReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtUpdateReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DtUpdateReq::key() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.key)
  return *key_;
}
inline void DtUpdateReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.key)
}
inline void DtUpdateReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.key)
}
inline void DtUpdateReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.key)
}
inline ::std::string* DtUpdateReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.key)
  return key_;
}
inline ::std::string* DtUpdateReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.key)
}

// required bytes type = 3;
inline bool DtUpdateReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtUpdateReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtUpdateReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtUpdateReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& DtUpdateReq::type() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.type)
  return *type_;
}
inline void DtUpdateReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.type)
}
inline void DtUpdateReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.type)
}
inline void DtUpdateReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.type)
}
inline ::std::string* DtUpdateReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.type)
  return type_;
}
inline ::std::string* DtUpdateReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.type)
}

// optional bytes context = 4;
inline bool DtUpdateReq::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DtUpdateReq::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DtUpdateReq::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DtUpdateReq::clear_context() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DtUpdateReq::context() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.context)
  return *context_;
}
inline void DtUpdateReq::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.context)
}
inline void DtUpdateReq::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.context)
}
inline void DtUpdateReq::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.context)
}
inline ::std::string* DtUpdateReq::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.context)
  return context_;
}
inline ::std::string* DtUpdateReq::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.context)
}

// required .DtOp op = 5;
inline bool DtUpdateReq::has_op() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DtUpdateReq::set_has_op() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DtUpdateReq::clear_has_op() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DtUpdateReq::clear_op() {
  if (op_ != NULL) op_->::DtOp::Clear();
  clear_has_op();
}
inline const ::DtOp& DtUpdateReq::op() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.op)
  return op_ != NULL ? *op_ : *default_instance_->op_;
}
inline ::DtOp* DtUpdateReq::mutable_op() {
  set_has_op();
  if (op_ == NULL) op_ = new ::DtOp;
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.op)
  return op_;
}
inline ::DtOp* DtUpdateReq::release_op() {
  clear_has_op();
  ::DtOp* temp = op_;
  op_ = NULL;
  return temp;
}
inline void DtUpdateReq::set_allocated_op(::DtOp* op) {
  delete op_;
  op_ = op;
  if (op) {
    set_has_op();
  } else {
    clear_has_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.op)
}

// optional uint32 w = 6;
inline bool DtUpdateReq::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DtUpdateReq::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DtUpdateReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DtUpdateReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 DtUpdateReq::w() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.w)
  return w_;
}
inline void DtUpdateReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.w)
}

// optional uint32 dw = 7;
inline bool DtUpdateReq::has_dw() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DtUpdateReq::set_has_dw() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DtUpdateReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DtUpdateReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 DtUpdateReq::dw() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.dw)
  return dw_;
}
inline void DtUpdateReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.dw)
}

// optional uint32 pw = 8;
inline bool DtUpdateReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DtUpdateReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DtUpdateReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DtUpdateReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 DtUpdateReq::pw() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.pw)
  return pw_;
}
inline void DtUpdateReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.pw)
}

// optional bool return_body = 9 [default = false];
inline bool DtUpdateReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DtUpdateReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DtUpdateReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DtUpdateReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool DtUpdateReq::return_body() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.return_body)
  return return_body_;
}
inline void DtUpdateReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.return_body)
}

// optional uint32 timeout = 10;
inline bool DtUpdateReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DtUpdateReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DtUpdateReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DtUpdateReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 DtUpdateReq::timeout() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.timeout)
  return timeout_;
}
inline void DtUpdateReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.timeout)
}

// optional bool sloppy_quorum = 11;
inline bool DtUpdateReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DtUpdateReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DtUpdateReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DtUpdateReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool DtUpdateReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void DtUpdateReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.sloppy_quorum)
}

// optional uint32 n_val = 12;
inline bool DtUpdateReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DtUpdateReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DtUpdateReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DtUpdateReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 DtUpdateReq::n_val() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.n_val)
  return n_val_;
}
inline void DtUpdateReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.n_val)
}

// optional bool include_context = 13 [default = true];
inline bool DtUpdateReq::has_include_context() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DtUpdateReq::set_has_include_context() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DtUpdateReq::clear_has_include_context() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DtUpdateReq::clear_include_context() {
  include_context_ = true;
  clear_has_include_context();
}
inline bool DtUpdateReq::include_context() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.include_context)
  return include_context_;
}
inline void DtUpdateReq::set_include_context(bool value) {
  set_has_include_context();
  include_context_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.include_context)
}

// -------------------------------------------------------------------

// DtUpdateResp

// optional bytes key = 1;
inline bool DtUpdateResp::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtUpdateResp::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtUpdateResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtUpdateResp::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DtUpdateResp::key() const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.key)
  return *key_;
}
inline void DtUpdateResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateResp.key)
}
inline void DtUpdateResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateResp.key)
}
inline void DtUpdateResp::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateResp.key)
}
inline ::std::string* DtUpdateResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.key)
  return key_;
}
inline ::std::string* DtUpdateResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateResp::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateResp.key)
}

// optional bytes context = 2;
inline bool DtUpdateResp::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtUpdateResp::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtUpdateResp::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtUpdateResp::clear_context() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DtUpdateResp::context() const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.context)
  return *context_;
}
inline void DtUpdateResp::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateResp.context)
}
inline void DtUpdateResp::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateResp.context)
}
inline void DtUpdateResp::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateResp.context)
}
inline ::std::string* DtUpdateResp::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.context)
  return context_;
}
inline ::std::string* DtUpdateResp::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateResp::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateResp.context)
}

// optional sint64 counter_value = 3;
inline bool DtUpdateResp::has_counter_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtUpdateResp::set_has_counter_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtUpdateResp::clear_has_counter_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtUpdateResp::clear_counter_value() {
  counter_value_ = GOOGLE_LONGLONG(0);
  clear_has_counter_value();
}
inline ::google::protobuf::int64 DtUpdateResp::counter_value() const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.counter_value)
  return counter_value_;
}
inline void DtUpdateResp::set_counter_value(::google::protobuf::int64 value) {
  set_has_counter_value();
  counter_value_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateResp.counter_value)
}

// repeated bytes set_value = 4;
inline int DtUpdateResp::set_value_size() const {
  return set_value_.size();
}
inline void DtUpdateResp::clear_set_value() {
  set_value_.Clear();
}
inline const ::std::string& DtUpdateResp::set_value(int index) const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.set_value)
  return set_value_.Get(index);
}
inline ::std::string* DtUpdateResp::mutable_set_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.set_value)
  return set_value_.Mutable(index);
}
inline void DtUpdateResp::set_set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DtUpdateResp.set_value)
  set_value_.Mutable(index)->assign(value);
}
inline void DtUpdateResp::set_set_value(int index, const char* value) {
  set_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateResp.set_value)
}
inline void DtUpdateResp::set_set_value(int index, const void* value, size_t size) {
  set_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateResp.set_value)
}
inline ::std::string* DtUpdateResp::add_set_value() {
  return set_value_.Add();
}
inline void DtUpdateResp::add_set_value(const ::std::string& value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DtUpdateResp.set_value)
}
inline void DtUpdateResp::add_set_value(const char* value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DtUpdateResp.set_value)
}
inline void DtUpdateResp::add_set_value(const void* value, size_t size) {
  set_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DtUpdateResp.set_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DtUpdateResp::set_value() const {
  // @@protoc_insertion_point(field_list:DtUpdateResp.set_value)
  return set_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DtUpdateResp::mutable_set_value() {
  // @@protoc_insertion_point(field_mutable_list:DtUpdateResp.set_value)
  return &set_value_;
}

// repeated .MapEntry map_value = 5;
inline int DtUpdateResp::map_value_size() const {
  return map_value_.size();
}
inline void DtUpdateResp::clear_map_value() {
  map_value_.Clear();
}
inline const ::MapEntry& DtUpdateResp::map_value(int index) const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.map_value)
  return map_value_.Get(index);
}
inline ::MapEntry* DtUpdateResp::mutable_map_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.map_value)
  return map_value_.Mutable(index);
}
inline ::MapEntry* DtUpdateResp::add_map_value() {
  // @@protoc_insertion_point(field_add:DtUpdateResp.map_value)
  return map_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
DtUpdateResp::map_value() const {
  // @@protoc_insertion_point(field_list:DtUpdateResp.map_value)
  return map_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
DtUpdateResp::mutable_map_value() {
  // @@protoc_insertion_point(field_mutable_list:DtUpdateResp.map_value)
  return &map_value_;
}

// -------------------------------------------------------------------

// RpbGetClientIdResp

// required bytes client_id = 1;
inline bool RpbGetClientIdResp::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetClientIdResp::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetClientIdResp::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetClientIdResp::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbGetClientIdResp::client_id() const {
  // @@protoc_insertion_point(field_get:RpbGetClientIdResp.client_id)
  return *client_id_;
}
inline void RpbGetClientIdResp::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetClientIdResp.client_id)
}
inline void RpbGetClientIdResp::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetClientIdResp.client_id)
}
inline void RpbGetClientIdResp::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetClientIdResp.client_id)
}
inline ::std::string* RpbGetClientIdResp::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetClientIdResp.client_id)
  return client_id_;
}
inline ::std::string* RpbGetClientIdResp::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetClientIdResp::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetClientIdResp.client_id)
}

// -------------------------------------------------------------------

// RpbSetClientIdReq

// required bytes client_id = 1;
inline bool RpbSetClientIdReq::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetClientIdReq::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetClientIdReq::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetClientIdReq::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbSetClientIdReq::client_id() const {
  // @@protoc_insertion_point(field_get:RpbSetClientIdReq.client_id)
  return *client_id_;
}
inline void RpbSetClientIdReq::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSetClientIdReq.client_id)
}
inline void RpbSetClientIdReq::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSetClientIdReq.client_id)
}
inline void RpbSetClientIdReq::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSetClientIdReq.client_id)
}
inline ::std::string* RpbSetClientIdReq::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSetClientIdReq.client_id)
  return client_id_;
}
inline ::std::string* RpbSetClientIdReq::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSetClientIdReq::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetClientIdReq.client_id)
}

// -------------------------------------------------------------------

// RpbGetReq

// required bytes bucket = 1;
inline bool RpbGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.bucket)
  return *bucket_;
}
inline void RpbGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.bucket)
}
inline void RpbGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.bucket)
}
inline void RpbGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.bucket)
}
inline ::std::string* RpbGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.bucket)
  return bucket_;
}
inline ::std::string* RpbGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.bucket)
}

// required bytes key = 2;
inline bool RpbGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetReq::key() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.key)
  return *key_;
}
inline void RpbGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.key)
}
inline void RpbGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.key)
}
inline void RpbGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.key)
}
inline ::std::string* RpbGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.key)
  return key_;
}
inline ::std::string* RpbGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.key)
}

// optional uint32 r = 3;
inline bool RpbGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbGetReq::r() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.r)
  return r_;
}
inline void RpbGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.r)
}

// optional uint32 pr = 4;
inline bool RpbGetReq::has_pr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbGetReq::set_has_pr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbGetReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbGetReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbGetReq::pr() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.pr)
  return pr_;
}
inline void RpbGetReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.pr)
}

// optional bool basic_quorum = 5;
inline bool RpbGetReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbGetReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbGetReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbGetReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbGetReq::basic_quorum() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.basic_quorum)
  return basic_quorum_;
}
inline void RpbGetReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.basic_quorum)
}

// optional bool notfound_ok = 6;
inline bool RpbGetReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbGetReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbGetReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbGetReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbGetReq::notfound_ok() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.notfound_ok)
  return notfound_ok_;
}
inline void RpbGetReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.notfound_ok)
}

// optional bytes if_modified = 7;
inline bool RpbGetReq::has_if_modified() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbGetReq::set_has_if_modified() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbGetReq::clear_has_if_modified() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbGetReq::clear_if_modified() {
  if (if_modified_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_->clear();
  }
  clear_has_if_modified();
}
inline const ::std::string& RpbGetReq::if_modified() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.if_modified)
  return *if_modified_;
}
inline void RpbGetReq::set_if_modified(const ::std::string& value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.if_modified)
}
inline void RpbGetReq::set_if_modified(const char* value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.if_modified)
}
inline void RpbGetReq::set_if_modified(const void* value, size_t size) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.if_modified)
}
inline ::std::string* RpbGetReq::mutable_if_modified() {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.if_modified)
  return if_modified_;
}
inline ::std::string* RpbGetReq::release_if_modified() {
  clear_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = if_modified_;
    if_modified_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_if_modified(::std::string* if_modified) {
  if (if_modified_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete if_modified_;
  }
  if (if_modified) {
    set_has_if_modified();
    if_modified_ = if_modified;
  } else {
    clear_has_if_modified();
    if_modified_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.if_modified)
}

// optional bool head = 8;
inline bool RpbGetReq::has_head() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbGetReq::set_has_head() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbGetReq::clear_has_head() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbGetReq::clear_head() {
  head_ = false;
  clear_has_head();
}
inline bool RpbGetReq::head() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.head)
  return head_;
}
inline void RpbGetReq::set_head(bool value) {
  set_has_head();
  head_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.head)
}

// optional bool deletedvclock = 9;
inline bool RpbGetReq::has_deletedvclock() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbGetReq::set_has_deletedvclock() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbGetReq::clear_has_deletedvclock() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbGetReq::clear_deletedvclock() {
  deletedvclock_ = false;
  clear_has_deletedvclock();
}
inline bool RpbGetReq::deletedvclock() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.deletedvclock)
  return deletedvclock_;
}
inline void RpbGetReq::set_deletedvclock(bool value) {
  set_has_deletedvclock();
  deletedvclock_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.deletedvclock)
}

// optional uint32 timeout = 10;
inline bool RpbGetReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbGetReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbGetReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbGetReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbGetReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.timeout)
  return timeout_;
}
inline void RpbGetReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.timeout)
}

// optional bool sloppy_quorum = 11;
inline bool RpbGetReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbGetReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbGetReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbGetReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool RpbGetReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void RpbGetReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.sloppy_quorum)
}

// optional uint32 n_val = 12;
inline bool RpbGetReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbGetReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbGetReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbGetReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbGetReq::n_val() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.n_val)
  return n_val_;
}
inline void RpbGetReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.n_val)
}

// optional bytes type = 13;
inline bool RpbGetReq::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbGetReq::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbGetReq::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbGetReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbGetReq::type() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.type)
  return *type_;
}
inline void RpbGetReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.type)
}
inline void RpbGetReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.type)
}
inline void RpbGetReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.type)
}
inline ::std::string* RpbGetReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.type)
  return type_;
}
inline ::std::string* RpbGetReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.type)
}

// -------------------------------------------------------------------

// RpbGetResp

// repeated .RpbContent content = 1;
inline int RpbGetResp::content_size() const {
  return content_.size();
}
inline void RpbGetResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbGetResp::content(int index) const {
  // @@protoc_insertion_point(field_get:RpbGetResp.content)
  return content_.Get(index);
}
inline ::RpbContent* RpbGetResp::mutable_content(int index) {
  // @@protoc_insertion_point(field_mutable:RpbGetResp.content)
  return content_.Mutable(index);
}
inline ::RpbContent* RpbGetResp::add_content() {
  // @@protoc_insertion_point(field_add:RpbGetResp.content)
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbGetResp::content() const {
  // @@protoc_insertion_point(field_list:RpbGetResp.content)
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbGetResp::mutable_content() {
  // @@protoc_insertion_point(field_mutable_list:RpbGetResp.content)
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbGetResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbGetResp::vclock() const {
  // @@protoc_insertion_point(field_get:RpbGetResp.vclock)
  return *vclock_;
}
inline void RpbGetResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetResp.vclock)
}
inline void RpbGetResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetResp.vclock)
}
inline void RpbGetResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetResp.vclock)
}
inline ::std::string* RpbGetResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetResp.vclock)
  return vclock_;
}
inline ::std::string* RpbGetResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetResp::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetResp.vclock)
}

// optional bool unchanged = 3;
inline bool RpbGetResp::has_unchanged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetResp::set_has_unchanged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetResp::clear_has_unchanged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetResp::clear_unchanged() {
  unchanged_ = false;
  clear_has_unchanged();
}
inline bool RpbGetResp::unchanged() const {
  // @@protoc_insertion_point(field_get:RpbGetResp.unchanged)
  return unchanged_;
}
inline void RpbGetResp::set_unchanged(bool value) {
  set_has_unchanged();
  unchanged_ = value;
  // @@protoc_insertion_point(field_set:RpbGetResp.unchanged)
}

// -------------------------------------------------------------------

// RpbPutReq

// required bytes bucket = 1;
inline bool RpbPutReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPutReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPutReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPutReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbPutReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.bucket)
  return *bucket_;
}
inline void RpbPutReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.bucket)
}
inline void RpbPutReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.bucket)
}
inline void RpbPutReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.bucket)
}
inline ::std::string* RpbPutReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.bucket)
  return bucket_;
}
inline ::std::string* RpbPutReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.bucket)
}

// optional bytes key = 2;
inline bool RpbPutReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutReq::key() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.key)
  return *key_;
}
inline void RpbPutReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.key)
}
inline void RpbPutReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.key)
}
inline void RpbPutReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.key)
}
inline ::std::string* RpbPutReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.key)
  return key_;
}
inline ::std::string* RpbPutReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.key)
}

// optional bytes vclock = 3;
inline bool RpbPutReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutReq::vclock() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.vclock)
  return *vclock_;
}
inline void RpbPutReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.vclock)
}
inline void RpbPutReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.vclock)
}
inline void RpbPutReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.vclock)
}
inline ::std::string* RpbPutReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.vclock)
  return vclock_;
}
inline ::std::string* RpbPutReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.vclock)
}

// required .RpbContent content = 4;
inline bool RpbPutReq::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbPutReq::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbPutReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbPutReq::clear_content() {
  if (content_ != NULL) content_->::RpbContent::Clear();
  clear_has_content();
}
inline const ::RpbContent& RpbPutReq::content() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.content)
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::RpbContent* RpbPutReq::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::RpbContent;
  // @@protoc_insertion_point(field_mutable:RpbPutReq.content)
  return content_;
}
inline ::RpbContent* RpbPutReq::release_content() {
  clear_has_content();
  ::RpbContent* temp = content_;
  content_ = NULL;
  return temp;
}
inline void RpbPutReq::set_allocated_content(::RpbContent* content) {
  delete content_;
  content_ = content;
  if (content) {
    set_has_content();
  } else {
    clear_has_content();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.content)
}

// optional uint32 w = 5;
inline bool RpbPutReq::has_w() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbPutReq::set_has_w() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbPutReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbPutReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbPutReq::w() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.w)
  return w_;
}
inline void RpbPutReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.w)
}

// optional uint32 dw = 6;
inline bool RpbPutReq::has_dw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbPutReq::set_has_dw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbPutReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbPutReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbPutReq::dw() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.dw)
  return dw_;
}
inline void RpbPutReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.dw)
}

// optional bool return_body = 7;
inline bool RpbPutReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbPutReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbPutReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbPutReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbPutReq::return_body() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.return_body)
  return return_body_;
}
inline void RpbPutReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.return_body)
}

// optional uint32 pw = 8;
inline bool RpbPutReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbPutReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbPutReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbPutReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbPutReq::pw() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.pw)
  return pw_;
}
inline void RpbPutReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.pw)
}

// optional bool if_not_modified = 9;
inline bool RpbPutReq::has_if_not_modified() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbPutReq::set_has_if_not_modified() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbPutReq::clear_has_if_not_modified() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbPutReq::clear_if_not_modified() {
  if_not_modified_ = false;
  clear_has_if_not_modified();
}
inline bool RpbPutReq::if_not_modified() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.if_not_modified)
  return if_not_modified_;
}
inline void RpbPutReq::set_if_not_modified(bool value) {
  set_has_if_not_modified();
  if_not_modified_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.if_not_modified)
}

// optional bool if_none_match = 10;
inline bool RpbPutReq::has_if_none_match() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbPutReq::set_has_if_none_match() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbPutReq::clear_has_if_none_match() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbPutReq::clear_if_none_match() {
  if_none_match_ = false;
  clear_has_if_none_match();
}
inline bool RpbPutReq::if_none_match() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.if_none_match)
  return if_none_match_;
}
inline void RpbPutReq::set_if_none_match(bool value) {
  set_has_if_none_match();
  if_none_match_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.if_none_match)
}

// optional bool return_head = 11;
inline bool RpbPutReq::has_return_head() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbPutReq::set_has_return_head() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbPutReq::clear_has_return_head() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbPutReq::clear_return_head() {
  return_head_ = false;
  clear_has_return_head();
}
inline bool RpbPutReq::return_head() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.return_head)
  return return_head_;
}
inline void RpbPutReq::set_return_head(bool value) {
  set_has_return_head();
  return_head_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.return_head)
}

// optional uint32 timeout = 12;
inline bool RpbPutReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbPutReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbPutReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbPutReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbPutReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.timeout)
  return timeout_;
}
inline void RpbPutReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.timeout)
}

// optional bool asis = 13;
inline bool RpbPutReq::has_asis() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbPutReq::set_has_asis() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbPutReq::clear_has_asis() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbPutReq::clear_asis() {
  asis_ = false;
  clear_has_asis();
}
inline bool RpbPutReq::asis() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.asis)
  return asis_;
}
inline void RpbPutReq::set_asis(bool value) {
  set_has_asis();
  asis_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.asis)
}

// optional bool sloppy_quorum = 14;
inline bool RpbPutReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RpbPutReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RpbPutReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RpbPutReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool RpbPutReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void RpbPutReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.sloppy_quorum)
}

// optional uint32 n_val = 15;
inline bool RpbPutReq::has_n_val() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RpbPutReq::set_has_n_val() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RpbPutReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RpbPutReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbPutReq::n_val() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.n_val)
  return n_val_;
}
inline void RpbPutReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.n_val)
}

// optional bytes type = 16;
inline bool RpbPutReq::has_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RpbPutReq::set_has_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RpbPutReq::clear_has_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RpbPutReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbPutReq::type() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.type)
  return *type_;
}
inline void RpbPutReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.type)
}
inline void RpbPutReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.type)
}
inline void RpbPutReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.type)
}
inline ::std::string* RpbPutReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.type)
  return type_;
}
inline ::std::string* RpbPutReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.type)
}

// -------------------------------------------------------------------

// RpbPutResp

// repeated .RpbContent content = 1;
inline int RpbPutResp::content_size() const {
  return content_.size();
}
inline void RpbPutResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbPutResp::content(int index) const {
  // @@protoc_insertion_point(field_get:RpbPutResp.content)
  return content_.Get(index);
}
inline ::RpbContent* RpbPutResp::mutable_content(int index) {
  // @@protoc_insertion_point(field_mutable:RpbPutResp.content)
  return content_.Mutable(index);
}
inline ::RpbContent* RpbPutResp::add_content() {
  // @@protoc_insertion_point(field_add:RpbPutResp.content)
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbPutResp::content() const {
  // @@protoc_insertion_point(field_list:RpbPutResp.content)
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbPutResp::mutable_content() {
  // @@protoc_insertion_point(field_mutable_list:RpbPutResp.content)
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbPutResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutResp::vclock() const {
  // @@protoc_insertion_point(field_get:RpbPutResp.vclock)
  return *vclock_;
}
inline void RpbPutResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutResp.vclock)
}
inline void RpbPutResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutResp.vclock)
}
inline void RpbPutResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutResp.vclock)
}
inline ::std::string* RpbPutResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutResp.vclock)
  return vclock_;
}
inline ::std::string* RpbPutResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutResp::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutResp.vclock)
}

// optional bytes key = 3;
inline bool RpbPutResp::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutResp::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutResp::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutResp::key() const {
  // @@protoc_insertion_point(field_get:RpbPutResp.key)
  return *key_;
}
inline void RpbPutResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutResp.key)
}
inline void RpbPutResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutResp.key)
}
inline void RpbPutResp::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutResp.key)
}
inline ::std::string* RpbPutResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutResp.key)
  return key_;
}
inline ::std::string* RpbPutResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutResp::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutResp.key)
}

// -------------------------------------------------------------------

// RpbDelReq

// required bytes bucket = 1;
inline bool RpbDelReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbDelReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbDelReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbDelReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbDelReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.bucket)
  return *bucket_;
}
inline void RpbDelReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.bucket)
}
inline void RpbDelReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.bucket)
}
inline void RpbDelReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.bucket)
}
inline ::std::string* RpbDelReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.bucket)
  return bucket_;
}
inline ::std::string* RpbDelReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.bucket)
}

// required bytes key = 2;
inline bool RpbDelReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbDelReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbDelReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbDelReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbDelReq::key() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.key)
  return *key_;
}
inline void RpbDelReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.key)
}
inline void RpbDelReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.key)
}
inline void RpbDelReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.key)
}
inline ::std::string* RpbDelReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.key)
  return key_;
}
inline ::std::string* RpbDelReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.key)
}

// optional uint32 rw = 3;
inline bool RpbDelReq::has_rw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbDelReq::set_has_rw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbDelReq::clear_has_rw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbDelReq::clear_rw() {
  rw_ = 0u;
  clear_has_rw();
}
inline ::google::protobuf::uint32 RpbDelReq::rw() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.rw)
  return rw_;
}
inline void RpbDelReq::set_rw(::google::protobuf::uint32 value) {
  set_has_rw();
  rw_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.rw)
}

// optional bytes vclock = 4;
inline bool RpbDelReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbDelReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbDelReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbDelReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbDelReq::vclock() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.vclock)
  return *vclock_;
}
inline void RpbDelReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.vclock)
}
inline void RpbDelReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.vclock)
}
inline void RpbDelReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.vclock)
}
inline ::std::string* RpbDelReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.vclock)
  return vclock_;
}
inline ::std::string* RpbDelReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.vclock)
}

// optional uint32 r = 5;
inline bool RpbDelReq::has_r() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbDelReq::set_has_r() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbDelReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbDelReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbDelReq::r() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.r)
  return r_;
}
inline void RpbDelReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.r)
}

// optional uint32 w = 6;
inline bool RpbDelReq::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbDelReq::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbDelReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbDelReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbDelReq::w() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.w)
  return w_;
}
inline void RpbDelReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.w)
}

// optional uint32 pr = 7;
inline bool RpbDelReq::has_pr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbDelReq::set_has_pr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbDelReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbDelReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbDelReq::pr() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.pr)
  return pr_;
}
inline void RpbDelReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.pr)
}

// optional uint32 pw = 8;
inline bool RpbDelReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbDelReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbDelReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbDelReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbDelReq::pw() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.pw)
  return pw_;
}
inline void RpbDelReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.pw)
}

// optional uint32 dw = 9;
inline bool RpbDelReq::has_dw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbDelReq::set_has_dw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbDelReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbDelReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbDelReq::dw() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.dw)
  return dw_;
}
inline void RpbDelReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.dw)
}

// optional uint32 timeout = 10;
inline bool RpbDelReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbDelReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbDelReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbDelReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbDelReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.timeout)
  return timeout_;
}
inline void RpbDelReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.timeout)
}

// optional bool sloppy_quorum = 11;
inline bool RpbDelReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbDelReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbDelReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbDelReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool RpbDelReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void RpbDelReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.sloppy_quorum)
}

// optional uint32 n_val = 12;
inline bool RpbDelReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbDelReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbDelReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbDelReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbDelReq::n_val() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.n_val)
  return n_val_;
}
inline void RpbDelReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.n_val)
}

// optional bytes type = 13;
inline bool RpbDelReq::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbDelReq::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbDelReq::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbDelReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbDelReq::type() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.type)
  return *type_;
}
inline void RpbDelReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.type)
}
inline void RpbDelReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.type)
}
inline void RpbDelReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.type)
}
inline ::std::string* RpbDelReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.type)
  return type_;
}
inline ::std::string* RpbDelReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.type)
}

// -------------------------------------------------------------------

// RpbListBucketsReq

// optional uint32 timeout = 1;
inline bool RpbListBucketsReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListBucketsReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListBucketsReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListBucketsReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbListBucketsReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsReq.timeout)
  return timeout_;
}
inline void RpbListBucketsReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbListBucketsReq.timeout)
}

// optional bool stream = 2;
inline bool RpbListBucketsReq::has_stream() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListBucketsReq::set_has_stream() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListBucketsReq::clear_has_stream() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListBucketsReq::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool RpbListBucketsReq::stream() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsReq.stream)
  return stream_;
}
inline void RpbListBucketsReq::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:RpbListBucketsReq.stream)
}

// optional bytes type = 3;
inline bool RpbListBucketsReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbListBucketsReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbListBucketsReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbListBucketsReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbListBucketsReq::type() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsReq.type)
  return *type_;
}
inline void RpbListBucketsReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbListBucketsReq.type)
}
inline void RpbListBucketsReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListBucketsReq.type)
}
inline void RpbListBucketsReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListBucketsReq.type)
}
inline ::std::string* RpbListBucketsReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbListBucketsReq.type)
  return type_;
}
inline ::std::string* RpbListBucketsReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbListBucketsReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbListBucketsReq.type)
}

// -------------------------------------------------------------------

// RpbListBucketsResp

// repeated bytes buckets = 1;
inline int RpbListBucketsResp::buckets_size() const {
  return buckets_.size();
}
inline void RpbListBucketsResp::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& RpbListBucketsResp::buckets(int index) const {
  // @@protoc_insertion_point(field_get:RpbListBucketsResp.buckets)
  return buckets_.Get(index);
}
inline ::std::string* RpbListBucketsResp::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:RpbListBucketsResp.buckets)
  return buckets_.Mutable(index);
}
inline void RpbListBucketsResp::set_buckets(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbListBucketsResp.buckets)
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListBucketsResp.buckets)
}
inline void RpbListBucketsResp::set_buckets(int index, const void* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListBucketsResp.buckets)
}
inline ::std::string* RpbListBucketsResp::add_buckets() {
  return buckets_.Add();
}
inline void RpbListBucketsResp::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbListBucketsResp.buckets)
}
inline void RpbListBucketsResp::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbListBucketsResp.buckets)
}
inline void RpbListBucketsResp::add_buckets(const void* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbListBucketsResp.buckets)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListBucketsResp::buckets() const {
  // @@protoc_insertion_point(field_list:RpbListBucketsResp.buckets)
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListBucketsResp::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:RpbListBucketsResp.buckets)
  return &buckets_;
}

// optional bool done = 2;
inline bool RpbListBucketsResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListBucketsResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListBucketsResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListBucketsResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListBucketsResp::done() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsResp.done)
  return done_;
}
inline void RpbListBucketsResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbListBucketsResp.done)
}

// -------------------------------------------------------------------

// RpbListKeysReq

// required bytes bucket = 1;
inline bool RpbListKeysReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListKeysReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListKeysReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListKeysReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbListKeysReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbListKeysReq.bucket)
  return *bucket_;
}
inline void RpbListKeysReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbListKeysReq.bucket)
}
inline void RpbListKeysReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListKeysReq.bucket)
}
inline void RpbListKeysReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListKeysReq.bucket)
}
inline ::std::string* RpbListKeysReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbListKeysReq.bucket)
  return bucket_;
}
inline ::std::string* RpbListKeysReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbListKeysReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbListKeysReq.bucket)
}

// optional uint32 timeout = 2;
inline bool RpbListKeysReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbListKeysReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbListKeysReq.timeout)
  return timeout_;
}
inline void RpbListKeysReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbListKeysReq.timeout)
}

// optional bytes type = 3;
inline bool RpbListKeysReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbListKeysReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbListKeysReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbListKeysReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbListKeysReq::type() const {
  // @@protoc_insertion_point(field_get:RpbListKeysReq.type)
  return *type_;
}
inline void RpbListKeysReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbListKeysReq.type)
}
inline void RpbListKeysReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListKeysReq.type)
}
inline void RpbListKeysReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListKeysReq.type)
}
inline ::std::string* RpbListKeysReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbListKeysReq.type)
  return type_;
}
inline ::std::string* RpbListKeysReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbListKeysReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbListKeysReq.type)
}

// -------------------------------------------------------------------

// RpbListKeysResp

// repeated bytes keys = 1;
inline int RpbListKeysResp::keys_size() const {
  return keys_.size();
}
inline void RpbListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbListKeysResp::keys(int index) const {
  // @@protoc_insertion_point(field_get:RpbListKeysResp.keys)
  return keys_.Get(index);
}
inline ::std::string* RpbListKeysResp::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:RpbListKeysResp.keys)
  return keys_.Mutable(index);
}
inline void RpbListKeysResp::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbListKeysResp.keys)
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListKeysResp.keys)
}
inline void RpbListKeysResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListKeysResp.keys)
}
inline ::std::string* RpbListKeysResp::add_keys() {
  return keys_.Add();
}
inline void RpbListKeysResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbListKeysResp.keys)
}
inline void RpbListKeysResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbListKeysResp.keys)
}
inline void RpbListKeysResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbListKeysResp.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListKeysResp::keys() const {
  // @@protoc_insertion_point(field_list:RpbListKeysResp.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListKeysResp::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:RpbListKeysResp.keys)
  return &keys_;
}

// optional bool done = 2;
inline bool RpbListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListKeysResp::done() const {
  // @@protoc_insertion_point(field_get:RpbListKeysResp.done)
  return done_;
}
inline void RpbListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbListKeysResp.done)
}

// -------------------------------------------------------------------

// RpbMapRedReq

// required bytes request = 1;
inline bool RpbMapRedReq::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedReq::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedReq::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedReq::clear_request() {
  if (request_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& RpbMapRedReq::request() const {
  // @@protoc_insertion_point(field_get:RpbMapRedReq.request)
  return *request_;
}
inline void RpbMapRedReq::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(value);
  // @@protoc_insertion_point(field_set:RpbMapRedReq.request)
}
inline void RpbMapRedReq::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbMapRedReq.request)
}
inline void RpbMapRedReq::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbMapRedReq.request)
}
inline ::std::string* RpbMapRedReq::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbMapRedReq.request)
  return request_;
}
inline ::std::string* RpbMapRedReq::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbMapRedReq::set_allocated_request(::std::string* request) {
  if (request_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_;
  }
  if (request) {
    set_has_request();
    request_ = request;
  } else {
    clear_has_request();
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbMapRedReq.request)
}

// required bytes content_type = 2;
inline bool RpbMapRedReq::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedReq::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedReq::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedReq::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbMapRedReq::content_type() const {
  // @@protoc_insertion_point(field_get:RpbMapRedReq.content_type)
  return *content_type_;
}
inline void RpbMapRedReq::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbMapRedReq.content_type)
}
inline void RpbMapRedReq::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbMapRedReq.content_type)
}
inline void RpbMapRedReq::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbMapRedReq.content_type)
}
inline ::std::string* RpbMapRedReq::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbMapRedReq.content_type)
  return content_type_;
}
inline ::std::string* RpbMapRedReq::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbMapRedReq::set_allocated_content_type(::std::string* content_type) {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_type_;
  }
  if (content_type) {
    set_has_content_type();
    content_type_ = content_type;
  } else {
    clear_has_content_type();
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbMapRedReq.content_type)
}

// -------------------------------------------------------------------

// RpbMapRedResp

// optional uint32 phase = 1;
inline bool RpbMapRedResp::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedResp::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedResp::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedResp::clear_phase() {
  phase_ = 0u;
  clear_has_phase();
}
inline ::google::protobuf::uint32 RpbMapRedResp::phase() const {
  // @@protoc_insertion_point(field_get:RpbMapRedResp.phase)
  return phase_;
}
inline void RpbMapRedResp::set_phase(::google::protobuf::uint32 value) {
  set_has_phase();
  phase_ = value;
  // @@protoc_insertion_point(field_set:RpbMapRedResp.phase)
}

// optional bytes response = 2;
inline bool RpbMapRedResp::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedResp::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedResp::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedResp::clear_response() {
  if (response_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& RpbMapRedResp::response() const {
  // @@protoc_insertion_point(field_get:RpbMapRedResp.response)
  return *response_;
}
inline void RpbMapRedResp::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(value);
  // @@protoc_insertion_point(field_set:RpbMapRedResp.response)
}
inline void RpbMapRedResp::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbMapRedResp.response)
}
inline void RpbMapRedResp::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbMapRedResp.response)
}
inline ::std::string* RpbMapRedResp::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbMapRedResp.response)
  return response_;
}
inline ::std::string* RpbMapRedResp::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbMapRedResp::set_allocated_response(::std::string* response) {
  if (response_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete response_;
  }
  if (response) {
    set_has_response();
    response_ = response;
  } else {
    clear_has_response();
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbMapRedResp.response)
}

// optional bool done = 3;
inline bool RpbMapRedResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbMapRedResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbMapRedResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbMapRedResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbMapRedResp::done() const {
  // @@protoc_insertion_point(field_get:RpbMapRedResp.done)
  return done_;
}
inline void RpbMapRedResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbMapRedResp.done)
}

// -------------------------------------------------------------------

// RpbIndexReq

// required bytes bucket = 1;
inline bool RpbIndexReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbIndexReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbIndexReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbIndexReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbIndexReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.bucket)
  return *bucket_;
}
inline void RpbIndexReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.bucket)
}
inline void RpbIndexReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.bucket)
}
inline void RpbIndexReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.bucket)
}
inline ::std::string* RpbIndexReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.bucket)
  return bucket_;
}
inline ::std::string* RpbIndexReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.bucket)
}

// required bytes index = 2;
inline bool RpbIndexReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexReq::clear_index() {
  if (index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& RpbIndexReq::index() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.index)
  return *index_;
}
inline void RpbIndexReq::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.index)
}
inline void RpbIndexReq::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.index)
}
inline void RpbIndexReq::set_index(const void* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.index)
}
inline ::std::string* RpbIndexReq::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.index)
  return index_;
}
inline ::std::string* RpbIndexReq::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_index(::std::string* index) {
  if (index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete index_;
  }
  if (index) {
    set_has_index();
    index_ = index;
  } else {
    clear_has_index();
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.index)
}

// required .RpbIndexReq.IndexQueryType qtype = 3;
inline bool RpbIndexReq::has_qtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexReq::set_has_qtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexReq::clear_has_qtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexReq::clear_qtype() {
  qtype_ = 0;
  clear_has_qtype();
}
inline ::RpbIndexReq_IndexQueryType RpbIndexReq::qtype() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.qtype)
  return static_cast< ::RpbIndexReq_IndexQueryType >(qtype_);
}
inline void RpbIndexReq::set_qtype(::RpbIndexReq_IndexQueryType value) {
  assert(::RpbIndexReq_IndexQueryType_IsValid(value));
  set_has_qtype();
  qtype_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.qtype)
}

// optional bytes key = 4;
inline bool RpbIndexReq::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbIndexReq::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbIndexReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbIndexReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbIndexReq::key() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.key)
  return *key_;
}
inline void RpbIndexReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.key)
}
inline void RpbIndexReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.key)
}
inline void RpbIndexReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.key)
}
inline ::std::string* RpbIndexReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.key)
  return key_;
}
inline ::std::string* RpbIndexReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.key)
}

// optional bytes range_min = 5;
inline bool RpbIndexReq::has_range_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbIndexReq::set_has_range_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbIndexReq::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbIndexReq::clear_range_min() {
  if (range_min_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_->clear();
  }
  clear_has_range_min();
}
inline const ::std::string& RpbIndexReq::range_min() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.range_min)
  return *range_min_;
}
inline void RpbIndexReq::set_range_min(const ::std::string& value) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.range_min)
}
inline void RpbIndexReq::set_range_min(const char* value) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.range_min)
}
inline void RpbIndexReq::set_range_min(const void* value, size_t size) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.range_min)
}
inline ::std::string* RpbIndexReq::mutable_range_min() {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.range_min)
  return range_min_;
}
inline ::std::string* RpbIndexReq::release_range_min() {
  clear_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = range_min_;
    range_min_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_range_min(::std::string* range_min) {
  if (range_min_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete range_min_;
  }
  if (range_min) {
    set_has_range_min();
    range_min_ = range_min;
  } else {
    clear_has_range_min();
    range_min_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.range_min)
}

// optional bytes range_max = 6;
inline bool RpbIndexReq::has_range_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbIndexReq::set_has_range_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbIndexReq::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbIndexReq::clear_range_max() {
  if (range_max_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_->clear();
  }
  clear_has_range_max();
}
inline const ::std::string& RpbIndexReq::range_max() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.range_max)
  return *range_max_;
}
inline void RpbIndexReq::set_range_max(const ::std::string& value) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.range_max)
}
inline void RpbIndexReq::set_range_max(const char* value) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.range_max)
}
inline void RpbIndexReq::set_range_max(const void* value, size_t size) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.range_max)
}
inline ::std::string* RpbIndexReq::mutable_range_max() {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.range_max)
  return range_max_;
}
inline ::std::string* RpbIndexReq::release_range_max() {
  clear_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = range_max_;
    range_max_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_range_max(::std::string* range_max) {
  if (range_max_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete range_max_;
  }
  if (range_max) {
    set_has_range_max();
    range_max_ = range_max;
  } else {
    clear_has_range_max();
    range_max_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.range_max)
}

// optional bool return_terms = 7;
inline bool RpbIndexReq::has_return_terms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbIndexReq::set_has_return_terms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbIndexReq::clear_has_return_terms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbIndexReq::clear_return_terms() {
  return_terms_ = false;
  clear_has_return_terms();
}
inline bool RpbIndexReq::return_terms() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.return_terms)
  return return_terms_;
}
inline void RpbIndexReq::set_return_terms(bool value) {
  set_has_return_terms();
  return_terms_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.return_terms)
}

// optional bool stream = 8;
inline bool RpbIndexReq::has_stream() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbIndexReq::set_has_stream() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbIndexReq::clear_has_stream() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbIndexReq::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool RpbIndexReq::stream() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.stream)
  return stream_;
}
inline void RpbIndexReq::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.stream)
}

// optional uint32 max_results = 9;
inline bool RpbIndexReq::has_max_results() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbIndexReq::set_has_max_results() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbIndexReq::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbIndexReq::clear_max_results() {
  max_results_ = 0u;
  clear_has_max_results();
}
inline ::google::protobuf::uint32 RpbIndexReq::max_results() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.max_results)
  return max_results_;
}
inline void RpbIndexReq::set_max_results(::google::protobuf::uint32 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.max_results)
}

// optional bytes continuation = 10;
inline bool RpbIndexReq::has_continuation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbIndexReq::set_has_continuation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbIndexReq::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbIndexReq::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbIndexReq::continuation() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.continuation)
  return *continuation_;
}
inline void RpbIndexReq::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.continuation)
}
inline void RpbIndexReq::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.continuation)
}
inline void RpbIndexReq::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.continuation)
}
inline ::std::string* RpbIndexReq::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.continuation)
  return continuation_;
}
inline ::std::string* RpbIndexReq::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.continuation)
}

// optional uint32 timeout = 11;
inline bool RpbIndexReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbIndexReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbIndexReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbIndexReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbIndexReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.timeout)
  return timeout_;
}
inline void RpbIndexReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.timeout)
}

// optional bytes type = 12;
inline bool RpbIndexReq::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbIndexReq::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbIndexReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbIndexReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbIndexReq::type() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.type)
  return *type_;
}
inline void RpbIndexReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.type)
}
inline void RpbIndexReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.type)
}
inline void RpbIndexReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.type)
}
inline ::std::string* RpbIndexReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.type)
  return type_;
}
inline ::std::string* RpbIndexReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.type)
}

// optional bytes term_regex = 13;
inline bool RpbIndexReq::has_term_regex() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbIndexReq::set_has_term_regex() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbIndexReq::clear_has_term_regex() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbIndexReq::clear_term_regex() {
  if (term_regex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_->clear();
  }
  clear_has_term_regex();
}
inline const ::std::string& RpbIndexReq::term_regex() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.term_regex)
  return *term_regex_;
}
inline void RpbIndexReq::set_term_regex(const ::std::string& value) {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  term_regex_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.term_regex)
}
inline void RpbIndexReq::set_term_regex(const char* value) {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  term_regex_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.term_regex)
}
inline void RpbIndexReq::set_term_regex(const void* value, size_t size) {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  term_regex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.term_regex)
}
inline ::std::string* RpbIndexReq::mutable_term_regex() {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.term_regex)
  return term_regex_;
}
inline ::std::string* RpbIndexReq::release_term_regex() {
  clear_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = term_regex_;
    term_regex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_term_regex(::std::string* term_regex) {
  if (term_regex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete term_regex_;
  }
  if (term_regex) {
    set_has_term_regex();
    term_regex_ = term_regex;
  } else {
    clear_has_term_regex();
    term_regex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.term_regex)
}

// optional bool pagination_sort = 14;
inline bool RpbIndexReq::has_pagination_sort() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RpbIndexReq::set_has_pagination_sort() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RpbIndexReq::clear_has_pagination_sort() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RpbIndexReq::clear_pagination_sort() {
  pagination_sort_ = false;
  clear_has_pagination_sort();
}
inline bool RpbIndexReq::pagination_sort() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.pagination_sort)
  return pagination_sort_;
}
inline void RpbIndexReq::set_pagination_sort(bool value) {
  set_has_pagination_sort();
  pagination_sort_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.pagination_sort)
}

// optional bytes cover_context = 15;
inline bool RpbIndexReq::has_cover_context() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RpbIndexReq::set_has_cover_context() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RpbIndexReq::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RpbIndexReq::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& RpbIndexReq::cover_context() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.cover_context)
  return *cover_context_;
}
inline void RpbIndexReq::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.cover_context)
}
inline void RpbIndexReq::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.cover_context)
}
inline void RpbIndexReq::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.cover_context)
}
inline ::std::string* RpbIndexReq::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.cover_context)
  return cover_context_;
}
inline ::std::string* RpbIndexReq::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.cover_context)
}

// optional bool return_body = 16;
inline bool RpbIndexReq::has_return_body() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RpbIndexReq::set_has_return_body() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RpbIndexReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RpbIndexReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbIndexReq::return_body() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.return_body)
  return return_body_;
}
inline void RpbIndexReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.return_body)
}

// -------------------------------------------------------------------

// RpbIndexResp

// repeated bytes keys = 1;
inline int RpbIndexResp::keys_size() const {
  return keys_.size();
}
inline void RpbIndexResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbIndexResp::keys(int index) const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.keys)
  return keys_.Get(index);
}
inline ::std::string* RpbIndexResp::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:RpbIndexResp.keys)
  return keys_.Mutable(index);
}
inline void RpbIndexResp::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbIndexResp.keys)
  keys_.Mutable(index)->assign(value);
}
inline void RpbIndexResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexResp.keys)
}
inline void RpbIndexResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexResp.keys)
}
inline ::std::string* RpbIndexResp::add_keys() {
  return keys_.Add();
}
inline void RpbIndexResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbIndexResp.keys)
}
inline void RpbIndexResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbIndexResp.keys)
}
inline void RpbIndexResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbIndexResp.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbIndexResp::keys() const {
  // @@protoc_insertion_point(field_list:RpbIndexResp.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbIndexResp::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:RpbIndexResp.keys)
  return &keys_;
}

// repeated .RpbPair results = 2;
inline int RpbIndexResp::results_size() const {
  return results_.size();
}
inline void RpbIndexResp::clear_results() {
  results_.Clear();
}
inline const ::RpbPair& RpbIndexResp::results(int index) const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.results)
  return results_.Get(index);
}
inline ::RpbPair* RpbIndexResp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:RpbIndexResp.results)
  return results_.Mutable(index);
}
inline ::RpbPair* RpbIndexResp::add_results() {
  // @@protoc_insertion_point(field_add:RpbIndexResp.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbIndexResp::results() const {
  // @@protoc_insertion_point(field_list:RpbIndexResp.results)
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbIndexResp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:RpbIndexResp.results)
  return &results_;
}

// optional bytes continuation = 3;
inline bool RpbIndexResp::has_continuation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexResp::set_has_continuation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexResp::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexResp::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbIndexResp::continuation() const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.continuation)
  return *continuation_;
}
inline void RpbIndexResp::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexResp.continuation)
}
inline void RpbIndexResp::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexResp.continuation)
}
inline void RpbIndexResp::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexResp.continuation)
}
inline ::std::string* RpbIndexResp::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexResp.continuation)
  return continuation_;
}
inline ::std::string* RpbIndexResp::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexResp::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexResp.continuation)
}

// optional bool done = 4;
inline bool RpbIndexResp::has_done() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbIndexResp::set_has_done() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbIndexResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbIndexResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbIndexResp::done() const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.done)
  return done_;
}
inline void RpbIndexResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexResp.done)
}

// -------------------------------------------------------------------

// RpbIndexBodyResp

// repeated .RpbIndexObject objects = 1;
inline int RpbIndexBodyResp::objects_size() const {
  return objects_.size();
}
inline void RpbIndexBodyResp::clear_objects() {
  objects_.Clear();
}
inline const ::RpbIndexObject& RpbIndexBodyResp::objects(int index) const {
  // @@protoc_insertion_point(field_get:RpbIndexBodyResp.objects)
  return objects_.Get(index);
}
inline ::RpbIndexObject* RpbIndexBodyResp::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:RpbIndexBodyResp.objects)
  return objects_.Mutable(index);
}
inline ::RpbIndexObject* RpbIndexBodyResp::add_objects() {
  // @@protoc_insertion_point(field_add:RpbIndexBodyResp.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
RpbIndexBodyResp::objects() const {
  // @@protoc_insertion_point(field_list:RpbIndexBodyResp.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
RpbIndexBodyResp::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:RpbIndexBodyResp.objects)
  return &objects_;
}

// optional bytes continuation = 2;
inline bool RpbIndexBodyResp::has_continuation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexBodyResp::set_has_continuation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexBodyResp::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexBodyResp::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbIndexBodyResp::continuation() const {
  // @@protoc_insertion_point(field_get:RpbIndexBodyResp.continuation)
  return *continuation_;
}
inline void RpbIndexBodyResp::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexBodyResp.continuation)
}
inline void RpbIndexBodyResp::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexBodyResp.continuation)
}
inline void RpbIndexBodyResp::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexBodyResp.continuation)
}
inline ::std::string* RpbIndexBodyResp::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexBodyResp.continuation)
  return continuation_;
}
inline ::std::string* RpbIndexBodyResp::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexBodyResp::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexBodyResp.continuation)
}

// optional bool done = 3;
inline bool RpbIndexBodyResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexBodyResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexBodyResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexBodyResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbIndexBodyResp::done() const {
  // @@protoc_insertion_point(field_get:RpbIndexBodyResp.done)
  return done_;
}
inline void RpbIndexBodyResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexBodyResp.done)
}

// -------------------------------------------------------------------

// RpbCSBucketReq

// required bytes bucket = 1;
inline bool RpbCSBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCSBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCSBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCSBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCSBucketReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.bucket)
  return *bucket_;
}
inline void RpbCSBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.bucket)
}
inline void RpbCSBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.bucket)
}
inline void RpbCSBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.bucket)
}
inline ::std::string* RpbCSBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCSBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.bucket)
}

// required bytes start_key = 2;
inline bool RpbCSBucketReq::has_start_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCSBucketReq::set_has_start_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCSBucketReq::clear_has_start_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCSBucketReq::clear_start_key() {
  if (start_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_->clear();
  }
  clear_has_start_key();
}
inline const ::std::string& RpbCSBucketReq::start_key() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.start_key)
  return *start_key_;
}
inline void RpbCSBucketReq::set_start_key(const ::std::string& value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.start_key)
}
inline void RpbCSBucketReq::set_start_key(const char* value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.start_key)
}
inline void RpbCSBucketReq::set_start_key(const void* value, size_t size) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.start_key)
}
inline ::std::string* RpbCSBucketReq::mutable_start_key() {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.start_key)
  return start_key_;
}
inline ::std::string* RpbCSBucketReq::release_start_key() {
  clear_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_key_;
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_start_key(::std::string* start_key) {
  if (start_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_key_;
  }
  if (start_key) {
    set_has_start_key();
    start_key_ = start_key;
  } else {
    clear_has_start_key();
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.start_key)
}

// optional bytes end_key = 3;
inline bool RpbCSBucketReq::has_end_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCSBucketReq::set_has_end_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCSBucketReq::clear_has_end_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCSBucketReq::clear_end_key() {
  if (end_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_->clear();
  }
  clear_has_end_key();
}
inline const ::std::string& RpbCSBucketReq::end_key() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.end_key)
  return *end_key_;
}
inline void RpbCSBucketReq::set_end_key(const ::std::string& value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.end_key)
}
inline void RpbCSBucketReq::set_end_key(const char* value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.end_key)
}
inline void RpbCSBucketReq::set_end_key(const void* value, size_t size) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.end_key)
}
inline ::std::string* RpbCSBucketReq::mutable_end_key() {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.end_key)
  return end_key_;
}
inline ::std::string* RpbCSBucketReq::release_end_key() {
  clear_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_key_;
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_end_key(::std::string* end_key) {
  if (end_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_key_;
  }
  if (end_key) {
    set_has_end_key();
    end_key_ = end_key;
  } else {
    clear_has_end_key();
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.end_key)
}

// optional bool start_incl = 4 [default = true];
inline bool RpbCSBucketReq::has_start_incl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCSBucketReq::set_has_start_incl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCSBucketReq::clear_has_start_incl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCSBucketReq::clear_start_incl() {
  start_incl_ = true;
  clear_has_start_incl();
}
inline bool RpbCSBucketReq::start_incl() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.start_incl)
  return start_incl_;
}
inline void RpbCSBucketReq::set_start_incl(bool value) {
  set_has_start_incl();
  start_incl_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.start_incl)
}

// optional bool end_incl = 5 [default = false];
inline bool RpbCSBucketReq::has_end_incl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbCSBucketReq::set_has_end_incl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbCSBucketReq::clear_has_end_incl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbCSBucketReq::clear_end_incl() {
  end_incl_ = false;
  clear_has_end_incl();
}
inline bool RpbCSBucketReq::end_incl() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.end_incl)
  return end_incl_;
}
inline void RpbCSBucketReq::set_end_incl(bool value) {
  set_has_end_incl();
  end_incl_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.end_incl)
}

// optional bytes continuation = 6;
inline bool RpbCSBucketReq::has_continuation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbCSBucketReq::set_has_continuation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbCSBucketReq::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbCSBucketReq::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbCSBucketReq::continuation() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.continuation)
  return *continuation_;
}
inline void RpbCSBucketReq::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.continuation)
}
inline void RpbCSBucketReq::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.continuation)
}
inline void RpbCSBucketReq::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.continuation)
}
inline ::std::string* RpbCSBucketReq::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.continuation)
  return continuation_;
}
inline ::std::string* RpbCSBucketReq::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.continuation)
}

// optional uint32 max_results = 7;
inline bool RpbCSBucketReq::has_max_results() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbCSBucketReq::set_has_max_results() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbCSBucketReq::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbCSBucketReq::clear_max_results() {
  max_results_ = 0u;
  clear_has_max_results();
}
inline ::google::protobuf::uint32 RpbCSBucketReq::max_results() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.max_results)
  return max_results_;
}
inline void RpbCSBucketReq::set_max_results(::google::protobuf::uint32 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.max_results)
}

// optional uint32 timeout = 8;
inline bool RpbCSBucketReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbCSBucketReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbCSBucketReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbCSBucketReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbCSBucketReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.timeout)
  return timeout_;
}
inline void RpbCSBucketReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.timeout)
}

// optional bytes type = 9;
inline bool RpbCSBucketReq::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbCSBucketReq::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbCSBucketReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbCSBucketReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbCSBucketReq::type() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.type)
  return *type_;
}
inline void RpbCSBucketReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.type)
}
inline void RpbCSBucketReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.type)
}
inline void RpbCSBucketReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.type)
}
inline ::std::string* RpbCSBucketReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.type)
  return type_;
}
inline ::std::string* RpbCSBucketReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.type)
}

// optional bytes cover_context = 10;
inline bool RpbCSBucketReq::has_cover_context() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbCSBucketReq::set_has_cover_context() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbCSBucketReq::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbCSBucketReq::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& RpbCSBucketReq::cover_context() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.cover_context)
  return *cover_context_;
}
inline void RpbCSBucketReq::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.cover_context)
}
inline void RpbCSBucketReq::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.cover_context)
}
inline void RpbCSBucketReq::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.cover_context)
}
inline ::std::string* RpbCSBucketReq::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.cover_context)
  return cover_context_;
}
inline ::std::string* RpbCSBucketReq::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.cover_context)
}

// -------------------------------------------------------------------

// RpbCSBucketResp

// repeated .RpbIndexObject objects = 1;
inline int RpbCSBucketResp::objects_size() const {
  return objects_.size();
}
inline void RpbCSBucketResp::clear_objects() {
  objects_.Clear();
}
inline const ::RpbIndexObject& RpbCSBucketResp::objects(int index) const {
  // @@protoc_insertion_point(field_get:RpbCSBucketResp.objects)
  return objects_.Get(index);
}
inline ::RpbIndexObject* RpbCSBucketResp::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:RpbCSBucketResp.objects)
  return objects_.Mutable(index);
}
inline ::RpbIndexObject* RpbCSBucketResp::add_objects() {
  // @@protoc_insertion_point(field_add:RpbCSBucketResp.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
RpbCSBucketResp::objects() const {
  // @@protoc_insertion_point(field_list:RpbCSBucketResp.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
RpbCSBucketResp::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:RpbCSBucketResp.objects)
  return &objects_;
}

// optional bytes continuation = 2;
inline bool RpbCSBucketResp::has_continuation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCSBucketResp::set_has_continuation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCSBucketResp::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCSBucketResp::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbCSBucketResp::continuation() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketResp.continuation)
  return *continuation_;
}
inline void RpbCSBucketResp::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketResp.continuation)
}
inline void RpbCSBucketResp::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketResp.continuation)
}
inline void RpbCSBucketResp::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketResp.continuation)
}
inline ::std::string* RpbCSBucketResp::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketResp.continuation)
  return continuation_;
}
inline ::std::string* RpbCSBucketResp::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketResp::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketResp.continuation)
}

// optional bool done = 3;
inline bool RpbCSBucketResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCSBucketResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCSBucketResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCSBucketResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbCSBucketResp::done() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketResp.done)
  return done_;
}
inline void RpbCSBucketResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketResp.done)
}

// -------------------------------------------------------------------

// RpbIndexObject

// required bytes key = 1;
inline bool RpbIndexObject::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbIndexObject::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbIndexObject::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbIndexObject::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbIndexObject::key() const {
  // @@protoc_insertion_point(field_get:RpbIndexObject.key)
  return *key_;
}
inline void RpbIndexObject::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexObject.key)
}
inline void RpbIndexObject::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexObject.key)
}
inline void RpbIndexObject::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexObject.key)
}
inline ::std::string* RpbIndexObject::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexObject.key)
  return key_;
}
inline ::std::string* RpbIndexObject::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexObject::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexObject.key)
}

// required .RpbGetResp object = 2;
inline bool RpbIndexObject::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexObject::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexObject::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexObject::clear_object() {
  if (object_ != NULL) object_->::RpbGetResp::Clear();
  clear_has_object();
}
inline const ::RpbGetResp& RpbIndexObject::object() const {
  // @@protoc_insertion_point(field_get:RpbIndexObject.object)
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::RpbGetResp* RpbIndexObject::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::RpbGetResp;
  // @@protoc_insertion_point(field_mutable:RpbIndexObject.object)
  return object_;
}
inline ::RpbGetResp* RpbIndexObject::release_object() {
  clear_has_object();
  ::RpbGetResp* temp = object_;
  object_ = NULL;
  return temp;
}
inline void RpbIndexObject::set_allocated_object(::RpbGetResp* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexObject.object)
}

// -------------------------------------------------------------------

// RpbContent

// required bytes value = 1;
inline bool RpbContent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbContent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbContent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbContent::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbContent::value() const {
  // @@protoc_insertion_point(field_get:RpbContent.value)
  return *value_;
}
inline void RpbContent::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.value)
}
inline void RpbContent::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.value)
}
inline void RpbContent::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.value)
}
inline ::std::string* RpbContent::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.value)
  return value_;
}
inline ::std::string* RpbContent::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.value)
}

// optional bytes content_type = 2;
inline bool RpbContent::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbContent::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbContent::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbContent::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbContent::content_type() const {
  // @@protoc_insertion_point(field_get:RpbContent.content_type)
  return *content_type_;
}
inline void RpbContent::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.content_type)
}
inline void RpbContent::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.content_type)
}
inline void RpbContent::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.content_type)
}
inline ::std::string* RpbContent::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.content_type)
  return content_type_;
}
inline ::std::string* RpbContent::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_content_type(::std::string* content_type) {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_type_;
  }
  if (content_type) {
    set_has_content_type();
    content_type_ = content_type;
  } else {
    clear_has_content_type();
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.content_type)
}

// optional bytes charset = 3;
inline bool RpbContent::has_charset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbContent::set_has_charset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbContent::clear_has_charset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbContent::clear_charset() {
  if (charset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RpbContent::charset() const {
  // @@protoc_insertion_point(field_get:RpbContent.charset)
  return *charset_;
}
inline void RpbContent::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.charset)
}
inline void RpbContent::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.charset)
}
inline void RpbContent::set_charset(const void* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.charset)
}
inline ::std::string* RpbContent::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.charset)
  return charset_;
}
inline ::std::string* RpbContent::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_charset(::std::string* charset) {
  if (charset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete charset_;
  }
  if (charset) {
    set_has_charset();
    charset_ = charset;
  } else {
    clear_has_charset();
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.charset)
}

// optional bytes content_encoding = 4;
inline bool RpbContent::has_content_encoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbContent::set_has_content_encoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbContent::clear_has_content_encoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbContent::clear_content_encoding() {
  if (content_encoding_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_->clear();
  }
  clear_has_content_encoding();
}
inline const ::std::string& RpbContent::content_encoding() const {
  // @@protoc_insertion_point(field_get:RpbContent.content_encoding)
  return *content_encoding_;
}
inline void RpbContent::set_content_encoding(const ::std::string& value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.content_encoding)
}
inline void RpbContent::set_content_encoding(const char* value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.content_encoding)
}
inline void RpbContent::set_content_encoding(const void* value, size_t size) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.content_encoding)
}
inline ::std::string* RpbContent::mutable_content_encoding() {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.content_encoding)
  return content_encoding_;
}
inline ::std::string* RpbContent::release_content_encoding() {
  clear_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_encoding_;
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_content_encoding(::std::string* content_encoding) {
  if (content_encoding_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_encoding_;
  }
  if (content_encoding) {
    set_has_content_encoding();
    content_encoding_ = content_encoding;
  } else {
    clear_has_content_encoding();
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.content_encoding)
}

// optional bytes vtag = 5;
inline bool RpbContent::has_vtag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbContent::set_has_vtag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbContent::clear_has_vtag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbContent::clear_vtag() {
  if (vtag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_->clear();
  }
  clear_has_vtag();
}
inline const ::std::string& RpbContent::vtag() const {
  // @@protoc_insertion_point(field_get:RpbContent.vtag)
  return *vtag_;
}
inline void RpbContent::set_vtag(const ::std::string& value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.vtag)
}
inline void RpbContent::set_vtag(const char* value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.vtag)
}
inline void RpbContent::set_vtag(const void* value, size_t size) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.vtag)
}
inline ::std::string* RpbContent::mutable_vtag() {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.vtag)
  return vtag_;
}
inline ::std::string* RpbContent::release_vtag() {
  clear_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vtag_;
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_vtag(::std::string* vtag) {
  if (vtag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vtag_;
  }
  if (vtag) {
    set_has_vtag();
    vtag_ = vtag;
  } else {
    clear_has_vtag();
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.vtag)
}

// repeated .RpbLink links = 6;
inline int RpbContent::links_size() const {
  return links_.size();
}
inline void RpbContent::clear_links() {
  links_.Clear();
}
inline const ::RpbLink& RpbContent::links(int index) const {
  // @@protoc_insertion_point(field_get:RpbContent.links)
  return links_.Get(index);
}
inline ::RpbLink* RpbContent::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:RpbContent.links)
  return links_.Mutable(index);
}
inline ::RpbLink* RpbContent::add_links() {
  // @@protoc_insertion_point(field_add:RpbContent.links)
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
RpbContent::links() const {
  // @@protoc_insertion_point(field_list:RpbContent.links)
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
RpbContent::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:RpbContent.links)
  return &links_;
}

// optional uint32 last_mod = 7;
inline bool RpbContent::has_last_mod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbContent::set_has_last_mod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbContent::clear_has_last_mod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbContent::clear_last_mod() {
  last_mod_ = 0u;
  clear_has_last_mod();
}
inline ::google::protobuf::uint32 RpbContent::last_mod() const {
  // @@protoc_insertion_point(field_get:RpbContent.last_mod)
  return last_mod_;
}
inline void RpbContent::set_last_mod(::google::protobuf::uint32 value) {
  set_has_last_mod();
  last_mod_ = value;
  // @@protoc_insertion_point(field_set:RpbContent.last_mod)
}

// optional uint32 last_mod_usecs = 8;
inline bool RpbContent::has_last_mod_usecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbContent::set_has_last_mod_usecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbContent::clear_has_last_mod_usecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbContent::clear_last_mod_usecs() {
  last_mod_usecs_ = 0u;
  clear_has_last_mod_usecs();
}
inline ::google::protobuf::uint32 RpbContent::last_mod_usecs() const {
  // @@protoc_insertion_point(field_get:RpbContent.last_mod_usecs)
  return last_mod_usecs_;
}
inline void RpbContent::set_last_mod_usecs(::google::protobuf::uint32 value) {
  set_has_last_mod_usecs();
  last_mod_usecs_ = value;
  // @@protoc_insertion_point(field_set:RpbContent.last_mod_usecs)
}

// repeated .RpbPair usermeta = 9;
inline int RpbContent::usermeta_size() const {
  return usermeta_.size();
}
inline void RpbContent::clear_usermeta() {
  usermeta_.Clear();
}
inline const ::RpbPair& RpbContent::usermeta(int index) const {
  // @@protoc_insertion_point(field_get:RpbContent.usermeta)
  return usermeta_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_usermeta(int index) {
  // @@protoc_insertion_point(field_mutable:RpbContent.usermeta)
  return usermeta_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_usermeta() {
  // @@protoc_insertion_point(field_add:RpbContent.usermeta)
  return usermeta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::usermeta() const {
  // @@protoc_insertion_point(field_list:RpbContent.usermeta)
  return usermeta_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_usermeta() {
  // @@protoc_insertion_point(field_mutable_list:RpbContent.usermeta)
  return &usermeta_;
}

// repeated .RpbPair indexes = 10;
inline int RpbContent::indexes_size() const {
  return indexes_.size();
}
inline void RpbContent::clear_indexes() {
  indexes_.Clear();
}
inline const ::RpbPair& RpbContent::indexes(int index) const {
  // @@protoc_insertion_point(field_get:RpbContent.indexes)
  return indexes_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:RpbContent.indexes)
  return indexes_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_indexes() {
  // @@protoc_insertion_point(field_add:RpbContent.indexes)
  return indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::indexes() const {
  // @@protoc_insertion_point(field_list:RpbContent.indexes)
  return indexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:RpbContent.indexes)
  return &indexes_;
}

// optional bool deleted = 11;
inline bool RpbContent::has_deleted() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbContent::set_has_deleted() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbContent::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbContent::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool RpbContent::deleted() const {
  // @@protoc_insertion_point(field_get:RpbContent.deleted)
  return deleted_;
}
inline void RpbContent::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
  // @@protoc_insertion_point(field_set:RpbContent.deleted)
}

// -------------------------------------------------------------------

// RpbLink

// optional bytes bucket = 1;
inline bool RpbLink::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbLink::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbLink::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbLink::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbLink::bucket() const {
  // @@protoc_insertion_point(field_get:RpbLink.bucket)
  return *bucket_;
}
inline void RpbLink::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbLink.bucket)
}
inline void RpbLink::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbLink.bucket)
}
inline void RpbLink::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbLink.bucket)
}
inline ::std::string* RpbLink::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbLink.bucket)
  return bucket_;
}
inline ::std::string* RpbLink::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbLink::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbLink.bucket)
}

// optional bytes key = 2;
inline bool RpbLink::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbLink::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbLink::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbLink::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbLink::key() const {
  // @@protoc_insertion_point(field_get:RpbLink.key)
  return *key_;
}
inline void RpbLink::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbLink.key)
}
inline void RpbLink::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbLink.key)
}
inline void RpbLink::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbLink.key)
}
inline ::std::string* RpbLink::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbLink.key)
  return key_;
}
inline ::std::string* RpbLink::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbLink::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbLink.key)
}

// optional bytes tag = 3;
inline bool RpbLink::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbLink::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbLink::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbLink::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& RpbLink::tag() const {
  // @@protoc_insertion_point(field_get:RpbLink.tag)
  return *tag_;
}
inline void RpbLink::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:RpbLink.tag)
}
inline void RpbLink::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbLink.tag)
}
inline void RpbLink::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbLink.tag)
}
inline ::std::string* RpbLink::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbLink.tag)
  return tag_;
}
inline ::std::string* RpbLink::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbLink::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbLink.tag)
}

// -------------------------------------------------------------------

// RpbCounterUpdateReq

// required bytes bucket = 1;
inline bool RpbCounterUpdateReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterUpdateReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterUpdateReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterUpdateReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCounterUpdateReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.bucket)
  return *bucket_;
}
inline void RpbCounterUpdateReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.bucket)
}
inline void RpbCounterUpdateReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterUpdateReq.bucket)
}
inline void RpbCounterUpdateReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterUpdateReq.bucket)
}
inline ::std::string* RpbCounterUpdateReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterUpdateReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCounterUpdateReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterUpdateReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterUpdateReq.bucket)
}

// required bytes key = 2;
inline bool RpbCounterUpdateReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCounterUpdateReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCounterUpdateReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCounterUpdateReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbCounterUpdateReq::key() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.key)
  return *key_;
}
inline void RpbCounterUpdateReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.key)
}
inline void RpbCounterUpdateReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterUpdateReq.key)
}
inline void RpbCounterUpdateReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterUpdateReq.key)
}
inline ::std::string* RpbCounterUpdateReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterUpdateReq.key)
  return key_;
}
inline ::std::string* RpbCounterUpdateReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterUpdateReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterUpdateReq.key)
}

// required sint64 amount = 3;
inline bool RpbCounterUpdateReq::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCounterUpdateReq::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCounterUpdateReq::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCounterUpdateReq::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 RpbCounterUpdateReq::amount() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.amount)
  return amount_;
}
inline void RpbCounterUpdateReq::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.amount)
}

// optional uint32 w = 4;
inline bool RpbCounterUpdateReq::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCounterUpdateReq::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCounterUpdateReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCounterUpdateReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbCounterUpdateReq::w() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.w)
  return w_;
}
inline void RpbCounterUpdateReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.w)
}

// optional uint32 dw = 5;
inline bool RpbCounterUpdateReq::has_dw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbCounterUpdateReq::set_has_dw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbCounterUpdateReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbCounterUpdateReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbCounterUpdateReq::dw() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.dw)
  return dw_;
}
inline void RpbCounterUpdateReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.dw)
}

// optional uint32 pw = 6;
inline bool RpbCounterUpdateReq::has_pw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbCounterUpdateReq::set_has_pw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbCounterUpdateReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbCounterUpdateReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbCounterUpdateReq::pw() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.pw)
  return pw_;
}
inline void RpbCounterUpdateReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.pw)
}

// optional bool returnvalue = 7;
inline bool RpbCounterUpdateReq::has_returnvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbCounterUpdateReq::set_has_returnvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbCounterUpdateReq::clear_has_returnvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbCounterUpdateReq::clear_returnvalue() {
  returnvalue_ = false;
  clear_has_returnvalue();
}
inline bool RpbCounterUpdateReq::returnvalue() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.returnvalue)
  return returnvalue_;
}
inline void RpbCounterUpdateReq::set_returnvalue(bool value) {
  set_has_returnvalue();
  returnvalue_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.returnvalue)
}

// -------------------------------------------------------------------

// RpbCounterUpdateResp

// optional sint64 value = 1;
inline bool RpbCounterUpdateResp::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterUpdateResp::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterUpdateResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterUpdateResp::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 RpbCounterUpdateResp::value() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateResp.value)
  return value_;
}
inline void RpbCounterUpdateResp::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateResp.value)
}

// -------------------------------------------------------------------

// RpbCounterGetReq

// required bytes bucket = 1;
inline bool RpbCounterGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCounterGetReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.bucket)
  return *bucket_;
}
inline void RpbCounterGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.bucket)
}
inline void RpbCounterGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterGetReq.bucket)
}
inline void RpbCounterGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterGetReq.bucket)
}
inline ::std::string* RpbCounterGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterGetReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCounterGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterGetReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterGetReq.bucket)
}

// required bytes key = 2;
inline bool RpbCounterGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCounterGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCounterGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCounterGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbCounterGetReq::key() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.key)
  return *key_;
}
inline void RpbCounterGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.key)
}
inline void RpbCounterGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterGetReq.key)
}
inline void RpbCounterGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterGetReq.key)
}
inline ::std::string* RpbCounterGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterGetReq.key)
  return key_;
}
inline ::std::string* RpbCounterGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterGetReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterGetReq.key)
}

// optional uint32 r = 3;
inline bool RpbCounterGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCounterGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCounterGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCounterGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbCounterGetReq::r() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.r)
  return r_;
}
inline void RpbCounterGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.r)
}

// optional uint32 pr = 4;
inline bool RpbCounterGetReq::has_pr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCounterGetReq::set_has_pr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCounterGetReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCounterGetReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbCounterGetReq::pr() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.pr)
  return pr_;
}
inline void RpbCounterGetReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.pr)
}

// optional bool basic_quorum = 5;
inline bool RpbCounterGetReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbCounterGetReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbCounterGetReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbCounterGetReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbCounterGetReq::basic_quorum() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.basic_quorum)
  return basic_quorum_;
}
inline void RpbCounterGetReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.basic_quorum)
}

// optional bool notfound_ok = 6;
inline bool RpbCounterGetReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbCounterGetReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbCounterGetReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbCounterGetReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbCounterGetReq::notfound_ok() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.notfound_ok)
  return notfound_ok_;
}
inline void RpbCounterGetReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.notfound_ok)
}

// -------------------------------------------------------------------

// RpbCounterGetResp

// optional sint64 value = 1;
inline bool RpbCounterGetResp::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterGetResp::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterGetResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterGetResp::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 RpbCounterGetResp::value() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetResp.value)
  return value_;
}
inline void RpbCounterGetResp::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetResp.value)
}

// -------------------------------------------------------------------

// RpbGetBucketKeyPreflistReq

// required bytes bucket = 1;
inline bool RpbGetBucketKeyPreflistReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketKeyPreflistReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketKeyPreflistReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketKeyPreflistReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetBucketKeyPreflistReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistReq.bucket)
  return *bucket_;
}
inline void RpbGetBucketKeyPreflistReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketKeyPreflistReq.bucket)
}
inline void RpbGetBucketKeyPreflistReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketKeyPreflistReq.bucket)
}
inline void RpbGetBucketKeyPreflistReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketKeyPreflistReq.bucket)
}
inline ::std::string* RpbGetBucketKeyPreflistReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistReq.bucket)
  return bucket_;
}
inline ::std::string* RpbGetBucketKeyPreflistReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketKeyPreflistReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketKeyPreflistReq.bucket)
}

// required bytes key = 2;
inline bool RpbGetBucketKeyPreflistReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetBucketKeyPreflistReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetBucketKeyPreflistReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetBucketKeyPreflistReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetBucketKeyPreflistReq::key() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistReq.key)
  return *key_;
}
inline void RpbGetBucketKeyPreflistReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketKeyPreflistReq.key)
}
inline void RpbGetBucketKeyPreflistReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketKeyPreflistReq.key)
}
inline void RpbGetBucketKeyPreflistReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketKeyPreflistReq.key)
}
inline ::std::string* RpbGetBucketKeyPreflistReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistReq.key)
  return key_;
}
inline ::std::string* RpbGetBucketKeyPreflistReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketKeyPreflistReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketKeyPreflistReq.key)
}

// optional bytes type = 3;
inline bool RpbGetBucketKeyPreflistReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetBucketKeyPreflistReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetBucketKeyPreflistReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetBucketKeyPreflistReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbGetBucketKeyPreflistReq::type() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistReq.type)
  return *type_;
}
inline void RpbGetBucketKeyPreflistReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketKeyPreflistReq.type)
}
inline void RpbGetBucketKeyPreflistReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketKeyPreflistReq.type)
}
inline void RpbGetBucketKeyPreflistReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketKeyPreflistReq.type)
}
inline ::std::string* RpbGetBucketKeyPreflistReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistReq.type)
  return type_;
}
inline ::std::string* RpbGetBucketKeyPreflistReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketKeyPreflistReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketKeyPreflistReq.type)
}

// -------------------------------------------------------------------

// RpbGetBucketKeyPreflistResp

// repeated .RpbBucketKeyPreflistItem preflist = 1;
inline int RpbGetBucketKeyPreflistResp::preflist_size() const {
  return preflist_.size();
}
inline void RpbGetBucketKeyPreflistResp::clear_preflist() {
  preflist_.Clear();
}
inline const ::RpbBucketKeyPreflistItem& RpbGetBucketKeyPreflistResp::preflist(int index) const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_.Get(index);
}
inline ::RpbBucketKeyPreflistItem* RpbGetBucketKeyPreflistResp::mutable_preflist(int index) {
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_.Mutable(index);
}
inline ::RpbBucketKeyPreflistItem* RpbGetBucketKeyPreflistResp::add_preflist() {
  // @@protoc_insertion_point(field_add:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >&
RpbGetBucketKeyPreflistResp::preflist() const {
  // @@protoc_insertion_point(field_list:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >*
RpbGetBucketKeyPreflistResp::mutable_preflist() {
  // @@protoc_insertion_point(field_mutable_list:RpbGetBucketKeyPreflistResp.preflist)
  return &preflist_;
}

// -------------------------------------------------------------------

// RpbBucketKeyPreflistItem

// required int64 partition = 1;
inline bool RpbBucketKeyPreflistItem::has_partition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbBucketKeyPreflistItem::set_has_partition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbBucketKeyPreflistItem::clear_has_partition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbBucketKeyPreflistItem::clear_partition() {
  partition_ = GOOGLE_LONGLONG(0);
  clear_has_partition();
}
inline ::google::protobuf::int64 RpbBucketKeyPreflistItem::partition() const {
  // @@protoc_insertion_point(field_get:RpbBucketKeyPreflistItem.partition)
  return partition_;
}
inline void RpbBucketKeyPreflistItem::set_partition(::google::protobuf::int64 value) {
  set_has_partition();
  partition_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketKeyPreflistItem.partition)
}

// required bytes node = 2;
inline bool RpbBucketKeyPreflistItem::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbBucketKeyPreflistItem::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbBucketKeyPreflistItem::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbBucketKeyPreflistItem::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& RpbBucketKeyPreflistItem::node() const {
  // @@protoc_insertion_point(field_get:RpbBucketKeyPreflistItem.node)
  return *node_;
}
inline void RpbBucketKeyPreflistItem::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:RpbBucketKeyPreflistItem.node)
}
inline void RpbBucketKeyPreflistItem::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbBucketKeyPreflistItem.node)
}
inline void RpbBucketKeyPreflistItem::set_node(const void* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbBucketKeyPreflistItem.node)
}
inline ::std::string* RpbBucketKeyPreflistItem::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbBucketKeyPreflistItem.node)
  return node_;
}
inline ::std::string* RpbBucketKeyPreflistItem::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbBucketKeyPreflistItem::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketKeyPreflistItem.node)
}

// required bool primary = 3;
inline bool RpbBucketKeyPreflistItem::has_primary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbBucketKeyPreflistItem::set_has_primary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbBucketKeyPreflistItem::clear_has_primary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbBucketKeyPreflistItem::clear_primary() {
  primary_ = false;
  clear_has_primary();
}
inline bool RpbBucketKeyPreflistItem::primary() const {
  // @@protoc_insertion_point(field_get:RpbBucketKeyPreflistItem.primary)
  return primary_;
}
inline void RpbBucketKeyPreflistItem::set_primary(bool value) {
  set_has_primary();
  primary_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketKeyPreflistItem.primary)
}

// -------------------------------------------------------------------

// RpbCoverageReq

// optional bytes type = 1;
inline bool RpbCoverageReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCoverageReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCoverageReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCoverageReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbCoverageReq::type() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.type)
  return *type_;
}
inline void RpbCoverageReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageReq.type)
}
inline void RpbCoverageReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.type)
}
inline void RpbCoverageReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.type)
}
inline ::std::string* RpbCoverageReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.type)
  return type_;
}
inline ::std::string* RpbCoverageReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageReq.type)
}

// required bytes bucket = 2;
inline bool RpbCoverageReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCoverageReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCoverageReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCoverageReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCoverageReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.bucket)
  return *bucket_;
}
inline void RpbCoverageReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageReq.bucket)
}
inline void RpbCoverageReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.bucket)
}
inline void RpbCoverageReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.bucket)
}
inline ::std::string* RpbCoverageReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCoverageReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageReq.bucket)
}

// optional uint32 min_partitions = 3;
inline bool RpbCoverageReq::has_min_partitions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCoverageReq::set_has_min_partitions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCoverageReq::clear_has_min_partitions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCoverageReq::clear_min_partitions() {
  min_partitions_ = 0u;
  clear_has_min_partitions();
}
inline ::google::protobuf::uint32 RpbCoverageReq::min_partitions() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.min_partitions)
  return min_partitions_;
}
inline void RpbCoverageReq::set_min_partitions(::google::protobuf::uint32 value) {
  set_has_min_partitions();
  min_partitions_ = value;
  // @@protoc_insertion_point(field_set:RpbCoverageReq.min_partitions)
}

// optional bytes replace_cover = 4;
inline bool RpbCoverageReq::has_replace_cover() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCoverageReq::set_has_replace_cover() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCoverageReq::clear_has_replace_cover() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCoverageReq::clear_replace_cover() {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_->clear();
  }
  clear_has_replace_cover();
}
inline const ::std::string& RpbCoverageReq::replace_cover() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.replace_cover)
  return *replace_cover_;
}
inline void RpbCoverageReq::set_replace_cover(const ::std::string& value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageReq.replace_cover)
}
inline void RpbCoverageReq::set_replace_cover(const char* value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.replace_cover)
}
inline void RpbCoverageReq::set_replace_cover(const void* value, size_t size) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.replace_cover)
}
inline ::std::string* RpbCoverageReq::mutable_replace_cover() {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.replace_cover)
  return replace_cover_;
}
inline ::std::string* RpbCoverageReq::release_replace_cover() {
  clear_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = replace_cover_;
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageReq::set_allocated_replace_cover(::std::string* replace_cover) {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete replace_cover_;
  }
  if (replace_cover) {
    set_has_replace_cover();
    replace_cover_ = replace_cover;
  } else {
    clear_has_replace_cover();
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageReq.replace_cover)
}

// repeated bytes unavailable_cover = 5;
inline int RpbCoverageReq::unavailable_cover_size() const {
  return unavailable_cover_.size();
}
inline void RpbCoverageReq::clear_unavailable_cover() {
  unavailable_cover_.Clear();
}
inline const ::std::string& RpbCoverageReq::unavailable_cover(int index) const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.unavailable_cover)
  return unavailable_cover_.Get(index);
}
inline ::std::string* RpbCoverageReq::mutable_unavailable_cover(int index) {
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.unavailable_cover)
  return unavailable_cover_.Mutable(index);
}
inline void RpbCoverageReq::set_unavailable_cover(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbCoverageReq.unavailable_cover)
  unavailable_cover_.Mutable(index)->assign(value);
}
inline void RpbCoverageReq::set_unavailable_cover(int index, const char* value) {
  unavailable_cover_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.unavailable_cover)
}
inline void RpbCoverageReq::set_unavailable_cover(int index, const void* value, size_t size) {
  unavailable_cover_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.unavailable_cover)
}
inline ::std::string* RpbCoverageReq::add_unavailable_cover() {
  return unavailable_cover_.Add();
}
inline void RpbCoverageReq::add_unavailable_cover(const ::std::string& value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbCoverageReq.unavailable_cover)
}
inline void RpbCoverageReq::add_unavailable_cover(const char* value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbCoverageReq.unavailable_cover)
}
inline void RpbCoverageReq::add_unavailable_cover(const void* value, size_t size) {
  unavailable_cover_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbCoverageReq.unavailable_cover)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbCoverageReq::unavailable_cover() const {
  // @@protoc_insertion_point(field_list:RpbCoverageReq.unavailable_cover)
  return unavailable_cover_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbCoverageReq::mutable_unavailable_cover() {
  // @@protoc_insertion_point(field_mutable_list:RpbCoverageReq.unavailable_cover)
  return &unavailable_cover_;
}

// -------------------------------------------------------------------

// RpbCoverageResp

// repeated .RpbCoverageEntry entries = 1;
inline int RpbCoverageResp::entries_size() const {
  return entries_.size();
}
inline void RpbCoverageResp::clear_entries() {
  entries_.Clear();
}
inline const ::RpbCoverageEntry& RpbCoverageResp::entries(int index) const {
  // @@protoc_insertion_point(field_get:RpbCoverageResp.entries)
  return entries_.Get(index);
}
inline ::RpbCoverageEntry* RpbCoverageResp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:RpbCoverageResp.entries)
  return entries_.Mutable(index);
}
inline ::RpbCoverageEntry* RpbCoverageResp::add_entries() {
  // @@protoc_insertion_point(field_add:RpbCoverageResp.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >&
RpbCoverageResp::entries() const {
  // @@protoc_insertion_point(field_list:RpbCoverageResp.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >*
RpbCoverageResp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:RpbCoverageResp.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// RpbCoverageEntry

// required bytes ip = 1;
inline bool RpbCoverageEntry::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCoverageEntry::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCoverageEntry::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCoverageEntry::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RpbCoverageEntry::ip() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.ip)
  return *ip_;
}
inline void RpbCoverageEntry::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.ip)
}
inline void RpbCoverageEntry::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageEntry.ip)
}
inline void RpbCoverageEntry::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageEntry.ip)
}
inline ::std::string* RpbCoverageEntry::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageEntry.ip)
  return ip_;
}
inline ::std::string* RpbCoverageEntry::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageEntry::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageEntry.ip)
}

// required uint32 port = 2;
inline bool RpbCoverageEntry::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCoverageEntry::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCoverageEntry::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCoverageEntry::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 RpbCoverageEntry::port() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.port)
  return port_;
}
inline void RpbCoverageEntry::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.port)
}

// optional bytes keyspace_desc = 3;
inline bool RpbCoverageEntry::has_keyspace_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCoverageEntry::set_has_keyspace_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCoverageEntry::clear_has_keyspace_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCoverageEntry::clear_keyspace_desc() {
  if (keyspace_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_->clear();
  }
  clear_has_keyspace_desc();
}
inline const ::std::string& RpbCoverageEntry::keyspace_desc() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.keyspace_desc)
  return *keyspace_desc_;
}
inline void RpbCoverageEntry::set_keyspace_desc(const ::std::string& value) {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  keyspace_desc_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.keyspace_desc)
}
inline void RpbCoverageEntry::set_keyspace_desc(const char* value) {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  keyspace_desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageEntry.keyspace_desc)
}
inline void RpbCoverageEntry::set_keyspace_desc(const void* value, size_t size) {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  keyspace_desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageEntry.keyspace_desc)
}
inline ::std::string* RpbCoverageEntry::mutable_keyspace_desc() {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageEntry.keyspace_desc)
  return keyspace_desc_;
}
inline ::std::string* RpbCoverageEntry::release_keyspace_desc() {
  clear_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = keyspace_desc_;
    keyspace_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageEntry::set_allocated_keyspace_desc(::std::string* keyspace_desc) {
  if (keyspace_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keyspace_desc_;
  }
  if (keyspace_desc) {
    set_has_keyspace_desc();
    keyspace_desc_ = keyspace_desc;
  } else {
    clear_has_keyspace_desc();
    keyspace_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageEntry.keyspace_desc)
}

// required bytes cover_context = 4;
inline bool RpbCoverageEntry::has_cover_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCoverageEntry::set_has_cover_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCoverageEntry::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCoverageEntry::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& RpbCoverageEntry::cover_context() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.cover_context)
  return *cover_context_;
}
inline void RpbCoverageEntry::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.cover_context)
}
inline void RpbCoverageEntry::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageEntry.cover_context)
}
inline void RpbCoverageEntry::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageEntry.cover_context)
}
inline ::std::string* RpbCoverageEntry::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageEntry.cover_context)
  return cover_context_;
}
inline ::std::string* RpbCoverageEntry::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageEntry::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageEntry.cover_context)
}

// -------------------------------------------------------------------

// RpbErrorResp

// required bytes errmsg = 1;
inline bool RpbErrorResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbErrorResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbErrorResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbErrorResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& RpbErrorResp::errmsg() const {
  // @@protoc_insertion_point(field_get:RpbErrorResp.errmsg)
  return *errmsg_;
}
inline void RpbErrorResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:RpbErrorResp.errmsg)
}
inline void RpbErrorResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbErrorResp.errmsg)
}
inline void RpbErrorResp::set_errmsg(const void* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbErrorResp.errmsg)
}
inline ::std::string* RpbErrorResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbErrorResp.errmsg)
  return errmsg_;
}
inline ::std::string* RpbErrorResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbErrorResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbErrorResp.errmsg)
}

// required uint32 errcode = 2;
inline bool RpbErrorResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbErrorResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbErrorResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbErrorResp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 RpbErrorResp::errcode() const {
  // @@protoc_insertion_point(field_get:RpbErrorResp.errcode)
  return errcode_;
}
inline void RpbErrorResp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:RpbErrorResp.errcode)
}

// -------------------------------------------------------------------

// RpbGetServerInfoResp

// optional bytes node = 1;
inline bool RpbGetServerInfoResp::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetServerInfoResp::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetServerInfoResp::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetServerInfoResp::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& RpbGetServerInfoResp::node() const {
  // @@protoc_insertion_point(field_get:RpbGetServerInfoResp.node)
  return *node_;
}
inline void RpbGetServerInfoResp::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetServerInfoResp.node)
}
inline void RpbGetServerInfoResp::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetServerInfoResp.node)
}
inline void RpbGetServerInfoResp::set_node(const void* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetServerInfoResp.node)
}
inline ::std::string* RpbGetServerInfoResp::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetServerInfoResp.node)
  return node_;
}
inline ::std::string* RpbGetServerInfoResp::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetServerInfoResp::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetServerInfoResp.node)
}

// optional bytes server_version = 2;
inline bool RpbGetServerInfoResp::has_server_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetServerInfoResp::set_has_server_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetServerInfoResp::clear_has_server_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetServerInfoResp::clear_server_version() {
  if (server_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_->clear();
  }
  clear_has_server_version();
}
inline const ::std::string& RpbGetServerInfoResp::server_version() const {
  // @@protoc_insertion_point(field_get:RpbGetServerInfoResp.server_version)
  return *server_version_;
}
inline void RpbGetServerInfoResp::set_server_version(const ::std::string& value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetServerInfoResp.server_version)
}
inline void RpbGetServerInfoResp::set_server_version(const char* value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetServerInfoResp.server_version)
}
inline void RpbGetServerInfoResp::set_server_version(const void* value, size_t size) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetServerInfoResp.server_version)
}
inline ::std::string* RpbGetServerInfoResp::mutable_server_version() {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetServerInfoResp.server_version)
  return server_version_;
}
inline ::std::string* RpbGetServerInfoResp::release_server_version() {
  clear_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_version_;
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetServerInfoResp::set_allocated_server_version(::std::string* server_version) {
  if (server_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_version_;
  }
  if (server_version) {
    set_has_server_version();
    server_version_ = server_version;
  } else {
    clear_has_server_version();
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetServerInfoResp.server_version)
}

// -------------------------------------------------------------------

// RpbPair

// required bytes key = 1;
inline bool RpbPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPair::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPair::key() const {
  // @@protoc_insertion_point(field_get:RpbPair.key)
  return *key_;
}
inline void RpbPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPair.key)
}
inline void RpbPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPair.key)
}
inline void RpbPair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPair.key)
}
inline ::std::string* RpbPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPair.key)
  return key_;
}
inline ::std::string* RpbPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPair.key)
}

// optional bytes value = 2;
inline bool RpbPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPair::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbPair::value() const {
  // @@protoc_insertion_point(field_get:RpbPair.value)
  return *value_;
}
inline void RpbPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPair.value)
}
inline void RpbPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPair.value)
}
inline void RpbPair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPair.value)
}
inline ::std::string* RpbPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPair.value)
  return value_;
}
inline ::std::string* RpbPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPair.value)
}

// -------------------------------------------------------------------

// RpbGetBucketReq

// required bytes bucket = 1;
inline bool RpbGetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetBucketReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketReq.bucket)
  return *bucket_;
}
inline void RpbGetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketReq.bucket)
}
inline void RpbGetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketReq.bucket)
}
inline void RpbGetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketReq.bucket)
}
inline ::std::string* RpbGetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketReq.bucket)
  return bucket_;
}
inline ::std::string* RpbGetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketReq.bucket)
}

// optional bytes type = 2;
inline bool RpbGetBucketReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetBucketReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetBucketReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetBucketReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbGetBucketReq::type() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketReq.type)
  return *type_;
}
inline void RpbGetBucketReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketReq.type)
}
inline void RpbGetBucketReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketReq.type)
}
inline void RpbGetBucketReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketReq.type)
}
inline ::std::string* RpbGetBucketReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketReq.type)
  return type_;
}
inline ::std::string* RpbGetBucketReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketReq.type)
}

// -------------------------------------------------------------------

// RpbGetBucketResp

// required .RpbBucketProps props = 1;
inline bool RpbGetBucketResp::has_props() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketResp::set_has_props() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketResp::clear_has_props() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketResp::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbGetBucketResp::props() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketResp.props)
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  // @@protoc_insertion_point(field_mutable:RpbGetBucketResp.props)
  return props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}
inline void RpbGetBucketResp::set_allocated_props(::RpbBucketProps* props) {
  delete props_;
  props_ = props;
  if (props) {
    set_has_props();
  } else {
    clear_has_props();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketResp.props)
}

// -------------------------------------------------------------------

// RpbSetBucketReq

// required bytes bucket = 1;
inline bool RpbSetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbSetBucketReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbSetBucketReq.bucket)
  return *bucket_;
}
inline void RpbSetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSetBucketReq.bucket)
}
inline void RpbSetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSetBucketReq.bucket)
}
inline void RpbSetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSetBucketReq.bucket)
}
inline ::std::string* RpbSetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSetBucketReq.bucket)
  return bucket_;
}
inline ::std::string* RpbSetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSetBucketReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetBucketReq.bucket)
}

// required .RpbBucketProps props = 2;
inline bool RpbSetBucketReq::has_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSetBucketReq::set_has_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSetBucketReq::clear_has_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSetBucketReq::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbSetBucketReq::props() const {
  // @@protoc_insertion_point(field_get:RpbSetBucketReq.props)
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  // @@protoc_insertion_point(field_mutable:RpbSetBucketReq.props)
  return props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}
inline void RpbSetBucketReq::set_allocated_props(::RpbBucketProps* props) {
  delete props_;
  props_ = props;
  if (props) {
    set_has_props();
  } else {
    clear_has_props();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetBucketReq.props)
}

// optional bytes type = 3;
inline bool RpbSetBucketReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbSetBucketReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbSetBucketReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbSetBucketReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbSetBucketReq::type() const {
  // @@protoc_insertion_point(field_get:RpbSetBucketReq.type)
  return *type_;
}
inline void RpbSetBucketReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSetBucketReq.type)
}
inline void RpbSetBucketReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSetBucketReq.type)
}
inline void RpbSetBucketReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSetBucketReq.type)
}
inline ::std::string* RpbSetBucketReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSetBucketReq.type)
  return type_;
}
inline ::std::string* RpbSetBucketReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSetBucketReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetBucketReq.type)
}

// -------------------------------------------------------------------

// RpbResetBucketReq

// required bytes bucket = 1;
inline bool RpbResetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbResetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbResetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbResetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbResetBucketReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbResetBucketReq.bucket)
  return *bucket_;
}
inline void RpbResetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbResetBucketReq.bucket)
}
inline void RpbResetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbResetBucketReq.bucket)
}
inline void RpbResetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbResetBucketReq.bucket)
}
inline ::std::string* RpbResetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbResetBucketReq.bucket)
  return bucket_;
}
inline ::std::string* RpbResetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbResetBucketReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbResetBucketReq.bucket)
}

// optional bytes type = 2;
inline bool RpbResetBucketReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbResetBucketReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbResetBucketReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbResetBucketReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbResetBucketReq::type() const {
  // @@protoc_insertion_point(field_get:RpbResetBucketReq.type)
  return *type_;
}
inline void RpbResetBucketReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbResetBucketReq.type)
}
inline void RpbResetBucketReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbResetBucketReq.type)
}
inline void RpbResetBucketReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbResetBucketReq.type)
}
inline ::std::string* RpbResetBucketReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbResetBucketReq.type)
  return type_;
}
inline ::std::string* RpbResetBucketReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbResetBucketReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbResetBucketReq.type)
}

// -------------------------------------------------------------------

// RpbGetBucketTypeReq

// required bytes type = 1;
inline bool RpbGetBucketTypeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketTypeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketTypeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketTypeReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbGetBucketTypeReq::type() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketTypeReq.type)
  return *type_;
}
inline void RpbGetBucketTypeReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketTypeReq.type)
}
inline void RpbGetBucketTypeReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketTypeReq.type)
}
inline void RpbGetBucketTypeReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketTypeReq.type)
}
inline ::std::string* RpbGetBucketTypeReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketTypeReq.type)
  return type_;
}
inline ::std::string* RpbGetBucketTypeReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketTypeReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketTypeReq.type)
}

// -------------------------------------------------------------------

// RpbSetBucketTypeReq

// required bytes type = 1;
inline bool RpbSetBucketTypeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetBucketTypeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetBucketTypeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetBucketTypeReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbSetBucketTypeReq::type() const {
  // @@protoc_insertion_point(field_get:RpbSetBucketTypeReq.type)
  return *type_;
}
inline void RpbSetBucketTypeReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSetBucketTypeReq.type)
}
inline void RpbSetBucketTypeReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSetBucketTypeReq.type)
}
inline void RpbSetBucketTypeReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSetBucketTypeReq.type)
}
inline ::std::string* RpbSetBucketTypeReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSetBucketTypeReq.type)
  return type_;
}
inline ::std::string* RpbSetBucketTypeReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSetBucketTypeReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetBucketTypeReq.type)
}

// required .RpbBucketProps props = 2;
inline bool RpbSetBucketTypeReq::has_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSetBucketTypeReq::set_has_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSetBucketTypeReq::clear_has_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSetBucketTypeReq::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::RpbBucketProps& RpbSetBucketTypeReq::props() const {
  // @@protoc_insertion_point(field_get:RpbSetBucketTypeReq.props)
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbSetBucketTypeReq::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  // @@protoc_insertion_point(field_mutable:RpbSetBucketTypeReq.props)
  return props_;
}
inline ::RpbBucketProps* RpbSetBucketTypeReq::release_props() {
  clear_has_props();
  ::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}
inline void RpbSetBucketTypeReq::set_allocated_props(::RpbBucketProps* props) {
  delete props_;
  props_ = props;
  if (props) {
    set_has_props();
  } else {
    clear_has_props();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetBucketTypeReq.props)
}

// -------------------------------------------------------------------

// RpbModFun

// required bytes module = 1;
inline bool RpbModFun::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbModFun::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbModFun::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbModFun::clear_module() {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_->clear();
  }
  clear_has_module();
}
inline const ::std::string& RpbModFun::module() const {
  // @@protoc_insertion_point(field_get:RpbModFun.module)
  return *module_;
}
inline void RpbModFun::set_module(const ::std::string& value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(value);
  // @@protoc_insertion_point(field_set:RpbModFun.module)
}
inline void RpbModFun::set_module(const char* value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbModFun.module)
}
inline void RpbModFun::set_module(const void* value, size_t size) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbModFun.module)
}
inline ::std::string* RpbModFun::mutable_module() {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbModFun.module)
  return module_;
}
inline ::std::string* RpbModFun::release_module() {
  clear_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = module_;
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbModFun::set_allocated_module(::std::string* module) {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete module_;
  }
  if (module) {
    set_has_module();
    module_ = module;
  } else {
    clear_has_module();
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbModFun.module)
}

// required bytes function = 2;
inline bool RpbModFun::has_function() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbModFun::set_has_function() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbModFun::clear_has_function() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbModFun::clear_function() {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_->clear();
  }
  clear_has_function();
}
inline const ::std::string& RpbModFun::function() const {
  // @@protoc_insertion_point(field_get:RpbModFun.function)
  return *function_;
}
inline void RpbModFun::set_function(const ::std::string& value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set:RpbModFun.function)
}
inline void RpbModFun::set_function(const char* value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbModFun.function)
}
inline void RpbModFun::set_function(const void* value, size_t size) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbModFun.function)
}
inline ::std::string* RpbModFun::mutable_function() {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbModFun.function)
  return function_;
}
inline ::std::string* RpbModFun::release_function() {
  clear_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_;
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbModFun::set_allocated_function(::std::string* function) {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_;
  }
  if (function) {
    set_has_function();
    function_ = function;
  } else {
    clear_has_function();
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbModFun.function)
}

// -------------------------------------------------------------------

// RpbCommitHook

// optional .RpbModFun modfun = 1;
inline bool RpbCommitHook::has_modfun() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCommitHook::set_has_modfun() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCommitHook::clear_has_modfun() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCommitHook::clear_modfun() {
  if (modfun_ != NULL) modfun_->::RpbModFun::Clear();
  clear_has_modfun();
}
inline const ::RpbModFun& RpbCommitHook::modfun() const {
  // @@protoc_insertion_point(field_get:RpbCommitHook.modfun)
  return modfun_ != NULL ? *modfun_ : *default_instance_->modfun_;
}
inline ::RpbModFun* RpbCommitHook::mutable_modfun() {
  set_has_modfun();
  if (modfun_ == NULL) modfun_ = new ::RpbModFun;
  // @@protoc_insertion_point(field_mutable:RpbCommitHook.modfun)
  return modfun_;
}
inline ::RpbModFun* RpbCommitHook::release_modfun() {
  clear_has_modfun();
  ::RpbModFun* temp = modfun_;
  modfun_ = NULL;
  return temp;
}
inline void RpbCommitHook::set_allocated_modfun(::RpbModFun* modfun) {
  delete modfun_;
  modfun_ = modfun;
  if (modfun) {
    set_has_modfun();
  } else {
    clear_has_modfun();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCommitHook.modfun)
}

// optional bytes name = 2;
inline bool RpbCommitHook::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCommitHook::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCommitHook::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCommitHook::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpbCommitHook::name() const {
  // @@protoc_insertion_point(field_get:RpbCommitHook.name)
  return *name_;
}
inline void RpbCommitHook::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCommitHook.name)
}
inline void RpbCommitHook::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCommitHook.name)
}
inline void RpbCommitHook::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCommitHook.name)
}
inline ::std::string* RpbCommitHook::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCommitHook.name)
  return name_;
}
inline ::std::string* RpbCommitHook::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCommitHook::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCommitHook.name)
}

// -------------------------------------------------------------------

// RpbBucketProps

// optional uint32 n_val = 1;
inline bool RpbBucketProps::has_n_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbBucketProps::set_has_n_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbBucketProps::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbBucketProps::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbBucketProps::n_val() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.n_val)
  return n_val_;
}
inline void RpbBucketProps::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.n_val)
}

// optional bool allow_mult = 2;
inline bool RpbBucketProps::has_allow_mult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbBucketProps::set_has_allow_mult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbBucketProps::clear_has_allow_mult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbBucketProps::clear_allow_mult() {
  allow_mult_ = false;
  clear_has_allow_mult();
}
inline bool RpbBucketProps::allow_mult() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.allow_mult)
  return allow_mult_;
}
inline void RpbBucketProps::set_allow_mult(bool value) {
  set_has_allow_mult();
  allow_mult_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.allow_mult)
}

// optional bool last_write_wins = 3;
inline bool RpbBucketProps::has_last_write_wins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbBucketProps::set_has_last_write_wins() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbBucketProps::clear_has_last_write_wins() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbBucketProps::clear_last_write_wins() {
  last_write_wins_ = false;
  clear_has_last_write_wins();
}
inline bool RpbBucketProps::last_write_wins() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.last_write_wins)
  return last_write_wins_;
}
inline void RpbBucketProps::set_last_write_wins(bool value) {
  set_has_last_write_wins();
  last_write_wins_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.last_write_wins)
}

// repeated .RpbCommitHook precommit = 4;
inline int RpbBucketProps::precommit_size() const {
  return precommit_.size();
}
inline void RpbBucketProps::clear_precommit() {
  precommit_.Clear();
}
inline const ::RpbCommitHook& RpbBucketProps::precommit(int index) const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.precommit)
  return precommit_.Get(index);
}
inline ::RpbCommitHook* RpbBucketProps::mutable_precommit(int index) {
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.precommit)
  return precommit_.Mutable(index);
}
inline ::RpbCommitHook* RpbBucketProps::add_precommit() {
  // @@protoc_insertion_point(field_add:RpbBucketProps.precommit)
  return precommit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >&
RpbBucketProps::precommit() const {
  // @@protoc_insertion_point(field_list:RpbBucketProps.precommit)
  return precommit_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >*
RpbBucketProps::mutable_precommit() {
  // @@protoc_insertion_point(field_mutable_list:RpbBucketProps.precommit)
  return &precommit_;
}

// optional bool has_precommit = 5 [default = false];
inline bool RpbBucketProps::has_has_precommit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbBucketProps::set_has_has_precommit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbBucketProps::clear_has_has_precommit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbBucketProps::clear_has_precommit() {
  has_precommit_ = false;
  clear_has_has_precommit();
}
inline bool RpbBucketProps::has_precommit() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.has_precommit)
  return has_precommit_;
}
inline void RpbBucketProps::set_has_precommit(bool value) {
  set_has_has_precommit();
  has_precommit_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.has_precommit)
}

// repeated .RpbCommitHook postcommit = 6;
inline int RpbBucketProps::postcommit_size() const {
  return postcommit_.size();
}
inline void RpbBucketProps::clear_postcommit() {
  postcommit_.Clear();
}
inline const ::RpbCommitHook& RpbBucketProps::postcommit(int index) const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.postcommit)
  return postcommit_.Get(index);
}
inline ::RpbCommitHook* RpbBucketProps::mutable_postcommit(int index) {
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.postcommit)
  return postcommit_.Mutable(index);
}
inline ::RpbCommitHook* RpbBucketProps::add_postcommit() {
  // @@protoc_insertion_point(field_add:RpbBucketProps.postcommit)
  return postcommit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >&
RpbBucketProps::postcommit() const {
  // @@protoc_insertion_point(field_list:RpbBucketProps.postcommit)
  return postcommit_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbCommitHook >*
RpbBucketProps::mutable_postcommit() {
  // @@protoc_insertion_point(field_mutable_list:RpbBucketProps.postcommit)
  return &postcommit_;
}

// optional bool has_postcommit = 7 [default = false];
inline bool RpbBucketProps::has_has_postcommit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbBucketProps::set_has_has_postcommit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbBucketProps::clear_has_has_postcommit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbBucketProps::clear_has_postcommit() {
  has_postcommit_ = false;
  clear_has_has_postcommit();
}
inline bool RpbBucketProps::has_postcommit() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.has_postcommit)
  return has_postcommit_;
}
inline void RpbBucketProps::set_has_postcommit(bool value) {
  set_has_has_postcommit();
  has_postcommit_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.has_postcommit)
}

// optional .RpbModFun chash_keyfun = 8;
inline bool RpbBucketProps::has_chash_keyfun() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbBucketProps::set_has_chash_keyfun() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbBucketProps::clear_has_chash_keyfun() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbBucketProps::clear_chash_keyfun() {
  if (chash_keyfun_ != NULL) chash_keyfun_->::RpbModFun::Clear();
  clear_has_chash_keyfun();
}
inline const ::RpbModFun& RpbBucketProps::chash_keyfun() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.chash_keyfun)
  return chash_keyfun_ != NULL ? *chash_keyfun_ : *default_instance_->chash_keyfun_;
}
inline ::RpbModFun* RpbBucketProps::mutable_chash_keyfun() {
  set_has_chash_keyfun();
  if (chash_keyfun_ == NULL) chash_keyfun_ = new ::RpbModFun;
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.chash_keyfun)
  return chash_keyfun_;
}
inline ::RpbModFun* RpbBucketProps::release_chash_keyfun() {
  clear_has_chash_keyfun();
  ::RpbModFun* temp = chash_keyfun_;
  chash_keyfun_ = NULL;
  return temp;
}
inline void RpbBucketProps::set_allocated_chash_keyfun(::RpbModFun* chash_keyfun) {
  delete chash_keyfun_;
  chash_keyfun_ = chash_keyfun;
  if (chash_keyfun) {
    set_has_chash_keyfun();
  } else {
    clear_has_chash_keyfun();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketProps.chash_keyfun)
}

// optional .RpbModFun linkfun = 9;
inline bool RpbBucketProps::has_linkfun() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbBucketProps::set_has_linkfun() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbBucketProps::clear_has_linkfun() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbBucketProps::clear_linkfun() {
  if (linkfun_ != NULL) linkfun_->::RpbModFun::Clear();
  clear_has_linkfun();
}
inline const ::RpbModFun& RpbBucketProps::linkfun() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.linkfun)
  return linkfun_ != NULL ? *linkfun_ : *default_instance_->linkfun_;
}
inline ::RpbModFun* RpbBucketProps::mutable_linkfun() {
  set_has_linkfun();
  if (linkfun_ == NULL) linkfun_ = new ::RpbModFun;
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.linkfun)
  return linkfun_;
}
inline ::RpbModFun* RpbBucketProps::release_linkfun() {
  clear_has_linkfun();
  ::RpbModFun* temp = linkfun_;
  linkfun_ = NULL;
  return temp;
}
inline void RpbBucketProps::set_allocated_linkfun(::RpbModFun* linkfun) {
  delete linkfun_;
  linkfun_ = linkfun;
  if (linkfun) {
    set_has_linkfun();
  } else {
    clear_has_linkfun();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketProps.linkfun)
}

// optional uint32 old_vclock = 10;
inline bool RpbBucketProps::has_old_vclock() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbBucketProps::set_has_old_vclock() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbBucketProps::clear_has_old_vclock() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbBucketProps::clear_old_vclock() {
  old_vclock_ = 0u;
  clear_has_old_vclock();
}
inline ::google::protobuf::uint32 RpbBucketProps::old_vclock() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.old_vclock)
  return old_vclock_;
}
inline void RpbBucketProps::set_old_vclock(::google::protobuf::uint32 value) {
  set_has_old_vclock();
  old_vclock_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.old_vclock)
}

// optional uint32 young_vclock = 11;
inline bool RpbBucketProps::has_young_vclock() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbBucketProps::set_has_young_vclock() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbBucketProps::clear_has_young_vclock() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbBucketProps::clear_young_vclock() {
  young_vclock_ = 0u;
  clear_has_young_vclock();
}
inline ::google::protobuf::uint32 RpbBucketProps::young_vclock() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.young_vclock)
  return young_vclock_;
}
inline void RpbBucketProps::set_young_vclock(::google::protobuf::uint32 value) {
  set_has_young_vclock();
  young_vclock_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.young_vclock)
}

// optional uint32 big_vclock = 12;
inline bool RpbBucketProps::has_big_vclock() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbBucketProps::set_has_big_vclock() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbBucketProps::clear_has_big_vclock() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbBucketProps::clear_big_vclock() {
  big_vclock_ = 0u;
  clear_has_big_vclock();
}
inline ::google::protobuf::uint32 RpbBucketProps::big_vclock() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.big_vclock)
  return big_vclock_;
}
inline void RpbBucketProps::set_big_vclock(::google::protobuf::uint32 value) {
  set_has_big_vclock();
  big_vclock_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.big_vclock)
}

// optional uint32 small_vclock = 13;
inline bool RpbBucketProps::has_small_vclock() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbBucketProps::set_has_small_vclock() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbBucketProps::clear_has_small_vclock() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbBucketProps::clear_small_vclock() {
  small_vclock_ = 0u;
  clear_has_small_vclock();
}
inline ::google::protobuf::uint32 RpbBucketProps::small_vclock() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.small_vclock)
  return small_vclock_;
}
inline void RpbBucketProps::set_small_vclock(::google::protobuf::uint32 value) {
  set_has_small_vclock();
  small_vclock_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.small_vclock)
}

// optional uint32 pr = 14;
inline bool RpbBucketProps::has_pr() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RpbBucketProps::set_has_pr() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RpbBucketProps::clear_has_pr() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RpbBucketProps::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbBucketProps::pr() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.pr)
  return pr_;
}
inline void RpbBucketProps::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.pr)
}

// optional uint32 r = 15;
inline bool RpbBucketProps::has_r() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RpbBucketProps::set_has_r() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RpbBucketProps::clear_has_r() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RpbBucketProps::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbBucketProps::r() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.r)
  return r_;
}
inline void RpbBucketProps::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.r)
}

// optional uint32 w = 16;
inline bool RpbBucketProps::has_w() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RpbBucketProps::set_has_w() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RpbBucketProps::clear_has_w() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RpbBucketProps::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbBucketProps::w() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.w)
  return w_;
}
inline void RpbBucketProps::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.w)
}

// optional uint32 pw = 17;
inline bool RpbBucketProps::has_pw() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RpbBucketProps::set_has_pw() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RpbBucketProps::clear_has_pw() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RpbBucketProps::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbBucketProps::pw() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.pw)
  return pw_;
}
inline void RpbBucketProps::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.pw)
}

// optional uint32 dw = 18;
inline bool RpbBucketProps::has_dw() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RpbBucketProps::set_has_dw() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RpbBucketProps::clear_has_dw() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RpbBucketProps::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbBucketProps::dw() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.dw)
  return dw_;
}
inline void RpbBucketProps::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.dw)
}

// optional uint32 rw = 19;
inline bool RpbBucketProps::has_rw() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RpbBucketProps::set_has_rw() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RpbBucketProps::clear_has_rw() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RpbBucketProps::clear_rw() {
  rw_ = 0u;
  clear_has_rw();
}
inline ::google::protobuf::uint32 RpbBucketProps::rw() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.rw)
  return rw_;
}
inline void RpbBucketProps::set_rw(::google::protobuf::uint32 value) {
  set_has_rw();
  rw_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.rw)
}

// optional bool basic_quorum = 20;
inline bool RpbBucketProps::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RpbBucketProps::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RpbBucketProps::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RpbBucketProps::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbBucketProps::basic_quorum() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.basic_quorum)
  return basic_quorum_;
}
inline void RpbBucketProps::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.basic_quorum)
}

// optional bool notfound_ok = 21;
inline bool RpbBucketProps::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RpbBucketProps::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RpbBucketProps::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RpbBucketProps::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbBucketProps::notfound_ok() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.notfound_ok)
  return notfound_ok_;
}
inline void RpbBucketProps::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.notfound_ok)
}

// optional bytes backend = 22;
inline bool RpbBucketProps::has_backend() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RpbBucketProps::set_has_backend() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RpbBucketProps::clear_has_backend() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RpbBucketProps::clear_backend() {
  if (backend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backend_->clear();
  }
  clear_has_backend();
}
inline const ::std::string& RpbBucketProps::backend() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.backend)
  return *backend_;
}
inline void RpbBucketProps::set_backend(const ::std::string& value) {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backend_ = new ::std::string;
  }
  backend_->assign(value);
  // @@protoc_insertion_point(field_set:RpbBucketProps.backend)
}
inline void RpbBucketProps::set_backend(const char* value) {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backend_ = new ::std::string;
  }
  backend_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbBucketProps.backend)
}
inline void RpbBucketProps::set_backend(const void* value, size_t size) {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backend_ = new ::std::string;
  }
  backend_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbBucketProps.backend)
}
inline ::std::string* RpbBucketProps::mutable_backend() {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backend_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.backend)
  return backend_;
}
inline ::std::string* RpbBucketProps::release_backend() {
  clear_has_backend();
  if (backend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backend_;
    backend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbBucketProps::set_allocated_backend(::std::string* backend) {
  if (backend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backend_;
  }
  if (backend) {
    set_has_backend();
    backend_ = backend;
  } else {
    clear_has_backend();
    backend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketProps.backend)
}

// optional bool search = 23;
inline bool RpbBucketProps::has_search() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RpbBucketProps::set_has_search() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RpbBucketProps::clear_has_search() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RpbBucketProps::clear_search() {
  search_ = false;
  clear_has_search();
}
inline bool RpbBucketProps::search() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.search)
  return search_;
}
inline void RpbBucketProps::set_search(bool value) {
  set_has_search();
  search_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.search)
}

// optional .RpbBucketProps.RpbReplMode repl = 24;
inline bool RpbBucketProps::has_repl() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RpbBucketProps::set_has_repl() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RpbBucketProps::clear_has_repl() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RpbBucketProps::clear_repl() {
  repl_ = 0;
  clear_has_repl();
}
inline ::RpbBucketProps_RpbReplMode RpbBucketProps::repl() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.repl)
  return static_cast< ::RpbBucketProps_RpbReplMode >(repl_);
}
inline void RpbBucketProps::set_repl(::RpbBucketProps_RpbReplMode value) {
  assert(::RpbBucketProps_RpbReplMode_IsValid(value));
  set_has_repl();
  repl_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.repl)
}

// optional bytes search_index = 25;
inline bool RpbBucketProps::has_search_index() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RpbBucketProps::set_has_search_index() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RpbBucketProps::clear_has_search_index() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RpbBucketProps::clear_search_index() {
  if (search_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_index_->clear();
  }
  clear_has_search_index();
}
inline const ::std::string& RpbBucketProps::search_index() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.search_index)
  return *search_index_;
}
inline void RpbBucketProps::set_search_index(const ::std::string& value) {
  set_has_search_index();
  if (search_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_index_ = new ::std::string;
  }
  search_index_->assign(value);
  // @@protoc_insertion_point(field_set:RpbBucketProps.search_index)
}
inline void RpbBucketProps::set_search_index(const char* value) {
  set_has_search_index();
  if (search_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_index_ = new ::std::string;
  }
  search_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbBucketProps.search_index)
}
inline void RpbBucketProps::set_search_index(const void* value, size_t size) {
  set_has_search_index();
  if (search_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_index_ = new ::std::string;
  }
  search_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbBucketProps.search_index)
}
inline ::std::string* RpbBucketProps::mutable_search_index() {
  set_has_search_index();
  if (search_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.search_index)
  return search_index_;
}
inline ::std::string* RpbBucketProps::release_search_index() {
  clear_has_search_index();
  if (search_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = search_index_;
    search_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbBucketProps::set_allocated_search_index(::std::string* search_index) {
  if (search_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete search_index_;
  }
  if (search_index) {
    set_has_search_index();
    search_index_ = search_index;
  } else {
    clear_has_search_index();
    search_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketProps.search_index)
}

// optional bytes datatype = 26;
inline bool RpbBucketProps::has_datatype() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RpbBucketProps::set_has_datatype() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RpbBucketProps::clear_has_datatype() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RpbBucketProps::clear_datatype() {
  if (datatype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datatype_->clear();
  }
  clear_has_datatype();
}
inline const ::std::string& RpbBucketProps::datatype() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.datatype)
  return *datatype_;
}
inline void RpbBucketProps::set_datatype(const ::std::string& value) {
  set_has_datatype();
  if (datatype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datatype_ = new ::std::string;
  }
  datatype_->assign(value);
  // @@protoc_insertion_point(field_set:RpbBucketProps.datatype)
}
inline void RpbBucketProps::set_datatype(const char* value) {
  set_has_datatype();
  if (datatype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datatype_ = new ::std::string;
  }
  datatype_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbBucketProps.datatype)
}
inline void RpbBucketProps::set_datatype(const void* value, size_t size) {
  set_has_datatype();
  if (datatype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datatype_ = new ::std::string;
  }
  datatype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbBucketProps.datatype)
}
inline ::std::string* RpbBucketProps::mutable_datatype() {
  set_has_datatype();
  if (datatype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    datatype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbBucketProps.datatype)
  return datatype_;
}
inline ::std::string* RpbBucketProps::release_datatype() {
  clear_has_datatype();
  if (datatype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = datatype_;
    datatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbBucketProps::set_allocated_datatype(::std::string* datatype) {
  if (datatype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete datatype_;
  }
  if (datatype) {
    set_has_datatype();
    datatype_ = datatype;
  } else {
    clear_has_datatype();
    datatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketProps.datatype)
}

// optional bool consistent = 27;
inline bool RpbBucketProps::has_consistent() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RpbBucketProps::set_has_consistent() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RpbBucketProps::clear_has_consistent() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RpbBucketProps::clear_consistent() {
  consistent_ = false;
  clear_has_consistent();
}
inline bool RpbBucketProps::consistent() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.consistent)
  return consistent_;
}
inline void RpbBucketProps::set_consistent(bool value) {
  set_has_consistent();
  consistent_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.consistent)
}

// optional bool write_once = 28;
inline bool RpbBucketProps::has_write_once() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RpbBucketProps::set_has_write_once() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RpbBucketProps::clear_has_write_once() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RpbBucketProps::clear_write_once() {
  write_once_ = false;
  clear_has_write_once();
}
inline bool RpbBucketProps::write_once() const {
  // @@protoc_insertion_point(field_get:RpbBucketProps.write_once)
  return write_once_;
}
inline void RpbBucketProps::set_write_once(bool value) {
  set_has_write_once();
  write_once_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketProps.write_once)
}

// -------------------------------------------------------------------

// RpbAuthReq

// required bytes user = 1;
inline bool RpbAuthReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbAuthReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbAuthReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbAuthReq::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& RpbAuthReq::user() const {
  // @@protoc_insertion_point(field_get:RpbAuthReq.user)
  return *user_;
}
inline void RpbAuthReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:RpbAuthReq.user)
}
inline void RpbAuthReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbAuthReq.user)
}
inline void RpbAuthReq::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbAuthReq.user)
}
inline ::std::string* RpbAuthReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbAuthReq.user)
  return user_;
}
inline ::std::string* RpbAuthReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbAuthReq::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbAuthReq.user)
}

// required bytes password = 2;
inline bool RpbAuthReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbAuthReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbAuthReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbAuthReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RpbAuthReq::password() const {
  // @@protoc_insertion_point(field_get:RpbAuthReq.password)
  return *password_;
}
inline void RpbAuthReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:RpbAuthReq.password)
}
inline void RpbAuthReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbAuthReq.password)
}
inline void RpbAuthReq::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbAuthReq.password)
}
inline ::std::string* RpbAuthReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbAuthReq.password)
  return password_;
}
inline ::std::string* RpbAuthReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbAuthReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbAuthReq.password)
}

// -------------------------------------------------------------------

// RpbToggleEncodingReq

// required bool use_native = 1;
inline bool RpbToggleEncodingReq::has_use_native() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbToggleEncodingReq::set_has_use_native() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbToggleEncodingReq::clear_has_use_native() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbToggleEncodingReq::clear_use_native() {
  use_native_ = false;
  clear_has_use_native();
}
inline bool RpbToggleEncodingReq::use_native() const {
  // @@protoc_insertion_point(field_get:RpbToggleEncodingReq.use_native)
  return use_native_;
}
inline void RpbToggleEncodingReq::set_use_native(bool value) {
  set_has_use_native();
  use_native_ = value;
  // @@protoc_insertion_point(field_set:RpbToggleEncodingReq.use_native)
}

// -------------------------------------------------------------------

// RpbToggleEncodingResp

// required bool use_native = 1;
inline bool RpbToggleEncodingResp::has_use_native() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbToggleEncodingResp::set_has_use_native() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbToggleEncodingResp::clear_has_use_native() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbToggleEncodingResp::clear_use_native() {
  use_native_ = false;
  clear_has_use_native();
}
inline bool RpbToggleEncodingResp::use_native() const {
  // @@protoc_insertion_point(field_get:RpbToggleEncodingResp.use_native)
  return use_native_;
}
inline void RpbToggleEncodingResp::set_use_native(bool value) {
  set_has_use_native();
  use_native_ = value;
  // @@protoc_insertion_point(field_set:RpbToggleEncodingResp.use_native)
}

// -------------------------------------------------------------------

// RpbSearchDoc

// repeated .RpbPair fields = 1;
inline int RpbSearchDoc::fields_size() const {
  return fields_.size();
}
inline void RpbSearchDoc::clear_fields() {
  fields_.Clear();
}
inline const ::RpbPair& RpbSearchDoc::fields(int index) const {
  // @@protoc_insertion_point(field_get:RpbSearchDoc.fields)
  return fields_.Get(index);
}
inline ::RpbPair* RpbSearchDoc::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:RpbSearchDoc.fields)
  return fields_.Mutable(index);
}
inline ::RpbPair* RpbSearchDoc::add_fields() {
  // @@protoc_insertion_point(field_add:RpbSearchDoc.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbSearchDoc::fields() const {
  // @@protoc_insertion_point(field_list:RpbSearchDoc.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbSearchDoc::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:RpbSearchDoc.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// RpbSearchQueryReq

// required bytes q = 1;
inline bool RpbSearchQueryReq::has_q() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSearchQueryReq::set_has_q() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSearchQueryReq::clear_has_q() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSearchQueryReq::clear_q() {
  if (q_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_->clear();
  }
  clear_has_q();
}
inline const ::std::string& RpbSearchQueryReq::q() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.q)
  return *q_;
}
inline void RpbSearchQueryReq::set_q(const ::std::string& value) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  q_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.q)
}
inline void RpbSearchQueryReq::set_q(const char* value) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  q_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.q)
}
inline void RpbSearchQueryReq::set_q(const void* value, size_t size) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  q_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.q)
}
inline ::std::string* RpbSearchQueryReq::mutable_q() {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.q)
  return q_;
}
inline ::std::string* RpbSearchQueryReq::release_q() {
  clear_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = q_;
    q_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_q(::std::string* q) {
  if (q_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete q_;
  }
  if (q) {
    set_has_q();
    q_ = q;
  } else {
    clear_has_q();
    q_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.q)
}

// required bytes index = 2;
inline bool RpbSearchQueryReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSearchQueryReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSearchQueryReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSearchQueryReq::clear_index() {
  if (index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& RpbSearchQueryReq::index() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.index)
  return *index_;
}
inline void RpbSearchQueryReq::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.index)
}
inline void RpbSearchQueryReq::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.index)
}
inline void RpbSearchQueryReq::set_index(const void* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.index)
}
inline ::std::string* RpbSearchQueryReq::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.index)
  return index_;
}
inline ::std::string* RpbSearchQueryReq::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_index(::std::string* index) {
  if (index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete index_;
  }
  if (index) {
    set_has_index();
    index_ = index;
  } else {
    clear_has_index();
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.index)
}

// optional uint32 rows = 3;
inline bool RpbSearchQueryReq::has_rows() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbSearchQueryReq::set_has_rows() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbSearchQueryReq::clear_has_rows() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbSearchQueryReq::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 RpbSearchQueryReq::rows() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.rows)
  return rows_;
}
inline void RpbSearchQueryReq::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.rows)
}

// optional uint32 start = 4;
inline bool RpbSearchQueryReq::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbSearchQueryReq::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbSearchQueryReq::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbSearchQueryReq::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 RpbSearchQueryReq::start() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.start)
  return start_;
}
inline void RpbSearchQueryReq::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.start)
}

// optional bytes sort = 5;
inline bool RpbSearchQueryReq::has_sort() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbSearchQueryReq::set_has_sort() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbSearchQueryReq::clear_has_sort() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbSearchQueryReq::clear_sort() {
  if (sort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_->clear();
  }
  clear_has_sort();
}
inline const ::std::string& RpbSearchQueryReq::sort() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.sort)
  return *sort_;
}
inline void RpbSearchQueryReq::set_sort(const ::std::string& value) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.sort)
}
inline void RpbSearchQueryReq::set_sort(const char* value) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.sort)
}
inline void RpbSearchQueryReq::set_sort(const void* value, size_t size) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.sort)
}
inline ::std::string* RpbSearchQueryReq::mutable_sort() {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.sort)
  return sort_;
}
inline ::std::string* RpbSearchQueryReq::release_sort() {
  clear_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sort_;
    sort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_sort(::std::string* sort) {
  if (sort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sort_;
  }
  if (sort) {
    set_has_sort();
    sort_ = sort;
  } else {
    clear_has_sort();
    sort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.sort)
}

// optional bytes filter = 6;
inline bool RpbSearchQueryReq::has_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbSearchQueryReq::set_has_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbSearchQueryReq::clear_has_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbSearchQueryReq::clear_filter() {
  if (filter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& RpbSearchQueryReq::filter() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.filter)
  return *filter_;
}
inline void RpbSearchQueryReq::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.filter)
}
inline void RpbSearchQueryReq::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.filter)
}
inline void RpbSearchQueryReq::set_filter(const void* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.filter)
}
inline ::std::string* RpbSearchQueryReq::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.filter)
  return filter_;
}
inline ::std::string* RpbSearchQueryReq::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_filter(::std::string* filter) {
  if (filter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filter_;
  }
  if (filter) {
    set_has_filter();
    filter_ = filter;
  } else {
    clear_has_filter();
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.filter)
}

// optional bytes df = 7;
inline bool RpbSearchQueryReq::has_df() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbSearchQueryReq::set_has_df() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbSearchQueryReq::clear_has_df() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbSearchQueryReq::clear_df() {
  if (df_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    df_->clear();
  }
  clear_has_df();
}
inline const ::std::string& RpbSearchQueryReq::df() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.df)
  return *df_;
}
inline void RpbSearchQueryReq::set_df(const ::std::string& value) {
  set_has_df();
  if (df_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    df_ = new ::std::string;
  }
  df_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.df)
}
inline void RpbSearchQueryReq::set_df(const char* value) {
  set_has_df();
  if (df_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    df_ = new ::std::string;
  }
  df_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.df)
}
inline void RpbSearchQueryReq::set_df(const void* value, size_t size) {
  set_has_df();
  if (df_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    df_ = new ::std::string;
  }
  df_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.df)
}
inline ::std::string* RpbSearchQueryReq::mutable_df() {
  set_has_df();
  if (df_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    df_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.df)
  return df_;
}
inline ::std::string* RpbSearchQueryReq::release_df() {
  clear_has_df();
  if (df_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = df_;
    df_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_df(::std::string* df) {
  if (df_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete df_;
  }
  if (df) {
    set_has_df();
    df_ = df;
  } else {
    clear_has_df();
    df_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.df)
}

// optional bytes op = 8;
inline bool RpbSearchQueryReq::has_op() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbSearchQueryReq::set_has_op() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbSearchQueryReq::clear_has_op() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbSearchQueryReq::clear_op() {
  if (op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_->clear();
  }
  clear_has_op();
}
inline const ::std::string& RpbSearchQueryReq::op() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.op)
  return *op_;
}
inline void RpbSearchQueryReq::set_op(const ::std::string& value) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  op_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.op)
}
inline void RpbSearchQueryReq::set_op(const char* value) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  op_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.op)
}
inline void RpbSearchQueryReq::set_op(const void* value, size_t size) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  op_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.op)
}
inline ::std::string* RpbSearchQueryReq::mutable_op() {
  set_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    op_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.op)
  return op_;
}
inline ::std::string* RpbSearchQueryReq::release_op() {
  clear_has_op();
  if (op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = op_;
    op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_op(::std::string* op) {
  if (op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete op_;
  }
  if (op) {
    set_has_op();
    op_ = op;
  } else {
    clear_has_op();
    op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.op)
}

// repeated bytes fl = 9;
inline int RpbSearchQueryReq::fl_size() const {
  return fl_.size();
}
inline void RpbSearchQueryReq::clear_fl() {
  fl_.Clear();
}
inline const ::std::string& RpbSearchQueryReq::fl(int index) const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.fl)
  return fl_.Get(index);
}
inline ::std::string* RpbSearchQueryReq::mutable_fl(int index) {
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.fl)
  return fl_.Mutable(index);
}
inline void RpbSearchQueryReq::set_fl(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.fl)
  fl_.Mutable(index)->assign(value);
}
inline void RpbSearchQueryReq::set_fl(int index, const char* value) {
  fl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.fl)
}
inline void RpbSearchQueryReq::set_fl(int index, const void* value, size_t size) {
  fl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.fl)
}
inline ::std::string* RpbSearchQueryReq::add_fl() {
  return fl_.Add();
}
inline void RpbSearchQueryReq::add_fl(const ::std::string& value) {
  fl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbSearchQueryReq.fl)
}
inline void RpbSearchQueryReq::add_fl(const char* value) {
  fl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbSearchQueryReq.fl)
}
inline void RpbSearchQueryReq::add_fl(const void* value, size_t size) {
  fl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbSearchQueryReq.fl)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbSearchQueryReq::fl() const {
  // @@protoc_insertion_point(field_list:RpbSearchQueryReq.fl)
  return fl_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbSearchQueryReq::mutable_fl() {
  // @@protoc_insertion_point(field_mutable_list:RpbSearchQueryReq.fl)
  return &fl_;
}

// optional bytes presort = 10;
inline bool RpbSearchQueryReq::has_presort() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbSearchQueryReq::set_has_presort() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbSearchQueryReq::clear_has_presort() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbSearchQueryReq::clear_presort() {
  if (presort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    presort_->clear();
  }
  clear_has_presort();
}
inline const ::std::string& RpbSearchQueryReq::presort() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryReq.presort)
  return *presort_;
}
inline void RpbSearchQueryReq::set_presort(const ::std::string& value) {
  set_has_presort();
  if (presort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    presort_ = new ::std::string;
  }
  presort_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSearchQueryReq.presort)
}
inline void RpbSearchQueryReq::set_presort(const char* value) {
  set_has_presort();
  if (presort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    presort_ = new ::std::string;
  }
  presort_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSearchQueryReq.presort)
}
inline void RpbSearchQueryReq::set_presort(const void* value, size_t size) {
  set_has_presort();
  if (presort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    presort_ = new ::std::string;
  }
  presort_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSearchQueryReq.presort)
}
inline ::std::string* RpbSearchQueryReq::mutable_presort() {
  set_has_presort();
  if (presort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    presort_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryReq.presort)
  return presort_;
}
inline ::std::string* RpbSearchQueryReq::release_presort() {
  clear_has_presort();
  if (presort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = presort_;
    presort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSearchQueryReq::set_allocated_presort(::std::string* presort) {
  if (presort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete presort_;
  }
  if (presort) {
    set_has_presort();
    presort_ = presort;
  } else {
    clear_has_presort();
    presort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSearchQueryReq.presort)
}

// -------------------------------------------------------------------

// RpbSearchQueryResp

// repeated .RpbSearchDoc docs = 1;
inline int RpbSearchQueryResp::docs_size() const {
  return docs_.size();
}
inline void RpbSearchQueryResp::clear_docs() {
  docs_.Clear();
}
inline const ::RpbSearchDoc& RpbSearchQueryResp::docs(int index) const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryResp.docs)
  return docs_.Get(index);
}
inline ::RpbSearchDoc* RpbSearchQueryResp::mutable_docs(int index) {
  // @@protoc_insertion_point(field_mutable:RpbSearchQueryResp.docs)
  return docs_.Mutable(index);
}
inline ::RpbSearchDoc* RpbSearchQueryResp::add_docs() {
  // @@protoc_insertion_point(field_add:RpbSearchQueryResp.docs)
  return docs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbSearchDoc >&
RpbSearchQueryResp::docs() const {
  // @@protoc_insertion_point(field_list:RpbSearchQueryResp.docs)
  return docs_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbSearchDoc >*
RpbSearchQueryResp::mutable_docs() {
  // @@protoc_insertion_point(field_mutable_list:RpbSearchQueryResp.docs)
  return &docs_;
}

// optional float max_score = 2;
inline bool RpbSearchQueryResp::has_max_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSearchQueryResp::set_has_max_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSearchQueryResp::clear_has_max_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSearchQueryResp::clear_max_score() {
  max_score_ = 0;
  clear_has_max_score();
}
inline float RpbSearchQueryResp::max_score() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryResp.max_score)
  return max_score_;
}
inline void RpbSearchQueryResp::set_max_score(float value) {
  set_has_max_score();
  max_score_ = value;
  // @@protoc_insertion_point(field_set:RpbSearchQueryResp.max_score)
}

// optional uint32 num_found = 3;
inline bool RpbSearchQueryResp::has_num_found() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbSearchQueryResp::set_has_num_found() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbSearchQueryResp::clear_has_num_found() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbSearchQueryResp::clear_num_found() {
  num_found_ = 0u;
  clear_has_num_found();
}
inline ::google::protobuf::uint32 RpbSearchQueryResp::num_found() const {
  // @@protoc_insertion_point(field_get:RpbSearchQueryResp.num_found)
  return num_found_;
}
inline void RpbSearchQueryResp::set_num_found(::google::protobuf::uint32 value) {
  set_has_num_found();
  num_found_ = value;
  // @@protoc_insertion_point(field_set:RpbSearchQueryResp.num_found)
}

// -------------------------------------------------------------------

// TsQueryReq

// optional .TsInterpolation query = 1;
inline bool TsQueryReq::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsQueryReq::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsQueryReq::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsQueryReq::clear_query() {
  if (query_ != NULL) query_->::TsInterpolation::Clear();
  clear_has_query();
}
inline const ::TsInterpolation& TsQueryReq::query() const {
  // @@protoc_insertion_point(field_get:TsQueryReq.query)
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::TsInterpolation* TsQueryReq::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::TsInterpolation;
  // @@protoc_insertion_point(field_mutable:TsQueryReq.query)
  return query_;
}
inline ::TsInterpolation* TsQueryReq::release_query() {
  clear_has_query();
  ::TsInterpolation* temp = query_;
  query_ = NULL;
  return temp;
}
inline void TsQueryReq::set_allocated_query(::TsInterpolation* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:TsQueryReq.query)
}

// optional bool stream = 2 [default = false];
inline bool TsQueryReq::has_stream() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsQueryReq::set_has_stream() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsQueryReq::clear_has_stream() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsQueryReq::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool TsQueryReq::stream() const {
  // @@protoc_insertion_point(field_get:TsQueryReq.stream)
  return stream_;
}
inline void TsQueryReq::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:TsQueryReq.stream)
}

// optional bytes cover_context = 3;
inline bool TsQueryReq::has_cover_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsQueryReq::set_has_cover_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsQueryReq::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsQueryReq::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& TsQueryReq::cover_context() const {
  // @@protoc_insertion_point(field_get:TsQueryReq.cover_context)
  return *cover_context_;
}
inline void TsQueryReq::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:TsQueryReq.cover_context)
}
inline void TsQueryReq::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsQueryReq.cover_context)
}
inline void TsQueryReq::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsQueryReq.cover_context)
}
inline ::std::string* TsQueryReq::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsQueryReq.cover_context)
  return cover_context_;
}
inline ::std::string* TsQueryReq::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsQueryReq::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsQueryReq.cover_context)
}

// -------------------------------------------------------------------

// TsQueryResp

// repeated .TsColumnDescription columns = 1;
inline int TsQueryResp::columns_size() const {
  return columns_.size();
}
inline void TsQueryResp::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsQueryResp::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsQueryResp.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsQueryResp::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsQueryResp.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsQueryResp::add_columns() {
  // @@protoc_insertion_point(field_add:TsQueryResp.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsQueryResp::columns() const {
  // @@protoc_insertion_point(field_list:TsQueryResp.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsQueryResp::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsQueryResp.columns)
  return &columns_;
}

// repeated .TsRow rows = 2;
inline int TsQueryResp::rows_size() const {
  return rows_.size();
}
inline void TsQueryResp::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsQueryResp::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsQueryResp.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsQueryResp::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsQueryResp.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsQueryResp::add_rows() {
  // @@protoc_insertion_point(field_add:TsQueryResp.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsQueryResp::rows() const {
  // @@protoc_insertion_point(field_list:TsQueryResp.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsQueryResp::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsQueryResp.rows)
  return &rows_;
}

// optional bool done = 3 [default = true];
inline bool TsQueryResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsQueryResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsQueryResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsQueryResp::clear_done() {
  done_ = true;
  clear_has_done();
}
inline bool TsQueryResp::done() const {
  // @@protoc_insertion_point(field_get:TsQueryResp.done)
  return done_;
}
inline void TsQueryResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:TsQueryResp.done)
}

// -------------------------------------------------------------------

// TsGetReq

// required bytes table = 1;
inline bool TsGetReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsGetReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsGetReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsGetReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsGetReq::table() const {
  // @@protoc_insertion_point(field_get:TsGetReq.table)
  return *table_;
}
inline void TsGetReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsGetReq.table)
}
inline void TsGetReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsGetReq.table)
}
inline void TsGetReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsGetReq.table)
}
inline ::std::string* TsGetReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsGetReq.table)
  return table_;
}
inline ::std::string* TsGetReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsGetReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsGetReq.table)
}

// repeated .TsCell key = 2;
inline int TsGetReq::key_size() const {
  return key_.size();
}
inline void TsGetReq::clear_key() {
  key_.Clear();
}
inline const ::TsCell& TsGetReq::key(int index) const {
  // @@protoc_insertion_point(field_get:TsGetReq.key)
  return key_.Get(index);
}
inline ::TsCell* TsGetReq::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:TsGetReq.key)
  return key_.Mutable(index);
}
inline ::TsCell* TsGetReq::add_key() {
  // @@protoc_insertion_point(field_add:TsGetReq.key)
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
TsGetReq::key() const {
  // @@protoc_insertion_point(field_list:TsGetReq.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
TsGetReq::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:TsGetReq.key)
  return &key_;
}

// optional uint32 timeout = 3;
inline bool TsGetReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsGetReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsGetReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsGetReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TsGetReq::timeout() const {
  // @@protoc_insertion_point(field_get:TsGetReq.timeout)
  return timeout_;
}
inline void TsGetReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:TsGetReq.timeout)
}

// -------------------------------------------------------------------

// TsGetResp

// repeated .TsColumnDescription columns = 1;
inline int TsGetResp::columns_size() const {
  return columns_.size();
}
inline void TsGetResp::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsGetResp::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsGetResp.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsGetResp::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsGetResp.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsGetResp::add_columns() {
  // @@protoc_insertion_point(field_add:TsGetResp.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsGetResp::columns() const {
  // @@protoc_insertion_point(field_list:TsGetResp.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsGetResp::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsGetResp.columns)
  return &columns_;
}

// repeated .TsRow rows = 2;
inline int TsGetResp::rows_size() const {
  return rows_.size();
}
inline void TsGetResp::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsGetResp::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsGetResp.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsGetResp::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsGetResp.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsGetResp::add_rows() {
  // @@protoc_insertion_point(field_add:TsGetResp.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsGetResp::rows() const {
  // @@protoc_insertion_point(field_list:TsGetResp.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsGetResp::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsGetResp.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// TsPutReq

// required bytes table = 1;
inline bool TsPutReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsPutReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsPutReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsPutReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsPutReq::table() const {
  // @@protoc_insertion_point(field_get:TsPutReq.table)
  return *table_;
}
inline void TsPutReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsPutReq.table)
}
inline void TsPutReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsPutReq.table)
}
inline void TsPutReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsPutReq.table)
}
inline ::std::string* TsPutReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsPutReq.table)
  return table_;
}
inline ::std::string* TsPutReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsPutReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsPutReq.table)
}

// repeated .TsColumnDescription columns = 2;
inline int TsPutReq::columns_size() const {
  return columns_.size();
}
inline void TsPutReq::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsPutReq::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsPutReq.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsPutReq::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsPutReq.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsPutReq::add_columns() {
  // @@protoc_insertion_point(field_add:TsPutReq.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsPutReq::columns() const {
  // @@protoc_insertion_point(field_list:TsPutReq.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsPutReq::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsPutReq.columns)
  return &columns_;
}

// repeated .TsRow rows = 3;
inline int TsPutReq::rows_size() const {
  return rows_.size();
}
inline void TsPutReq::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsPutReq::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsPutReq.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsPutReq::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsPutReq.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsPutReq::add_rows() {
  // @@protoc_insertion_point(field_add:TsPutReq.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsPutReq::rows() const {
  // @@protoc_insertion_point(field_list:TsPutReq.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsPutReq::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsPutReq.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// TsTtbPutReq

// required bytes table = 1;
inline bool TsTtbPutReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsTtbPutReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsTtbPutReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsTtbPutReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsTtbPutReq::table() const {
  // @@protoc_insertion_point(field_get:TsTtbPutReq.table)
  return *table_;
}
inline void TsTtbPutReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsTtbPutReq.table)
}
inline void TsTtbPutReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsTtbPutReq.table)
}
inline void TsTtbPutReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsTtbPutReq.table)
}
inline ::std::string* TsTtbPutReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsTtbPutReq.table)
  return table_;
}
inline ::std::string* TsTtbPutReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsTtbPutReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsTtbPutReq.table)
}

// repeated .TsColumnDescription columns = 2;
inline int TsTtbPutReq::columns_size() const {
  return columns_.size();
}
inline void TsTtbPutReq::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsTtbPutReq::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsTtbPutReq.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsTtbPutReq::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsTtbPutReq.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsTtbPutReq::add_columns() {
  // @@protoc_insertion_point(field_add:TsTtbPutReq.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsTtbPutReq::columns() const {
  // @@protoc_insertion_point(field_list:TsTtbPutReq.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsTtbPutReq::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsTtbPutReq.columns)
  return &columns_;
}

// repeated .TsRow rows = 3;
inline int TsTtbPutReq::rows_size() const {
  return rows_.size();
}
inline void TsTtbPutReq::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsTtbPutReq::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsTtbPutReq.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsTtbPutReq::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsTtbPutReq.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsTtbPutReq::add_rows() {
  // @@protoc_insertion_point(field_add:TsTtbPutReq.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsTtbPutReq::rows() const {
  // @@protoc_insertion_point(field_list:TsTtbPutReq.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsTtbPutReq::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsTtbPutReq.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// TsPutResp

// -------------------------------------------------------------------

// TsDelReq

// required bytes table = 1;
inline bool TsDelReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsDelReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsDelReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsDelReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsDelReq::table() const {
  // @@protoc_insertion_point(field_get:TsDelReq.table)
  return *table_;
}
inline void TsDelReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsDelReq.table)
}
inline void TsDelReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsDelReq.table)
}
inline void TsDelReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsDelReq.table)
}
inline ::std::string* TsDelReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsDelReq.table)
  return table_;
}
inline ::std::string* TsDelReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsDelReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsDelReq.table)
}

// repeated .TsCell key = 2;
inline int TsDelReq::key_size() const {
  return key_.size();
}
inline void TsDelReq::clear_key() {
  key_.Clear();
}
inline const ::TsCell& TsDelReq::key(int index) const {
  // @@protoc_insertion_point(field_get:TsDelReq.key)
  return key_.Get(index);
}
inline ::TsCell* TsDelReq::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:TsDelReq.key)
  return key_.Mutable(index);
}
inline ::TsCell* TsDelReq::add_key() {
  // @@protoc_insertion_point(field_add:TsDelReq.key)
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
TsDelReq::key() const {
  // @@protoc_insertion_point(field_list:TsDelReq.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
TsDelReq::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:TsDelReq.key)
  return &key_;
}

// optional bytes vclock = 3;
inline bool TsDelReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsDelReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsDelReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsDelReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& TsDelReq::vclock() const {
  // @@protoc_insertion_point(field_get:TsDelReq.vclock)
  return *vclock_;
}
inline void TsDelReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:TsDelReq.vclock)
}
inline void TsDelReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsDelReq.vclock)
}
inline void TsDelReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsDelReq.vclock)
}
inline ::std::string* TsDelReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsDelReq.vclock)
  return vclock_;
}
inline ::std::string* TsDelReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsDelReq::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsDelReq.vclock)
}

// optional uint32 timeout = 4;
inline bool TsDelReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsDelReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsDelReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsDelReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TsDelReq::timeout() const {
  // @@protoc_insertion_point(field_get:TsDelReq.timeout)
  return timeout_;
}
inline void TsDelReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:TsDelReq.timeout)
}

// -------------------------------------------------------------------

// TsDelResp

// -------------------------------------------------------------------

// TsInterpolation

// required bytes base = 1;
inline bool TsInterpolation::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsInterpolation::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsInterpolation::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsInterpolation::clear_base() {
  if (base_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_->clear();
  }
  clear_has_base();
}
inline const ::std::string& TsInterpolation::base() const {
  // @@protoc_insertion_point(field_get:TsInterpolation.base)
  return *base_;
}
inline void TsInterpolation::set_base(const ::std::string& value) {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  base_->assign(value);
  // @@protoc_insertion_point(field_set:TsInterpolation.base)
}
inline void TsInterpolation::set_base(const char* value) {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  base_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsInterpolation.base)
}
inline void TsInterpolation::set_base(const void* value, size_t size) {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  base_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsInterpolation.base)
}
inline ::std::string* TsInterpolation::mutable_base() {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsInterpolation.base)
  return base_;
}
inline ::std::string* TsInterpolation::release_base() {
  clear_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = base_;
    base_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsInterpolation::set_allocated_base(::std::string* base) {
  if (base_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete base_;
  }
  if (base) {
    set_has_base();
    base_ = base;
  } else {
    clear_has_base();
    base_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsInterpolation.base)
}

// repeated .RpbPair interpolations = 2;
inline int TsInterpolation::interpolations_size() const {
  return interpolations_.size();
}
inline void TsInterpolation::clear_interpolations() {
  interpolations_.Clear();
}
inline const ::RpbPair& TsInterpolation::interpolations(int index) const {
  // @@protoc_insertion_point(field_get:TsInterpolation.interpolations)
  return interpolations_.Get(index);
}
inline ::RpbPair* TsInterpolation::mutable_interpolations(int index) {
  // @@protoc_insertion_point(field_mutable:TsInterpolation.interpolations)
  return interpolations_.Mutable(index);
}
inline ::RpbPair* TsInterpolation::add_interpolations() {
  // @@protoc_insertion_point(field_add:TsInterpolation.interpolations)
  return interpolations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
TsInterpolation::interpolations() const {
  // @@protoc_insertion_point(field_list:TsInterpolation.interpolations)
  return interpolations_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
TsInterpolation::mutable_interpolations() {
  // @@protoc_insertion_point(field_mutable_list:TsInterpolation.interpolations)
  return &interpolations_;
}

// -------------------------------------------------------------------

// TsColumnDescription

// required bytes name = 1;
inline bool TsColumnDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsColumnDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsColumnDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsColumnDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TsColumnDescription::name() const {
  // @@protoc_insertion_point(field_get:TsColumnDescription.name)
  return *name_;
}
inline void TsColumnDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:TsColumnDescription.name)
}
inline void TsColumnDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsColumnDescription.name)
}
inline void TsColumnDescription::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsColumnDescription.name)
}
inline ::std::string* TsColumnDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsColumnDescription.name)
  return name_;
}
inline ::std::string* TsColumnDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsColumnDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsColumnDescription.name)
}

// required .TsColumnType type = 2;
inline bool TsColumnDescription::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsColumnDescription::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsColumnDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsColumnDescription::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TsColumnType TsColumnDescription::type() const {
  // @@protoc_insertion_point(field_get:TsColumnDescription.type)
  return static_cast< ::TsColumnType >(type_);
}
inline void TsColumnDescription::set_type(::TsColumnType value) {
  assert(::TsColumnType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TsColumnDescription.type)
}

// -------------------------------------------------------------------

// TsRow

// repeated .TsCell cells = 1;
inline int TsRow::cells_size() const {
  return cells_.size();
}
inline void TsRow::clear_cells() {
  cells_.Clear();
}
inline const ::TsCell& TsRow::cells(int index) const {
  // @@protoc_insertion_point(field_get:TsRow.cells)
  return cells_.Get(index);
}
inline ::TsCell* TsRow::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:TsRow.cells)
  return cells_.Mutable(index);
}
inline ::TsCell* TsRow::add_cells() {
  // @@protoc_insertion_point(field_add:TsRow.cells)
  return cells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
TsRow::cells() const {
  // @@protoc_insertion_point(field_list:TsRow.cells)
  return cells_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
TsRow::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:TsRow.cells)
  return &cells_;
}

// -------------------------------------------------------------------

// TsCell

// optional bytes varchar_value = 1;
inline bool TsCell::has_varchar_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsCell::set_has_varchar_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsCell::clear_has_varchar_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsCell::clear_varchar_value() {
  if (varchar_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_->clear();
  }
  clear_has_varchar_value();
}
inline const ::std::string& TsCell::varchar_value() const {
  // @@protoc_insertion_point(field_get:TsCell.varchar_value)
  return *varchar_value_;
}
inline void TsCell::set_varchar_value(const ::std::string& value) {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  varchar_value_->assign(value);
  // @@protoc_insertion_point(field_set:TsCell.varchar_value)
}
inline void TsCell::set_varchar_value(const char* value) {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  varchar_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCell.varchar_value)
}
inline void TsCell::set_varchar_value(const void* value, size_t size) {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  varchar_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCell.varchar_value)
}
inline ::std::string* TsCell::mutable_varchar_value() {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCell.varchar_value)
  return varchar_value_;
}
inline ::std::string* TsCell::release_varchar_value() {
  clear_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = varchar_value_;
    varchar_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCell::set_allocated_varchar_value(::std::string* varchar_value) {
  if (varchar_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete varchar_value_;
  }
  if (varchar_value) {
    set_has_varchar_value();
    varchar_value_ = varchar_value;
  } else {
    clear_has_varchar_value();
    varchar_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCell.varchar_value)
}

// optional sint64 sint64_value = 2;
inline bool TsCell::has_sint64_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsCell::set_has_sint64_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsCell::clear_has_sint64_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsCell::clear_sint64_value() {
  sint64_value_ = GOOGLE_LONGLONG(0);
  clear_has_sint64_value();
}
inline ::google::protobuf::int64 TsCell::sint64_value() const {
  // @@protoc_insertion_point(field_get:TsCell.sint64_value)
  return sint64_value_;
}
inline void TsCell::set_sint64_value(::google::protobuf::int64 value) {
  set_has_sint64_value();
  sint64_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.sint64_value)
}

// optional sint64 timestamp_value = 3;
inline bool TsCell::has_timestamp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsCell::set_has_timestamp_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsCell::clear_has_timestamp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsCell::clear_timestamp_value() {
  timestamp_value_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_value();
}
inline ::google::protobuf::int64 TsCell::timestamp_value() const {
  // @@protoc_insertion_point(field_get:TsCell.timestamp_value)
  return timestamp_value_;
}
inline void TsCell::set_timestamp_value(::google::protobuf::int64 value) {
  set_has_timestamp_value();
  timestamp_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.timestamp_value)
}

// optional bool boolean_value = 4;
inline bool TsCell::has_boolean_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsCell::set_has_boolean_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsCell::clear_has_boolean_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsCell::clear_boolean_value() {
  boolean_value_ = false;
  clear_has_boolean_value();
}
inline bool TsCell::boolean_value() const {
  // @@protoc_insertion_point(field_get:TsCell.boolean_value)
  return boolean_value_;
}
inline void TsCell::set_boolean_value(bool value) {
  set_has_boolean_value();
  boolean_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.boolean_value)
}

// optional double double_value = 5;
inline bool TsCell::has_double_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TsCell::set_has_double_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TsCell::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TsCell::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double TsCell::double_value() const {
  // @@protoc_insertion_point(field_get:TsCell.double_value)
  return double_value_;
}
inline void TsCell::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.double_value)
}

// -------------------------------------------------------------------

// TsListKeysReq

// required bytes table = 1;
inline bool TsListKeysReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsListKeysReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsListKeysReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsListKeysReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsListKeysReq::table() const {
  // @@protoc_insertion_point(field_get:TsListKeysReq.table)
  return *table_;
}
inline void TsListKeysReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsListKeysReq.table)
}
inline void TsListKeysReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsListKeysReq.table)
}
inline void TsListKeysReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsListKeysReq.table)
}
inline ::std::string* TsListKeysReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsListKeysReq.table)
  return table_;
}
inline ::std::string* TsListKeysReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsListKeysReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsListKeysReq.table)
}

// optional uint32 timeout = 2;
inline bool TsListKeysReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsListKeysReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsListKeysReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsListKeysReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TsListKeysReq::timeout() const {
  // @@protoc_insertion_point(field_get:TsListKeysReq.timeout)
  return timeout_;
}
inline void TsListKeysReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:TsListKeysReq.timeout)
}

// -------------------------------------------------------------------

// TsListKeysResp

// repeated .TsRow keys = 1;
inline int TsListKeysResp::keys_size() const {
  return keys_.size();
}
inline void TsListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::TsRow& TsListKeysResp::keys(int index) const {
  // @@protoc_insertion_point(field_get:TsListKeysResp.keys)
  return keys_.Get(index);
}
inline ::TsRow* TsListKeysResp::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:TsListKeysResp.keys)
  return keys_.Mutable(index);
}
inline ::TsRow* TsListKeysResp::add_keys() {
  // @@protoc_insertion_point(field_add:TsListKeysResp.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsListKeysResp::keys() const {
  // @@protoc_insertion_point(field_list:TsListKeysResp.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsListKeysResp::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:TsListKeysResp.keys)
  return &keys_;
}

// optional bool done = 2;
inline bool TsListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool TsListKeysResp::done() const {
  // @@protoc_insertion_point(field_get:TsListKeysResp.done)
  return done_;
}
inline void TsListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:TsListKeysResp.done)
}

// -------------------------------------------------------------------

// TsCoverageReq

// optional .TsInterpolation query = 1;
inline bool TsCoverageReq::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsCoverageReq::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsCoverageReq::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsCoverageReq::clear_query() {
  if (query_ != NULL) query_->::TsInterpolation::Clear();
  clear_has_query();
}
inline const ::TsInterpolation& TsCoverageReq::query() const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.query)
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::TsInterpolation* TsCoverageReq::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::TsInterpolation;
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.query)
  return query_;
}
inline ::TsInterpolation* TsCoverageReq::release_query() {
  clear_has_query();
  ::TsInterpolation* temp = query_;
  query_ = NULL;
  return temp;
}
inline void TsCoverageReq::set_allocated_query(::TsInterpolation* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageReq.query)
}

// required bytes table = 2;
inline bool TsCoverageReq::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsCoverageReq::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsCoverageReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsCoverageReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsCoverageReq::table() const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.table)
  return *table_;
}
inline void TsCoverageReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageReq.table)
}
inline void TsCoverageReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageReq.table)
}
inline void TsCoverageReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageReq.table)
}
inline ::std::string* TsCoverageReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.table)
  return table_;
}
inline ::std::string* TsCoverageReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageReq.table)
}

// optional bytes replace_cover = 3;
inline bool TsCoverageReq::has_replace_cover() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsCoverageReq::set_has_replace_cover() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsCoverageReq::clear_has_replace_cover() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsCoverageReq::clear_replace_cover() {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_->clear();
  }
  clear_has_replace_cover();
}
inline const ::std::string& TsCoverageReq::replace_cover() const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.replace_cover)
  return *replace_cover_;
}
inline void TsCoverageReq::set_replace_cover(const ::std::string& value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageReq.replace_cover)
}
inline void TsCoverageReq::set_replace_cover(const char* value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageReq.replace_cover)
}
inline void TsCoverageReq::set_replace_cover(const void* value, size_t size) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageReq.replace_cover)
}
inline ::std::string* TsCoverageReq::mutable_replace_cover() {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.replace_cover)
  return replace_cover_;
}
inline ::std::string* TsCoverageReq::release_replace_cover() {
  clear_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = replace_cover_;
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageReq::set_allocated_replace_cover(::std::string* replace_cover) {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete replace_cover_;
  }
  if (replace_cover) {
    set_has_replace_cover();
    replace_cover_ = replace_cover;
  } else {
    clear_has_replace_cover();
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageReq.replace_cover)
}

// repeated bytes unavailable_cover = 4;
inline int TsCoverageReq::unavailable_cover_size() const {
  return unavailable_cover_.size();
}
inline void TsCoverageReq::clear_unavailable_cover() {
  unavailable_cover_.Clear();
}
inline const ::std::string& TsCoverageReq::unavailable_cover(int index) const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.unavailable_cover)
  return unavailable_cover_.Get(index);
}
inline ::std::string* TsCoverageReq::mutable_unavailable_cover(int index) {
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.unavailable_cover)
  return unavailable_cover_.Mutable(index);
}
inline void TsCoverageReq::set_unavailable_cover(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TsCoverageReq.unavailable_cover)
  unavailable_cover_.Mutable(index)->assign(value);
}
inline void TsCoverageReq::set_unavailable_cover(int index, const char* value) {
  unavailable_cover_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageReq.unavailable_cover)
}
inline void TsCoverageReq::set_unavailable_cover(int index, const void* value, size_t size) {
  unavailable_cover_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageReq.unavailable_cover)
}
inline ::std::string* TsCoverageReq::add_unavailable_cover() {
  return unavailable_cover_.Add();
}
inline void TsCoverageReq::add_unavailable_cover(const ::std::string& value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TsCoverageReq.unavailable_cover)
}
inline void TsCoverageReq::add_unavailable_cover(const char* value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TsCoverageReq.unavailable_cover)
}
inline void TsCoverageReq::add_unavailable_cover(const void* value, size_t size) {
  unavailable_cover_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TsCoverageReq.unavailable_cover)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TsCoverageReq::unavailable_cover() const {
  // @@protoc_insertion_point(field_list:TsCoverageReq.unavailable_cover)
  return unavailable_cover_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TsCoverageReq::mutable_unavailable_cover() {
  // @@protoc_insertion_point(field_mutable_list:TsCoverageReq.unavailable_cover)
  return &unavailable_cover_;
}

// -------------------------------------------------------------------

// TsCoverageResp

// repeated .TsCoverageEntry entries = 1;
inline int TsCoverageResp::entries_size() const {
  return entries_.size();
}
inline void TsCoverageResp::clear_entries() {
  entries_.Clear();
}
inline const ::TsCoverageEntry& TsCoverageResp::entries(int index) const {
  // @@protoc_insertion_point(field_get:TsCoverageResp.entries)
  return entries_.Get(index);
}
inline ::TsCoverageEntry* TsCoverageResp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TsCoverageResp.entries)
  return entries_.Mutable(index);
}
inline ::TsCoverageEntry* TsCoverageResp::add_entries() {
  // @@protoc_insertion_point(field_add:TsCoverageResp.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >&
TsCoverageResp::entries() const {
  // @@protoc_insertion_point(field_list:TsCoverageResp.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >*
TsCoverageResp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TsCoverageResp.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// TsCoverageEntry

// required bytes ip = 1;
inline bool TsCoverageEntry::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsCoverageEntry::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsCoverageEntry::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsCoverageEntry::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TsCoverageEntry::ip() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.ip)
  return *ip_;
}
inline void TsCoverageEntry::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageEntry.ip)
}
inline void TsCoverageEntry::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageEntry.ip)
}
inline void TsCoverageEntry::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageEntry.ip)
}
inline ::std::string* TsCoverageEntry::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageEntry.ip)
  return ip_;
}
inline ::std::string* TsCoverageEntry::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageEntry::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageEntry.ip)
}

// required uint32 port = 2;
inline bool TsCoverageEntry::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsCoverageEntry::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsCoverageEntry::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsCoverageEntry::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TsCoverageEntry::port() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.port)
  return port_;
}
inline void TsCoverageEntry::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:TsCoverageEntry.port)
}

// required bytes cover_context = 3;
inline bool TsCoverageEntry::has_cover_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsCoverageEntry::set_has_cover_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsCoverageEntry::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsCoverageEntry::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& TsCoverageEntry::cover_context() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.cover_context)
  return *cover_context_;
}
inline void TsCoverageEntry::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageEntry.cover_context)
}
inline void TsCoverageEntry::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageEntry.cover_context)
}
inline void TsCoverageEntry::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageEntry.cover_context)
}
inline ::std::string* TsCoverageEntry::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageEntry.cover_context)
  return cover_context_;
}
inline ::std::string* TsCoverageEntry::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageEntry::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageEntry.cover_context)
}

// optional .TsRange range = 4;
inline bool TsCoverageEntry::has_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsCoverageEntry::set_has_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsCoverageEntry::clear_has_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsCoverageEntry::clear_range() {
  if (range_ != NULL) range_->::TsRange::Clear();
  clear_has_range();
}
inline const ::TsRange& TsCoverageEntry::range() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.range)
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::TsRange* TsCoverageEntry::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::TsRange;
  // @@protoc_insertion_point(field_mutable:TsCoverageEntry.range)
  return range_;
}
inline ::TsRange* TsCoverageEntry::release_range() {
  clear_has_range();
  ::TsRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline void TsCoverageEntry::set_allocated_range(::TsRange* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageEntry.range)
}

// -------------------------------------------------------------------

// TsRange

// required bytes field_name = 1;
inline bool TsRange::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsRange::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsRange::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsRange::clear_field_name() {
  if (field_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_->clear();
  }
  clear_has_field_name();
}
inline const ::std::string& TsRange::field_name() const {
  // @@protoc_insertion_point(field_get:TsRange.field_name)
  return *field_name_;
}
inline void TsRange::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
  // @@protoc_insertion_point(field_set:TsRange.field_name)
}
inline void TsRange::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsRange.field_name)
}
inline void TsRange::set_field_name(const void* value, size_t size) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsRange.field_name)
}
inline ::std::string* TsRange::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsRange.field_name)
  return field_name_;
}
inline ::std::string* TsRange::release_field_name() {
  clear_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsRange::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsRange.field_name)
}

// required sint64 lower_bound = 2;
inline bool TsRange::has_lower_bound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsRange::set_has_lower_bound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsRange::clear_has_lower_bound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsRange::clear_lower_bound() {
  lower_bound_ = GOOGLE_LONGLONG(0);
  clear_has_lower_bound();
}
inline ::google::protobuf::int64 TsRange::lower_bound() const {
  // @@protoc_insertion_point(field_get:TsRange.lower_bound)
  return lower_bound_;
}
inline void TsRange::set_lower_bound(::google::protobuf::int64 value) {
  set_has_lower_bound();
  lower_bound_ = value;
  // @@protoc_insertion_point(field_set:TsRange.lower_bound)
}

// required bool lower_bound_inclusive = 3;
inline bool TsRange::has_lower_bound_inclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsRange::set_has_lower_bound_inclusive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsRange::clear_has_lower_bound_inclusive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsRange::clear_lower_bound_inclusive() {
  lower_bound_inclusive_ = false;
  clear_has_lower_bound_inclusive();
}
inline bool TsRange::lower_bound_inclusive() const {
  // @@protoc_insertion_point(field_get:TsRange.lower_bound_inclusive)
  return lower_bound_inclusive_;
}
inline void TsRange::set_lower_bound_inclusive(bool value) {
  set_has_lower_bound_inclusive();
  lower_bound_inclusive_ = value;
  // @@protoc_insertion_point(field_set:TsRange.lower_bound_inclusive)
}

// required sint64 upper_bound = 4;
inline bool TsRange::has_upper_bound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsRange::set_has_upper_bound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsRange::clear_has_upper_bound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsRange::clear_upper_bound() {
  upper_bound_ = GOOGLE_LONGLONG(0);
  clear_has_upper_bound();
}
inline ::google::protobuf::int64 TsRange::upper_bound() const {
  // @@protoc_insertion_point(field_get:TsRange.upper_bound)
  return upper_bound_;
}
inline void TsRange::set_upper_bound(::google::protobuf::int64 value) {
  set_has_upper_bound();
  upper_bound_ = value;
  // @@protoc_insertion_point(field_set:TsRange.upper_bound)
}

// required bool upper_bound_inclusive = 5;
inline bool TsRange::has_upper_bound_inclusive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TsRange::set_has_upper_bound_inclusive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TsRange::clear_has_upper_bound_inclusive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TsRange::clear_upper_bound_inclusive() {
  upper_bound_inclusive_ = false;
  clear_has_upper_bound_inclusive();
}
inline bool TsRange::upper_bound_inclusive() const {
  // @@protoc_insertion_point(field_get:TsRange.upper_bound_inclusive)
  return upper_bound_inclusive_;
}
inline void TsRange::set_upper_bound_inclusive(bool value) {
  set_has_upper_bound_inclusive();
  upper_bound_inclusive_ = value;
  // @@protoc_insertion_point(field_set:TsRange.upper_bound_inclusive)
}

// required bytes desc = 6;
inline bool TsRange::has_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TsRange::set_has_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TsRange::clear_has_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TsRange::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TsRange::desc() const {
  // @@protoc_insertion_point(field_get:TsRange.desc)
  return *desc_;
}
inline void TsRange::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:TsRange.desc)
}
inline void TsRange::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsRange.desc)
}
inline void TsRange::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsRange.desc)
}
inline ::std::string* TsRange::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsRange.desc)
  return desc_;
}
inline ::std::string* TsRange::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsRange::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsRange.desc)
}

// -------------------------------------------------------------------

// RpbYokozunaIndex

// required bytes name = 1;
inline bool RpbYokozunaIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpbYokozunaIndex::name() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndex.name)
  return *name_;
}
inline void RpbYokozunaIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaIndex.name)
}
inline void RpbYokozunaIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaIndex.name)
}
inline void RpbYokozunaIndex::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaIndex.name)
}
inline ::std::string* RpbYokozunaIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaIndex.name)
  return name_;
}
inline ::std::string* RpbYokozunaIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaIndex.name)
}

// optional bytes schema = 2;
inline bool RpbYokozunaIndex::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbYokozunaIndex::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbYokozunaIndex::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbYokozunaIndex::clear_schema() {
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_->clear();
  }
  clear_has_schema();
}
inline const ::std::string& RpbYokozunaIndex::schema() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndex.schema)
  return *schema_;
}
inline void RpbYokozunaIndex::set_schema(const ::std::string& value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaIndex.schema)
}
inline void RpbYokozunaIndex::set_schema(const char* value) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaIndex.schema)
}
inline void RpbYokozunaIndex::set_schema(const void* value, size_t size) {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaIndex.schema)
}
inline ::std::string* RpbYokozunaIndex::mutable_schema() {
  set_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaIndex.schema)
  return schema_;
}
inline ::std::string* RpbYokozunaIndex::release_schema() {
  clear_has_schema();
  if (schema_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_;
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaIndex::set_allocated_schema(::std::string* schema) {
  if (schema_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_;
  }
  if (schema) {
    set_has_schema();
    schema_ = schema;
  } else {
    clear_has_schema();
    schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaIndex.schema)
}

// optional uint32 n_val = 3;
inline bool RpbYokozunaIndex::has_n_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbYokozunaIndex::set_has_n_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbYokozunaIndex::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbYokozunaIndex::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbYokozunaIndex::n_val() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndex.n_val)
  return n_val_;
}
inline void RpbYokozunaIndex::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbYokozunaIndex.n_val)
}

// -------------------------------------------------------------------

// RpbYokozunaIndexGetReq

// optional bytes name = 1;
inline bool RpbYokozunaIndexGetReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaIndexGetReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaIndexGetReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaIndexGetReq::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpbYokozunaIndexGetReq::name() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndexGetReq.name)
  return *name_;
}
inline void RpbYokozunaIndexGetReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaIndexGetReq.name)
}
inline void RpbYokozunaIndexGetReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaIndexGetReq.name)
}
inline void RpbYokozunaIndexGetReq::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaIndexGetReq.name)
}
inline ::std::string* RpbYokozunaIndexGetReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaIndexGetReq.name)
  return name_;
}
inline ::std::string* RpbYokozunaIndexGetReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaIndexGetReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaIndexGetReq.name)
}

// -------------------------------------------------------------------

// RpbYokozunaIndexGetResp

// repeated .RpbYokozunaIndex index = 1;
inline int RpbYokozunaIndexGetResp::index_size() const {
  return index_.size();
}
inline void RpbYokozunaIndexGetResp::clear_index() {
  index_.Clear();
}
inline const ::RpbYokozunaIndex& RpbYokozunaIndexGetResp::index(int index) const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndexGetResp.index)
  return index_.Get(index);
}
inline ::RpbYokozunaIndex* RpbYokozunaIndexGetResp::mutable_index(int index) {
  // @@protoc_insertion_point(field_mutable:RpbYokozunaIndexGetResp.index)
  return index_.Mutable(index);
}
inline ::RpbYokozunaIndex* RpbYokozunaIndexGetResp::add_index() {
  // @@protoc_insertion_point(field_add:RpbYokozunaIndexGetResp.index)
  return index_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbYokozunaIndex >&
RpbYokozunaIndexGetResp::index() const {
  // @@protoc_insertion_point(field_list:RpbYokozunaIndexGetResp.index)
  return index_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbYokozunaIndex >*
RpbYokozunaIndexGetResp::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:RpbYokozunaIndexGetResp.index)
  return &index_;
}

// -------------------------------------------------------------------

// RpbYokozunaIndexPutReq

// required .RpbYokozunaIndex index = 1;
inline bool RpbYokozunaIndexPutReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaIndexPutReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaIndexPutReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaIndexPutReq::clear_index() {
  if (index_ != NULL) index_->::RpbYokozunaIndex::Clear();
  clear_has_index();
}
inline const ::RpbYokozunaIndex& RpbYokozunaIndexPutReq::index() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndexPutReq.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::RpbYokozunaIndex* RpbYokozunaIndexPutReq::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::RpbYokozunaIndex;
  // @@protoc_insertion_point(field_mutable:RpbYokozunaIndexPutReq.index)
  return index_;
}
inline ::RpbYokozunaIndex* RpbYokozunaIndexPutReq::release_index() {
  clear_has_index();
  ::RpbYokozunaIndex* temp = index_;
  index_ = NULL;
  return temp;
}
inline void RpbYokozunaIndexPutReq::set_allocated_index(::RpbYokozunaIndex* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaIndexPutReq.index)
}

// optional uint32 timeout = 2;
inline bool RpbYokozunaIndexPutReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbYokozunaIndexPutReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbYokozunaIndexPutReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbYokozunaIndexPutReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbYokozunaIndexPutReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndexPutReq.timeout)
  return timeout_;
}
inline void RpbYokozunaIndexPutReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbYokozunaIndexPutReq.timeout)
}

// -------------------------------------------------------------------

// RpbYokozunaIndexDeleteReq

// required bytes name = 1;
inline bool RpbYokozunaIndexDeleteReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaIndexDeleteReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaIndexDeleteReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaIndexDeleteReq::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpbYokozunaIndexDeleteReq::name() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaIndexDeleteReq.name)
  return *name_;
}
inline void RpbYokozunaIndexDeleteReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaIndexDeleteReq.name)
}
inline void RpbYokozunaIndexDeleteReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaIndexDeleteReq.name)
}
inline void RpbYokozunaIndexDeleteReq::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaIndexDeleteReq.name)
}
inline ::std::string* RpbYokozunaIndexDeleteReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaIndexDeleteReq.name)
  return name_;
}
inline ::std::string* RpbYokozunaIndexDeleteReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaIndexDeleteReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaIndexDeleteReq.name)
}

// -------------------------------------------------------------------

// RpbYokozunaSchema

// required bytes name = 1;
inline bool RpbYokozunaSchema::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaSchema::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaSchema::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaSchema::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpbYokozunaSchema::name() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaSchema.name)
  return *name_;
}
inline void RpbYokozunaSchema::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaSchema.name)
}
inline void RpbYokozunaSchema::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaSchema.name)
}
inline void RpbYokozunaSchema::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaSchema.name)
}
inline ::std::string* RpbYokozunaSchema::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaSchema.name)
  return name_;
}
inline ::std::string* RpbYokozunaSchema::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaSchema::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaSchema.name)
}

// optional bytes content = 2;
inline bool RpbYokozunaSchema::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbYokozunaSchema::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbYokozunaSchema::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbYokozunaSchema::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& RpbYokozunaSchema::content() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaSchema.content)
  return *content_;
}
inline void RpbYokozunaSchema::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaSchema.content)
}
inline void RpbYokozunaSchema::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaSchema.content)
}
inline void RpbYokozunaSchema::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaSchema.content)
}
inline ::std::string* RpbYokozunaSchema::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaSchema.content)
  return content_;
}
inline ::std::string* RpbYokozunaSchema::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaSchema::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaSchema.content)
}

// -------------------------------------------------------------------

// RpbYokozunaSchemaPutReq

// required .RpbYokozunaSchema schema = 1;
inline bool RpbYokozunaSchemaPutReq::has_schema() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaSchemaPutReq::set_has_schema() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaSchemaPutReq::clear_has_schema() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaSchemaPutReq::clear_schema() {
  if (schema_ != NULL) schema_->::RpbYokozunaSchema::Clear();
  clear_has_schema();
}
inline const ::RpbYokozunaSchema& RpbYokozunaSchemaPutReq::schema() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaSchemaPutReq.schema)
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::RpbYokozunaSchema* RpbYokozunaSchemaPutReq::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::RpbYokozunaSchema;
  // @@protoc_insertion_point(field_mutable:RpbYokozunaSchemaPutReq.schema)
  return schema_;
}
inline ::RpbYokozunaSchema* RpbYokozunaSchemaPutReq::release_schema() {
  clear_has_schema();
  ::RpbYokozunaSchema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void RpbYokozunaSchemaPutReq::set_allocated_schema(::RpbYokozunaSchema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaSchemaPutReq.schema)
}

// -------------------------------------------------------------------

// RpbYokozunaSchemaGetReq

// required bytes name = 1;
inline bool RpbYokozunaSchemaGetReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaSchemaGetReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaSchemaGetReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaSchemaGetReq::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpbYokozunaSchemaGetReq::name() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaSchemaGetReq.name)
  return *name_;
}
inline void RpbYokozunaSchemaGetReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:RpbYokozunaSchemaGetReq.name)
}
inline void RpbYokozunaSchemaGetReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbYokozunaSchemaGetReq.name)
}
inline void RpbYokozunaSchemaGetReq::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbYokozunaSchemaGetReq.name)
}
inline ::std::string* RpbYokozunaSchemaGetReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbYokozunaSchemaGetReq.name)
  return name_;
}
inline ::std::string* RpbYokozunaSchemaGetReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbYokozunaSchemaGetReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaSchemaGetReq.name)
}

// -------------------------------------------------------------------

// RpbYokozunaSchemaGetResp

// required .RpbYokozunaSchema schema = 1;
inline bool RpbYokozunaSchemaGetResp::has_schema() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbYokozunaSchemaGetResp::set_has_schema() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbYokozunaSchemaGetResp::clear_has_schema() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbYokozunaSchemaGetResp::clear_schema() {
  if (schema_ != NULL) schema_->::RpbYokozunaSchema::Clear();
  clear_has_schema();
}
inline const ::RpbYokozunaSchema& RpbYokozunaSchemaGetResp::schema() const {
  // @@protoc_insertion_point(field_get:RpbYokozunaSchemaGetResp.schema)
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::RpbYokozunaSchema* RpbYokozunaSchemaGetResp::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::RpbYokozunaSchema;
  // @@protoc_insertion_point(field_mutable:RpbYokozunaSchemaGetResp.schema)
  return schema_;
}
inline ::RpbYokozunaSchema* RpbYokozunaSchemaGetResp::release_schema() {
  clear_has_schema();
  ::RpbYokozunaSchema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void RpbYokozunaSchemaGetResp::set_allocated_schema(::RpbYokozunaSchema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbYokozunaSchemaGetResp.schema)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MapField_MapFieldType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapField_MapFieldType>() {
  return ::MapField_MapFieldType_descriptor();
}
template <> struct is_proto_enum< ::DtFetchResp_DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DtFetchResp_DataType>() {
  return ::DtFetchResp_DataType_descriptor();
}
template <> struct is_proto_enum< ::MapUpdate_FlagOp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapUpdate_FlagOp>() {
  return ::MapUpdate_FlagOp_descriptor();
}
template <> struct is_proto_enum< ::RpbIndexReq_IndexQueryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpbIndexReq_IndexQueryType>() {
  return ::RpbIndexReq_IndexQueryType_descriptor();
}
template <> struct is_proto_enum< ::RpbBucketProps_RpbReplMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpbBucketProps_RpbReplMode>() {
  return ::RpbBucketProps_RpbReplMode_descriptor();
}
template <> struct is_proto_enum< ::TsColumnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TsColumnType>() {
  return ::TsColumnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riak_2eproto__INCLUDED
